
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserSession
 * 
 */
export type UserSession = $Result.DefaultSelection<Prisma.$UserSessionPayload>
/**
 * Model UserProfile
 * 
 */
export type UserProfile = $Result.DefaultSelection<Prisma.$UserProfilePayload>
/**
 * Model Vehicle
 * 
 */
export type Vehicle = $Result.DefaultSelection<Prisma.$VehiclePayload>
/**
 * Model Place
 * 
 */
export type Place = $Result.DefaultSelection<Prisma.$PlacePayload>
/**
 * Model ParkingZone
 * 
 */
export type ParkingZone = $Result.DefaultSelection<Prisma.$ParkingZonePayload>
/**
 * Model ParkingSlot
 * 
 */
export type ParkingSlot = $Result.DefaultSelection<Prisma.$ParkingSlotPayload>
/**
 * Model SlotAvailability
 * 
 */
export type SlotAvailability = $Result.DefaultSelection<Prisma.$SlotAvailabilityPayload>
/**
 * Model TariffPlan
 * 
 */
export type TariffPlan = $Result.DefaultSelection<Prisma.$TariffPlanPayload>
/**
 * Model TariffRate
 * 
 */
export type TariffRate = $Result.DefaultSelection<Prisma.$TariffRatePayload>
/**
 * Model Booking
 * 
 */
export type Booking = $Result.DefaultSelection<Prisma.$BookingPayload>
/**
 * Model BookingStatusLog
 * 
 */
export type BookingStatusLog = $Result.DefaultSelection<Prisma.$BookingStatusLogPayload>
/**
 * Model BookingPayment
 * 
 */
export type BookingPayment = $Result.DefaultSelection<Prisma.$BookingPaymentPayload>
/**
 * Model PaymentTransaction
 * 
 */
export type PaymentTransaction = $Result.DefaultSelection<Prisma.$PaymentTransactionPayload>
/**
 * Model RefundTransaction
 * 
 */
export type RefundTransaction = $Result.DefaultSelection<Prisma.$RefundTransactionPayload>
/**
 * Model PaymentMethod
 * 
 */
export type PaymentMethod = $Result.DefaultSelection<Prisma.$PaymentMethodPayload>
/**
 * Model UserPaymentMethod
 * 
 */
export type UserPaymentMethod = $Result.DefaultSelection<Prisma.$UserPaymentMethodPayload>
/**
 * Model PromoCode
 * 
 */
export type PromoCode = $Result.DefaultSelection<Prisma.$PromoCodePayload>
/**
 * Model ParkingPass
 * 
 */
export type ParkingPass = $Result.DefaultSelection<Prisma.$ParkingPassPayload>
/**
 * Model ParkingPassPayment
 * 
 */
export type ParkingPassPayment = $Result.DefaultSelection<Prisma.$ParkingPassPaymentPayload>
/**
 * Model AccessLog
 * 
 */
export type AccessLog = $Result.DefaultSelection<Prisma.$AccessLogPayload>
/**
 * Model BookingExtension
 * 
 */
export type BookingExtension = $Result.DefaultSelection<Prisma.$BookingExtensionPayload>
/**
 * Model NotificationSetting
 * 
 */
export type NotificationSetting = $Result.DefaultSelection<Prisma.$NotificationSettingPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model PlaceRating
 * 
 */
export type PlaceRating = $Result.DefaultSelection<Prisma.$PlaceRatingPayload>
/**
 * Model OperatingHour
 * 
 */
export type OperatingHour = $Result.DefaultSelection<Prisma.$OperatingHourPayload>
/**
 * Model PlaceAdmin
 * 
 */
export type PlaceAdmin = $Result.DefaultSelection<Prisma.$PlaceAdminPayload>
/**
 * Model SystemLog
 * 
 */
export type SystemLog = $Result.DefaultSelection<Prisma.$SystemLogPayload>
/**
 * Model EmailVerificationToken
 * 
 */
export type EmailVerificationToken = $Result.DefaultSelection<Prisma.$EmailVerificationTokenPayload>
/**
 * Model PhoneVerificationOtp
 * 
 */
export type PhoneVerificationOtp = $Result.DefaultSelection<Prisma.$PhoneVerificationOtpPayload>
/**
 * Model PasswordResetToken
 * 
 */
export type PasswordResetToken = $Result.DefaultSelection<Prisma.$PasswordResetTokenPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSession`: Exposes CRUD operations for the **UserSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSessions
    * const userSessions = await prisma.userSession.findMany()
    * ```
    */
  get userSession(): Prisma.UserSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userProfile`: Exposes CRUD operations for the **UserProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserProfiles
    * const userProfiles = await prisma.userProfile.findMany()
    * ```
    */
  get userProfile(): Prisma.UserProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vehicle`: Exposes CRUD operations for the **Vehicle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vehicles
    * const vehicles = await prisma.vehicle.findMany()
    * ```
    */
  get vehicle(): Prisma.VehicleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.place`: Exposes CRUD operations for the **Place** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Places
    * const places = await prisma.place.findMany()
    * ```
    */
  get place(): Prisma.PlaceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.parkingZone`: Exposes CRUD operations for the **ParkingZone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ParkingZones
    * const parkingZones = await prisma.parkingZone.findMany()
    * ```
    */
  get parkingZone(): Prisma.ParkingZoneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.parkingSlot`: Exposes CRUD operations for the **ParkingSlot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ParkingSlots
    * const parkingSlots = await prisma.parkingSlot.findMany()
    * ```
    */
  get parkingSlot(): Prisma.ParkingSlotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.slotAvailability`: Exposes CRUD operations for the **SlotAvailability** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SlotAvailabilities
    * const slotAvailabilities = await prisma.slotAvailability.findMany()
    * ```
    */
  get slotAvailability(): Prisma.SlotAvailabilityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tariffPlan`: Exposes CRUD operations for the **TariffPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TariffPlans
    * const tariffPlans = await prisma.tariffPlan.findMany()
    * ```
    */
  get tariffPlan(): Prisma.TariffPlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tariffRate`: Exposes CRUD operations for the **TariffRate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TariffRates
    * const tariffRates = await prisma.tariffRate.findMany()
    * ```
    */
  get tariffRate(): Prisma.TariffRateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.booking`: Exposes CRUD operations for the **Booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): Prisma.BookingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookingStatusLog`: Exposes CRUD operations for the **BookingStatusLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookingStatusLogs
    * const bookingStatusLogs = await prisma.bookingStatusLog.findMany()
    * ```
    */
  get bookingStatusLog(): Prisma.BookingStatusLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookingPayment`: Exposes CRUD operations for the **BookingPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookingPayments
    * const bookingPayments = await prisma.bookingPayment.findMany()
    * ```
    */
  get bookingPayment(): Prisma.BookingPaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentTransaction`: Exposes CRUD operations for the **PaymentTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentTransactions
    * const paymentTransactions = await prisma.paymentTransaction.findMany()
    * ```
    */
  get paymentTransaction(): Prisma.PaymentTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refundTransaction`: Exposes CRUD operations for the **RefundTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefundTransactions
    * const refundTransactions = await prisma.refundTransaction.findMany()
    * ```
    */
  get refundTransaction(): Prisma.RefundTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentMethod`: Exposes CRUD operations for the **PaymentMethod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentMethods
    * const paymentMethods = await prisma.paymentMethod.findMany()
    * ```
    */
  get paymentMethod(): Prisma.PaymentMethodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPaymentMethod`: Exposes CRUD operations for the **UserPaymentMethod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPaymentMethods
    * const userPaymentMethods = await prisma.userPaymentMethod.findMany()
    * ```
    */
  get userPaymentMethod(): Prisma.UserPaymentMethodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.promoCode`: Exposes CRUD operations for the **PromoCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PromoCodes
    * const promoCodes = await prisma.promoCode.findMany()
    * ```
    */
  get promoCode(): Prisma.PromoCodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.parkingPass`: Exposes CRUD operations for the **ParkingPass** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ParkingPasses
    * const parkingPasses = await prisma.parkingPass.findMany()
    * ```
    */
  get parkingPass(): Prisma.ParkingPassDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.parkingPassPayment`: Exposes CRUD operations for the **ParkingPassPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ParkingPassPayments
    * const parkingPassPayments = await prisma.parkingPassPayment.findMany()
    * ```
    */
  get parkingPassPayment(): Prisma.ParkingPassPaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.accessLog`: Exposes CRUD operations for the **AccessLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccessLogs
    * const accessLogs = await prisma.accessLog.findMany()
    * ```
    */
  get accessLog(): Prisma.AccessLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookingExtension`: Exposes CRUD operations for the **BookingExtension** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookingExtensions
    * const bookingExtensions = await prisma.bookingExtension.findMany()
    * ```
    */
  get bookingExtension(): Prisma.BookingExtensionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationSetting`: Exposes CRUD operations for the **NotificationSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationSettings
    * const notificationSettings = await prisma.notificationSetting.findMany()
    * ```
    */
  get notificationSetting(): Prisma.NotificationSettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.placeRating`: Exposes CRUD operations for the **PlaceRating** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlaceRatings
    * const placeRatings = await prisma.placeRating.findMany()
    * ```
    */
  get placeRating(): Prisma.PlaceRatingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.operatingHour`: Exposes CRUD operations for the **OperatingHour** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OperatingHours
    * const operatingHours = await prisma.operatingHour.findMany()
    * ```
    */
  get operatingHour(): Prisma.OperatingHourDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.placeAdmin`: Exposes CRUD operations for the **PlaceAdmin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlaceAdmins
    * const placeAdmins = await prisma.placeAdmin.findMany()
    * ```
    */
  get placeAdmin(): Prisma.PlaceAdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemLog`: Exposes CRUD operations for the **SystemLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemLogs
    * const systemLogs = await prisma.systemLog.findMany()
    * ```
    */
  get systemLog(): Prisma.SystemLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailVerificationToken`: Exposes CRUD operations for the **EmailVerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailVerificationTokens
    * const emailVerificationTokens = await prisma.emailVerificationToken.findMany()
    * ```
    */
  get emailVerificationToken(): Prisma.EmailVerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.phoneVerificationOtp`: Exposes CRUD operations for the **PhoneVerificationOtp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PhoneVerificationOtps
    * const phoneVerificationOtps = await prisma.phoneVerificationOtp.findMany()
    * ```
    */
  get phoneVerificationOtp(): Prisma.PhoneVerificationOtpDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordResetToken`: Exposes CRUD operations for the **PasswordResetToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResetTokens
    * const passwordResetTokens = await prisma.passwordResetToken.findMany()
    * ```
    */
  get passwordResetToken(): Prisma.PasswordResetTokenDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    UserSession: 'UserSession',
    UserProfile: 'UserProfile',
    Vehicle: 'Vehicle',
    Place: 'Place',
    ParkingZone: 'ParkingZone',
    ParkingSlot: 'ParkingSlot',
    SlotAvailability: 'SlotAvailability',
    TariffPlan: 'TariffPlan',
    TariffRate: 'TariffRate',
    Booking: 'Booking',
    BookingStatusLog: 'BookingStatusLog',
    BookingPayment: 'BookingPayment',
    PaymentTransaction: 'PaymentTransaction',
    RefundTransaction: 'RefundTransaction',
    PaymentMethod: 'PaymentMethod',
    UserPaymentMethod: 'UserPaymentMethod',
    PromoCode: 'PromoCode',
    ParkingPass: 'ParkingPass',
    ParkingPassPayment: 'ParkingPassPayment',
    AccessLog: 'AccessLog',
    BookingExtension: 'BookingExtension',
    NotificationSetting: 'NotificationSetting',
    Notification: 'Notification',
    PlaceRating: 'PlaceRating',
    OperatingHour: 'OperatingHour',
    PlaceAdmin: 'PlaceAdmin',
    SystemLog: 'SystemLog',
    EmailVerificationToken: 'EmailVerificationToken',
    PhoneVerificationOtp: 'PhoneVerificationOtp',
    PasswordResetToken: 'PasswordResetToken'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "userSession" | "userProfile" | "vehicle" | "place" | "parkingZone" | "parkingSlot" | "slotAvailability" | "tariffPlan" | "tariffRate" | "booking" | "bookingStatusLog" | "bookingPayment" | "paymentTransaction" | "refundTransaction" | "paymentMethod" | "userPaymentMethod" | "promoCode" | "parkingPass" | "parkingPassPayment" | "accessLog" | "bookingExtension" | "notificationSetting" | "notification" | "placeRating" | "operatingHour" | "placeAdmin" | "systemLog" | "emailVerificationToken" | "phoneVerificationOtp" | "passwordResetToken"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserSession: {
        payload: Prisma.$UserSessionPayload<ExtArgs>
        fields: Prisma.UserSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findFirst: {
            args: Prisma.UserSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findMany: {
            args: Prisma.UserSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          create: {
            args: Prisma.UserSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          createMany: {
            args: Prisma.UserSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          delete: {
            args: Prisma.UserSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          update: {
            args: Prisma.UserSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          deleteMany: {
            args: Prisma.UserSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          upsert: {
            args: Prisma.UserSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          aggregate: {
            args: Prisma.UserSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSession>
          }
          groupBy: {
            args: Prisma.UserSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSessionCountArgs<ExtArgs>
            result: $Utils.Optional<UserSessionCountAggregateOutputType> | number
          }
        }
      }
      UserProfile: {
        payload: Prisma.$UserProfilePayload<ExtArgs>
        fields: Prisma.UserProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          findFirst: {
            args: Prisma.UserProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          findMany: {
            args: Prisma.UserProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          create: {
            args: Prisma.UserProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          createMany: {
            args: Prisma.UserProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          delete: {
            args: Prisma.UserProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          update: {
            args: Prisma.UserProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          deleteMany: {
            args: Prisma.UserProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          upsert: {
            args: Prisma.UserProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          aggregate: {
            args: Prisma.UserProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserProfile>
          }
          groupBy: {
            args: Prisma.UserProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserProfileCountArgs<ExtArgs>
            result: $Utils.Optional<UserProfileCountAggregateOutputType> | number
          }
        }
      }
      Vehicle: {
        payload: Prisma.$VehiclePayload<ExtArgs>
        fields: Prisma.VehicleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VehicleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VehicleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          findFirst: {
            args: Prisma.VehicleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VehicleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          findMany: {
            args: Prisma.VehicleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>[]
          }
          create: {
            args: Prisma.VehicleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          createMany: {
            args: Prisma.VehicleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VehicleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>[]
          }
          delete: {
            args: Prisma.VehicleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          update: {
            args: Prisma.VehicleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          deleteMany: {
            args: Prisma.VehicleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VehicleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VehicleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>[]
          }
          upsert: {
            args: Prisma.VehicleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          aggregate: {
            args: Prisma.VehicleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicle>
          }
          groupBy: {
            args: Prisma.VehicleGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehicleGroupByOutputType>[]
          }
          count: {
            args: Prisma.VehicleCountArgs<ExtArgs>
            result: $Utils.Optional<VehicleCountAggregateOutputType> | number
          }
        }
      }
      Place: {
        payload: Prisma.$PlacePayload<ExtArgs>
        fields: Prisma.PlaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlaceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlaceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>
          }
          findFirst: {
            args: Prisma.PlaceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlaceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>
          }
          findMany: {
            args: Prisma.PlaceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>[]
          }
          create: {
            args: Prisma.PlaceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>
          }
          createMany: {
            args: Prisma.PlaceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlaceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>[]
          }
          delete: {
            args: Prisma.PlaceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>
          }
          update: {
            args: Prisma.PlaceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>
          }
          deleteMany: {
            args: Prisma.PlaceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlaceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlaceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>[]
          }
          upsert: {
            args: Prisma.PlaceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>
          }
          aggregate: {
            args: Prisma.PlaceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlace>
          }
          groupBy: {
            args: Prisma.PlaceGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlaceCountArgs<ExtArgs>
            result: $Utils.Optional<PlaceCountAggregateOutputType> | number
          }
        }
      }
      ParkingZone: {
        payload: Prisma.$ParkingZonePayload<ExtArgs>
        fields: Prisma.ParkingZoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParkingZoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingZonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParkingZoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingZonePayload>
          }
          findFirst: {
            args: Prisma.ParkingZoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingZonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParkingZoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingZonePayload>
          }
          findMany: {
            args: Prisma.ParkingZoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingZonePayload>[]
          }
          create: {
            args: Prisma.ParkingZoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingZonePayload>
          }
          createMany: {
            args: Prisma.ParkingZoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParkingZoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingZonePayload>[]
          }
          delete: {
            args: Prisma.ParkingZoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingZonePayload>
          }
          update: {
            args: Prisma.ParkingZoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingZonePayload>
          }
          deleteMany: {
            args: Prisma.ParkingZoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParkingZoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ParkingZoneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingZonePayload>[]
          }
          upsert: {
            args: Prisma.ParkingZoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingZonePayload>
          }
          aggregate: {
            args: Prisma.ParkingZoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParkingZone>
          }
          groupBy: {
            args: Prisma.ParkingZoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParkingZoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParkingZoneCountArgs<ExtArgs>
            result: $Utils.Optional<ParkingZoneCountAggregateOutputType> | number
          }
        }
      }
      ParkingSlot: {
        payload: Prisma.$ParkingSlotPayload<ExtArgs>
        fields: Prisma.ParkingSlotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParkingSlotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingSlotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParkingSlotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingSlotPayload>
          }
          findFirst: {
            args: Prisma.ParkingSlotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingSlotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParkingSlotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingSlotPayload>
          }
          findMany: {
            args: Prisma.ParkingSlotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingSlotPayload>[]
          }
          create: {
            args: Prisma.ParkingSlotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingSlotPayload>
          }
          createMany: {
            args: Prisma.ParkingSlotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParkingSlotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingSlotPayload>[]
          }
          delete: {
            args: Prisma.ParkingSlotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingSlotPayload>
          }
          update: {
            args: Prisma.ParkingSlotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingSlotPayload>
          }
          deleteMany: {
            args: Prisma.ParkingSlotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParkingSlotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ParkingSlotUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingSlotPayload>[]
          }
          upsert: {
            args: Prisma.ParkingSlotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingSlotPayload>
          }
          aggregate: {
            args: Prisma.ParkingSlotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParkingSlot>
          }
          groupBy: {
            args: Prisma.ParkingSlotGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParkingSlotGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParkingSlotCountArgs<ExtArgs>
            result: $Utils.Optional<ParkingSlotCountAggregateOutputType> | number
          }
        }
      }
      SlotAvailability: {
        payload: Prisma.$SlotAvailabilityPayload<ExtArgs>
        fields: Prisma.SlotAvailabilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SlotAvailabilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotAvailabilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SlotAvailabilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotAvailabilityPayload>
          }
          findFirst: {
            args: Prisma.SlotAvailabilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotAvailabilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SlotAvailabilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotAvailabilityPayload>
          }
          findMany: {
            args: Prisma.SlotAvailabilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotAvailabilityPayload>[]
          }
          create: {
            args: Prisma.SlotAvailabilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotAvailabilityPayload>
          }
          createMany: {
            args: Prisma.SlotAvailabilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SlotAvailabilityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotAvailabilityPayload>[]
          }
          delete: {
            args: Prisma.SlotAvailabilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotAvailabilityPayload>
          }
          update: {
            args: Prisma.SlotAvailabilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotAvailabilityPayload>
          }
          deleteMany: {
            args: Prisma.SlotAvailabilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SlotAvailabilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SlotAvailabilityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotAvailabilityPayload>[]
          }
          upsert: {
            args: Prisma.SlotAvailabilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotAvailabilityPayload>
          }
          aggregate: {
            args: Prisma.SlotAvailabilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSlotAvailability>
          }
          groupBy: {
            args: Prisma.SlotAvailabilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<SlotAvailabilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.SlotAvailabilityCountArgs<ExtArgs>
            result: $Utils.Optional<SlotAvailabilityCountAggregateOutputType> | number
          }
        }
      }
      TariffPlan: {
        payload: Prisma.$TariffPlanPayload<ExtArgs>
        fields: Prisma.TariffPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TariffPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TariffPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffPlanPayload>
          }
          findFirst: {
            args: Prisma.TariffPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TariffPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffPlanPayload>
          }
          findMany: {
            args: Prisma.TariffPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffPlanPayload>[]
          }
          create: {
            args: Prisma.TariffPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffPlanPayload>
          }
          createMany: {
            args: Prisma.TariffPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TariffPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffPlanPayload>[]
          }
          delete: {
            args: Prisma.TariffPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffPlanPayload>
          }
          update: {
            args: Prisma.TariffPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffPlanPayload>
          }
          deleteMany: {
            args: Prisma.TariffPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TariffPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TariffPlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffPlanPayload>[]
          }
          upsert: {
            args: Prisma.TariffPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffPlanPayload>
          }
          aggregate: {
            args: Prisma.TariffPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTariffPlan>
          }
          groupBy: {
            args: Prisma.TariffPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<TariffPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.TariffPlanCountArgs<ExtArgs>
            result: $Utils.Optional<TariffPlanCountAggregateOutputType> | number
          }
        }
      }
      TariffRate: {
        payload: Prisma.$TariffRatePayload<ExtArgs>
        fields: Prisma.TariffRateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TariffRateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffRatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TariffRateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffRatePayload>
          }
          findFirst: {
            args: Prisma.TariffRateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffRatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TariffRateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffRatePayload>
          }
          findMany: {
            args: Prisma.TariffRateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffRatePayload>[]
          }
          create: {
            args: Prisma.TariffRateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffRatePayload>
          }
          createMany: {
            args: Prisma.TariffRateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TariffRateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffRatePayload>[]
          }
          delete: {
            args: Prisma.TariffRateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffRatePayload>
          }
          update: {
            args: Prisma.TariffRateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffRatePayload>
          }
          deleteMany: {
            args: Prisma.TariffRateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TariffRateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TariffRateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffRatePayload>[]
          }
          upsert: {
            args: Prisma.TariffRateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffRatePayload>
          }
          aggregate: {
            args: Prisma.TariffRateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTariffRate>
          }
          groupBy: {
            args: Prisma.TariffRateGroupByArgs<ExtArgs>
            result: $Utils.Optional<TariffRateGroupByOutputType>[]
          }
          count: {
            args: Prisma.TariffRateCountArgs<ExtArgs>
            result: $Utils.Optional<TariffRateCountAggregateOutputType> | number
          }
        }
      }
      Booking: {
        payload: Prisma.$BookingPayload<ExtArgs>
        fields: Prisma.BookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findFirst: {
            args: Prisma.BookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findMany: {
            args: Prisma.BookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          create: {
            args: Prisma.BookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          createMany: {
            args: Prisma.BookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          delete: {
            args: Prisma.BookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          update: {
            args: Prisma.BookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          deleteMany: {
            args: Prisma.BookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          upsert: {
            args: Prisma.BookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          aggregate: {
            args: Prisma.BookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking>
          }
          groupBy: {
            args: Prisma.BookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingCountArgs<ExtArgs>
            result: $Utils.Optional<BookingCountAggregateOutputType> | number
          }
        }
      }
      BookingStatusLog: {
        payload: Prisma.$BookingStatusLogPayload<ExtArgs>
        fields: Prisma.BookingStatusLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingStatusLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingStatusLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingStatusLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingStatusLogPayload>
          }
          findFirst: {
            args: Prisma.BookingStatusLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingStatusLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingStatusLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingStatusLogPayload>
          }
          findMany: {
            args: Prisma.BookingStatusLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingStatusLogPayload>[]
          }
          create: {
            args: Prisma.BookingStatusLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingStatusLogPayload>
          }
          createMany: {
            args: Prisma.BookingStatusLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingStatusLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingStatusLogPayload>[]
          }
          delete: {
            args: Prisma.BookingStatusLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingStatusLogPayload>
          }
          update: {
            args: Prisma.BookingStatusLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingStatusLogPayload>
          }
          deleteMany: {
            args: Prisma.BookingStatusLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingStatusLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingStatusLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingStatusLogPayload>[]
          }
          upsert: {
            args: Prisma.BookingStatusLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingStatusLogPayload>
          }
          aggregate: {
            args: Prisma.BookingStatusLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookingStatusLog>
          }
          groupBy: {
            args: Prisma.BookingStatusLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingStatusLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingStatusLogCountArgs<ExtArgs>
            result: $Utils.Optional<BookingStatusLogCountAggregateOutputType> | number
          }
        }
      }
      BookingPayment: {
        payload: Prisma.$BookingPaymentPayload<ExtArgs>
        fields: Prisma.BookingPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingPaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingPaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPaymentPayload>
          }
          findFirst: {
            args: Prisma.BookingPaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingPaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPaymentPayload>
          }
          findMany: {
            args: Prisma.BookingPaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPaymentPayload>[]
          }
          create: {
            args: Prisma.BookingPaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPaymentPayload>
          }
          createMany: {
            args: Prisma.BookingPaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingPaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPaymentPayload>[]
          }
          delete: {
            args: Prisma.BookingPaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPaymentPayload>
          }
          update: {
            args: Prisma.BookingPaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPaymentPayload>
          }
          deleteMany: {
            args: Prisma.BookingPaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingPaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingPaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPaymentPayload>[]
          }
          upsert: {
            args: Prisma.BookingPaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPaymentPayload>
          }
          aggregate: {
            args: Prisma.BookingPaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookingPayment>
          }
          groupBy: {
            args: Prisma.BookingPaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingPaymentCountArgs<ExtArgs>
            result: $Utils.Optional<BookingPaymentCountAggregateOutputType> | number
          }
        }
      }
      PaymentTransaction: {
        payload: Prisma.$PaymentTransactionPayload<ExtArgs>
        fields: Prisma.PaymentTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>
          }
          findFirst: {
            args: Prisma.PaymentTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>
          }
          findMany: {
            args: Prisma.PaymentTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>[]
          }
          create: {
            args: Prisma.PaymentTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>
          }
          createMany: {
            args: Prisma.PaymentTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>[]
          }
          delete: {
            args: Prisma.PaymentTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>
          }
          update: {
            args: Prisma.PaymentTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>
          }
          deleteMany: {
            args: Prisma.PaymentTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>[]
          }
          upsert: {
            args: Prisma.PaymentTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>
          }
          aggregate: {
            args: Prisma.PaymentTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentTransaction>
          }
          groupBy: {
            args: Prisma.PaymentTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentTransactionCountAggregateOutputType> | number
          }
        }
      }
      RefundTransaction: {
        payload: Prisma.$RefundTransactionPayload<ExtArgs>
        fields: Prisma.RefundTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefundTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefundTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundTransactionPayload>
          }
          findFirst: {
            args: Prisma.RefundTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefundTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundTransactionPayload>
          }
          findMany: {
            args: Prisma.RefundTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundTransactionPayload>[]
          }
          create: {
            args: Prisma.RefundTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundTransactionPayload>
          }
          createMany: {
            args: Prisma.RefundTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefundTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundTransactionPayload>[]
          }
          delete: {
            args: Prisma.RefundTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundTransactionPayload>
          }
          update: {
            args: Prisma.RefundTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundTransactionPayload>
          }
          deleteMany: {
            args: Prisma.RefundTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefundTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RefundTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundTransactionPayload>[]
          }
          upsert: {
            args: Prisma.RefundTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundTransactionPayload>
          }
          aggregate: {
            args: Prisma.RefundTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefundTransaction>
          }
          groupBy: {
            args: Prisma.RefundTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefundTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefundTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<RefundTransactionCountAggregateOutputType> | number
          }
        }
      }
      PaymentMethod: {
        payload: Prisma.$PaymentMethodPayload<ExtArgs>
        fields: Prisma.PaymentMethodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentMethodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentMethodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          findFirst: {
            args: Prisma.PaymentMethodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentMethodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          findMany: {
            args: Prisma.PaymentMethodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          create: {
            args: Prisma.PaymentMethodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          createMany: {
            args: Prisma.PaymentMethodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentMethodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          delete: {
            args: Prisma.PaymentMethodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          update: {
            args: Prisma.PaymentMethodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          deleteMany: {
            args: Prisma.PaymentMethodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentMethodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentMethodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          upsert: {
            args: Prisma.PaymentMethodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          aggregate: {
            args: Prisma.PaymentMethodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentMethod>
          }
          groupBy: {
            args: Prisma.PaymentMethodGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentMethodCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodCountAggregateOutputType> | number
          }
        }
      }
      UserPaymentMethod: {
        payload: Prisma.$UserPaymentMethodPayload<ExtArgs>
        fields: Prisma.UserPaymentMethodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPaymentMethodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPaymentMethodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPaymentMethodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPaymentMethodPayload>
          }
          findFirst: {
            args: Prisma.UserPaymentMethodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPaymentMethodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPaymentMethodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPaymentMethodPayload>
          }
          findMany: {
            args: Prisma.UserPaymentMethodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPaymentMethodPayload>[]
          }
          create: {
            args: Prisma.UserPaymentMethodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPaymentMethodPayload>
          }
          createMany: {
            args: Prisma.UserPaymentMethodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserPaymentMethodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPaymentMethodPayload>[]
          }
          delete: {
            args: Prisma.UserPaymentMethodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPaymentMethodPayload>
          }
          update: {
            args: Prisma.UserPaymentMethodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPaymentMethodPayload>
          }
          deleteMany: {
            args: Prisma.UserPaymentMethodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPaymentMethodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserPaymentMethodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPaymentMethodPayload>[]
          }
          upsert: {
            args: Prisma.UserPaymentMethodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPaymentMethodPayload>
          }
          aggregate: {
            args: Prisma.UserPaymentMethodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPaymentMethod>
          }
          groupBy: {
            args: Prisma.UserPaymentMethodGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPaymentMethodGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPaymentMethodCountArgs<ExtArgs>
            result: $Utils.Optional<UserPaymentMethodCountAggregateOutputType> | number
          }
        }
      }
      PromoCode: {
        payload: Prisma.$PromoCodePayload<ExtArgs>
        fields: Prisma.PromoCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromoCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromoCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          findFirst: {
            args: Prisma.PromoCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromoCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          findMany: {
            args: Prisma.PromoCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>[]
          }
          create: {
            args: Prisma.PromoCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          createMany: {
            args: Prisma.PromoCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PromoCodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>[]
          }
          delete: {
            args: Prisma.PromoCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          update: {
            args: Prisma.PromoCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          deleteMany: {
            args: Prisma.PromoCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromoCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PromoCodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>[]
          }
          upsert: {
            args: Prisma.PromoCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          aggregate: {
            args: Prisma.PromoCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromoCode>
          }
          groupBy: {
            args: Prisma.PromoCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromoCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromoCodeCountArgs<ExtArgs>
            result: $Utils.Optional<PromoCodeCountAggregateOutputType> | number
          }
        }
      }
      ParkingPass: {
        payload: Prisma.$ParkingPassPayload<ExtArgs>
        fields: Prisma.ParkingPassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParkingPassFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingPassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParkingPassFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingPassPayload>
          }
          findFirst: {
            args: Prisma.ParkingPassFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingPassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParkingPassFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingPassPayload>
          }
          findMany: {
            args: Prisma.ParkingPassFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingPassPayload>[]
          }
          create: {
            args: Prisma.ParkingPassCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingPassPayload>
          }
          createMany: {
            args: Prisma.ParkingPassCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParkingPassCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingPassPayload>[]
          }
          delete: {
            args: Prisma.ParkingPassDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingPassPayload>
          }
          update: {
            args: Prisma.ParkingPassUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingPassPayload>
          }
          deleteMany: {
            args: Prisma.ParkingPassDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParkingPassUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ParkingPassUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingPassPayload>[]
          }
          upsert: {
            args: Prisma.ParkingPassUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingPassPayload>
          }
          aggregate: {
            args: Prisma.ParkingPassAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParkingPass>
          }
          groupBy: {
            args: Prisma.ParkingPassGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParkingPassGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParkingPassCountArgs<ExtArgs>
            result: $Utils.Optional<ParkingPassCountAggregateOutputType> | number
          }
        }
      }
      ParkingPassPayment: {
        payload: Prisma.$ParkingPassPaymentPayload<ExtArgs>
        fields: Prisma.ParkingPassPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParkingPassPaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingPassPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParkingPassPaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingPassPaymentPayload>
          }
          findFirst: {
            args: Prisma.ParkingPassPaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingPassPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParkingPassPaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingPassPaymentPayload>
          }
          findMany: {
            args: Prisma.ParkingPassPaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingPassPaymentPayload>[]
          }
          create: {
            args: Prisma.ParkingPassPaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingPassPaymentPayload>
          }
          createMany: {
            args: Prisma.ParkingPassPaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParkingPassPaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingPassPaymentPayload>[]
          }
          delete: {
            args: Prisma.ParkingPassPaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingPassPaymentPayload>
          }
          update: {
            args: Prisma.ParkingPassPaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingPassPaymentPayload>
          }
          deleteMany: {
            args: Prisma.ParkingPassPaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParkingPassPaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ParkingPassPaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingPassPaymentPayload>[]
          }
          upsert: {
            args: Prisma.ParkingPassPaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingPassPaymentPayload>
          }
          aggregate: {
            args: Prisma.ParkingPassPaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParkingPassPayment>
          }
          groupBy: {
            args: Prisma.ParkingPassPaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParkingPassPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParkingPassPaymentCountArgs<ExtArgs>
            result: $Utils.Optional<ParkingPassPaymentCountAggregateOutputType> | number
          }
        }
      }
      AccessLog: {
        payload: Prisma.$AccessLogPayload<ExtArgs>
        fields: Prisma.AccessLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccessLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccessLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessLogPayload>
          }
          findFirst: {
            args: Prisma.AccessLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccessLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessLogPayload>
          }
          findMany: {
            args: Prisma.AccessLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessLogPayload>[]
          }
          create: {
            args: Prisma.AccessLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessLogPayload>
          }
          createMany: {
            args: Prisma.AccessLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccessLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessLogPayload>[]
          }
          delete: {
            args: Prisma.AccessLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessLogPayload>
          }
          update: {
            args: Prisma.AccessLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessLogPayload>
          }
          deleteMany: {
            args: Prisma.AccessLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccessLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccessLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessLogPayload>[]
          }
          upsert: {
            args: Prisma.AccessLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessLogPayload>
          }
          aggregate: {
            args: Prisma.AccessLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccessLog>
          }
          groupBy: {
            args: Prisma.AccessLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccessLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccessLogCountArgs<ExtArgs>
            result: $Utils.Optional<AccessLogCountAggregateOutputType> | number
          }
        }
      }
      BookingExtension: {
        payload: Prisma.$BookingExtensionPayload<ExtArgs>
        fields: Prisma.BookingExtensionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingExtensionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingExtensionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingExtensionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingExtensionPayload>
          }
          findFirst: {
            args: Prisma.BookingExtensionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingExtensionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingExtensionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingExtensionPayload>
          }
          findMany: {
            args: Prisma.BookingExtensionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingExtensionPayload>[]
          }
          create: {
            args: Prisma.BookingExtensionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingExtensionPayload>
          }
          createMany: {
            args: Prisma.BookingExtensionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingExtensionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingExtensionPayload>[]
          }
          delete: {
            args: Prisma.BookingExtensionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingExtensionPayload>
          }
          update: {
            args: Prisma.BookingExtensionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingExtensionPayload>
          }
          deleteMany: {
            args: Prisma.BookingExtensionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingExtensionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingExtensionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingExtensionPayload>[]
          }
          upsert: {
            args: Prisma.BookingExtensionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingExtensionPayload>
          }
          aggregate: {
            args: Prisma.BookingExtensionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookingExtension>
          }
          groupBy: {
            args: Prisma.BookingExtensionGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingExtensionGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingExtensionCountArgs<ExtArgs>
            result: $Utils.Optional<BookingExtensionCountAggregateOutputType> | number
          }
        }
      }
      NotificationSetting: {
        payload: Prisma.$NotificationSettingPayload<ExtArgs>
        fields: Prisma.NotificationSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingPayload>
          }
          findFirst: {
            args: Prisma.NotificationSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingPayload>
          }
          findMany: {
            args: Prisma.NotificationSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingPayload>[]
          }
          create: {
            args: Prisma.NotificationSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingPayload>
          }
          createMany: {
            args: Prisma.NotificationSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationSettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingPayload>[]
          }
          delete: {
            args: Prisma.NotificationSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingPayload>
          }
          update: {
            args: Prisma.NotificationSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingPayload>
          }
          deleteMany: {
            args: Prisma.NotificationSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationSettingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingPayload>[]
          }
          upsert: {
            args: Prisma.NotificationSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingPayload>
          }
          aggregate: {
            args: Prisma.NotificationSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationSetting>
          }
          groupBy: {
            args: Prisma.NotificationSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationSettingCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationSettingCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      PlaceRating: {
        payload: Prisma.$PlaceRatingPayload<ExtArgs>
        fields: Prisma.PlaceRatingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlaceRatingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceRatingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlaceRatingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceRatingPayload>
          }
          findFirst: {
            args: Prisma.PlaceRatingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceRatingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlaceRatingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceRatingPayload>
          }
          findMany: {
            args: Prisma.PlaceRatingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceRatingPayload>[]
          }
          create: {
            args: Prisma.PlaceRatingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceRatingPayload>
          }
          createMany: {
            args: Prisma.PlaceRatingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlaceRatingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceRatingPayload>[]
          }
          delete: {
            args: Prisma.PlaceRatingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceRatingPayload>
          }
          update: {
            args: Prisma.PlaceRatingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceRatingPayload>
          }
          deleteMany: {
            args: Prisma.PlaceRatingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlaceRatingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlaceRatingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceRatingPayload>[]
          }
          upsert: {
            args: Prisma.PlaceRatingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceRatingPayload>
          }
          aggregate: {
            args: Prisma.PlaceRatingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlaceRating>
          }
          groupBy: {
            args: Prisma.PlaceRatingGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlaceRatingGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlaceRatingCountArgs<ExtArgs>
            result: $Utils.Optional<PlaceRatingCountAggregateOutputType> | number
          }
        }
      }
      OperatingHour: {
        payload: Prisma.$OperatingHourPayload<ExtArgs>
        fields: Prisma.OperatingHourFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OperatingHourFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatingHourPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OperatingHourFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatingHourPayload>
          }
          findFirst: {
            args: Prisma.OperatingHourFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatingHourPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OperatingHourFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatingHourPayload>
          }
          findMany: {
            args: Prisma.OperatingHourFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatingHourPayload>[]
          }
          create: {
            args: Prisma.OperatingHourCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatingHourPayload>
          }
          createMany: {
            args: Prisma.OperatingHourCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OperatingHourCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatingHourPayload>[]
          }
          delete: {
            args: Prisma.OperatingHourDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatingHourPayload>
          }
          update: {
            args: Prisma.OperatingHourUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatingHourPayload>
          }
          deleteMany: {
            args: Prisma.OperatingHourDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OperatingHourUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OperatingHourUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatingHourPayload>[]
          }
          upsert: {
            args: Prisma.OperatingHourUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatingHourPayload>
          }
          aggregate: {
            args: Prisma.OperatingHourAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOperatingHour>
          }
          groupBy: {
            args: Prisma.OperatingHourGroupByArgs<ExtArgs>
            result: $Utils.Optional<OperatingHourGroupByOutputType>[]
          }
          count: {
            args: Prisma.OperatingHourCountArgs<ExtArgs>
            result: $Utils.Optional<OperatingHourCountAggregateOutputType> | number
          }
        }
      }
      PlaceAdmin: {
        payload: Prisma.$PlaceAdminPayload<ExtArgs>
        fields: Prisma.PlaceAdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlaceAdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceAdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlaceAdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceAdminPayload>
          }
          findFirst: {
            args: Prisma.PlaceAdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceAdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlaceAdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceAdminPayload>
          }
          findMany: {
            args: Prisma.PlaceAdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceAdminPayload>[]
          }
          create: {
            args: Prisma.PlaceAdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceAdminPayload>
          }
          createMany: {
            args: Prisma.PlaceAdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlaceAdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceAdminPayload>[]
          }
          delete: {
            args: Prisma.PlaceAdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceAdminPayload>
          }
          update: {
            args: Prisma.PlaceAdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceAdminPayload>
          }
          deleteMany: {
            args: Prisma.PlaceAdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlaceAdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlaceAdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceAdminPayload>[]
          }
          upsert: {
            args: Prisma.PlaceAdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceAdminPayload>
          }
          aggregate: {
            args: Prisma.PlaceAdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlaceAdmin>
          }
          groupBy: {
            args: Prisma.PlaceAdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlaceAdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlaceAdminCountArgs<ExtArgs>
            result: $Utils.Optional<PlaceAdminCountAggregateOutputType> | number
          }
        }
      }
      SystemLog: {
        payload: Prisma.$SystemLogPayload<ExtArgs>
        fields: Prisma.SystemLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          findFirst: {
            args: Prisma.SystemLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          findMany: {
            args: Prisma.SystemLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>[]
          }
          create: {
            args: Prisma.SystemLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          createMany: {
            args: Prisma.SystemLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>[]
          }
          delete: {
            args: Prisma.SystemLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          update: {
            args: Prisma.SystemLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          deleteMany: {
            args: Prisma.SystemLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>[]
          }
          upsert: {
            args: Prisma.SystemLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          aggregate: {
            args: Prisma.SystemLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemLog>
          }
          groupBy: {
            args: Prisma.SystemLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemLogCountArgs<ExtArgs>
            result: $Utils.Optional<SystemLogCountAggregateOutputType> | number
          }
        }
      }
      EmailVerificationToken: {
        payload: Prisma.$EmailVerificationTokenPayload<ExtArgs>
        fields: Prisma.EmailVerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailVerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailVerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.EmailVerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailVerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>
          }
          findMany: {
            args: Prisma.EmailVerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>[]
          }
          create: {
            args: Prisma.EmailVerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>
          }
          createMany: {
            args: Prisma.EmailVerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailVerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.EmailVerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>
          }
          update: {
            args: Prisma.EmailVerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.EmailVerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailVerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailVerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.EmailVerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.EmailVerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailVerificationToken>
          }
          groupBy: {
            args: Prisma.EmailVerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailVerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailVerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<EmailVerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      PhoneVerificationOtp: {
        payload: Prisma.$PhoneVerificationOtpPayload<ExtArgs>
        fields: Prisma.PhoneVerificationOtpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PhoneVerificationOtpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhoneVerificationOtpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PhoneVerificationOtpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhoneVerificationOtpPayload>
          }
          findFirst: {
            args: Prisma.PhoneVerificationOtpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhoneVerificationOtpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PhoneVerificationOtpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhoneVerificationOtpPayload>
          }
          findMany: {
            args: Prisma.PhoneVerificationOtpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhoneVerificationOtpPayload>[]
          }
          create: {
            args: Prisma.PhoneVerificationOtpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhoneVerificationOtpPayload>
          }
          createMany: {
            args: Prisma.PhoneVerificationOtpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PhoneVerificationOtpCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhoneVerificationOtpPayload>[]
          }
          delete: {
            args: Prisma.PhoneVerificationOtpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhoneVerificationOtpPayload>
          }
          update: {
            args: Prisma.PhoneVerificationOtpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhoneVerificationOtpPayload>
          }
          deleteMany: {
            args: Prisma.PhoneVerificationOtpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PhoneVerificationOtpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PhoneVerificationOtpUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhoneVerificationOtpPayload>[]
          }
          upsert: {
            args: Prisma.PhoneVerificationOtpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhoneVerificationOtpPayload>
          }
          aggregate: {
            args: Prisma.PhoneVerificationOtpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhoneVerificationOtp>
          }
          groupBy: {
            args: Prisma.PhoneVerificationOtpGroupByArgs<ExtArgs>
            result: $Utils.Optional<PhoneVerificationOtpGroupByOutputType>[]
          }
          count: {
            args: Prisma.PhoneVerificationOtpCountArgs<ExtArgs>
            result: $Utils.Optional<PhoneVerificationOtpCountAggregateOutputType> | number
          }
        }
      }
      PasswordResetToken: {
        payload: Prisma.$PasswordResetTokenPayload<ExtArgs>
        fields: Prisma.PasswordResetTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findMany: {
            args: Prisma.PasswordResetTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          create: {
            args: Prisma.PasswordResetTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          createMany: {
            args: Prisma.PasswordResetTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          delete: {
            args: Prisma.PasswordResetTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          update: {
            args: Prisma.PasswordResetTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          upsert: {
            args: Prisma.PasswordResetTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordResetToken>
          }
          groupBy: {
            args: Prisma.PasswordResetTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetTokenCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    userSession?: UserSessionOmit
    userProfile?: UserProfileOmit
    vehicle?: VehicleOmit
    place?: PlaceOmit
    parkingZone?: ParkingZoneOmit
    parkingSlot?: ParkingSlotOmit
    slotAvailability?: SlotAvailabilityOmit
    tariffPlan?: TariffPlanOmit
    tariffRate?: TariffRateOmit
    booking?: BookingOmit
    bookingStatusLog?: BookingStatusLogOmit
    bookingPayment?: BookingPaymentOmit
    paymentTransaction?: PaymentTransactionOmit
    refundTransaction?: RefundTransactionOmit
    paymentMethod?: PaymentMethodOmit
    userPaymentMethod?: UserPaymentMethodOmit
    promoCode?: PromoCodeOmit
    parkingPass?: ParkingPassOmit
    parkingPassPayment?: ParkingPassPaymentOmit
    accessLog?: AccessLogOmit
    bookingExtension?: BookingExtensionOmit
    notificationSetting?: NotificationSettingOmit
    notification?: NotificationOmit
    placeRating?: PlaceRatingOmit
    operatingHour?: OperatingHourOmit
    placeAdmin?: PlaceAdminOmit
    systemLog?: SystemLogOmit
    emailVerificationToken?: EmailVerificationTokenOmit
    phoneVerificationOtp?: PhoneVerificationOtpOmit
    passwordResetToken?: PasswordResetTokenOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    vehicles: number
    bookings: number
    userPaymentMethods: number
    notifications: number
    parkingPasses: number
    placeRatings: number
    sessions: number
    EmailVerificationToken: number
    PhoneVerificationOtp: number
    PasswordResetToken: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicles?: boolean | UserCountOutputTypeCountVehiclesArgs
    bookings?: boolean | UserCountOutputTypeCountBookingsArgs
    userPaymentMethods?: boolean | UserCountOutputTypeCountUserPaymentMethodsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    parkingPasses?: boolean | UserCountOutputTypeCountParkingPassesArgs
    placeRatings?: boolean | UserCountOutputTypeCountPlaceRatingsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    EmailVerificationToken?: boolean | UserCountOutputTypeCountEmailVerificationTokenArgs
    PhoneVerificationOtp?: boolean | UserCountOutputTypeCountPhoneVerificationOtpArgs
    PasswordResetToken?: boolean | UserCountOutputTypeCountPasswordResetTokenArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVehiclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserPaymentMethodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPaymentMethodWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountParkingPassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParkingPassWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPlaceRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaceRatingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmailVerificationTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailVerificationTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPhoneVerificationOtpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhoneVerificationOtpWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPasswordResetTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
  }


  /**
   * Count Type VehicleCountOutputType
   */

  export type VehicleCountOutputType = {
    bookings: number
  }

  export type VehicleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | VehicleCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleCountOutputType
     */
    select?: VehicleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }


  /**
   * Count Type PlaceCountOutputType
   */

  export type PlaceCountOutputType = {
    parkingZones: number
    tariffPlans: number
    parkingPasses: number
    operatingHours: number
    placeAdmins: number
    placeRatings: number
  }

  export type PlaceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parkingZones?: boolean | PlaceCountOutputTypeCountParkingZonesArgs
    tariffPlans?: boolean | PlaceCountOutputTypeCountTariffPlansArgs
    parkingPasses?: boolean | PlaceCountOutputTypeCountParkingPassesArgs
    operatingHours?: boolean | PlaceCountOutputTypeCountOperatingHoursArgs
    placeAdmins?: boolean | PlaceCountOutputTypeCountPlaceAdminsArgs
    placeRatings?: boolean | PlaceCountOutputTypeCountPlaceRatingsArgs
  }

  // Custom InputTypes
  /**
   * PlaceCountOutputType without action
   */
  export type PlaceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceCountOutputType
     */
    select?: PlaceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlaceCountOutputType without action
   */
  export type PlaceCountOutputTypeCountParkingZonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParkingZoneWhereInput
  }

  /**
   * PlaceCountOutputType without action
   */
  export type PlaceCountOutputTypeCountTariffPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TariffPlanWhereInput
  }

  /**
   * PlaceCountOutputType without action
   */
  export type PlaceCountOutputTypeCountParkingPassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParkingPassWhereInput
  }

  /**
   * PlaceCountOutputType without action
   */
  export type PlaceCountOutputTypeCountOperatingHoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperatingHourWhereInput
  }

  /**
   * PlaceCountOutputType without action
   */
  export type PlaceCountOutputTypeCountPlaceAdminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaceAdminWhereInput
  }

  /**
   * PlaceCountOutputType without action
   */
  export type PlaceCountOutputTypeCountPlaceRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaceRatingWhereInput
  }


  /**
   * Count Type ParkingZoneCountOutputType
   */

  export type ParkingZoneCountOutputType = {
    parkingSlots: number
  }

  export type ParkingZoneCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parkingSlots?: boolean | ParkingZoneCountOutputTypeCountParkingSlotsArgs
  }

  // Custom InputTypes
  /**
   * ParkingZoneCountOutputType without action
   */
  export type ParkingZoneCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingZoneCountOutputType
     */
    select?: ParkingZoneCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ParkingZoneCountOutputType without action
   */
  export type ParkingZoneCountOutputTypeCountParkingSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParkingSlotWhereInput
  }


  /**
   * Count Type ParkingSlotCountOutputType
   */

  export type ParkingSlotCountOutputType = {
    slotAvailability: number
    bookings: number
  }

  export type ParkingSlotCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    slotAvailability?: boolean | ParkingSlotCountOutputTypeCountSlotAvailabilityArgs
    bookings?: boolean | ParkingSlotCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * ParkingSlotCountOutputType without action
   */
  export type ParkingSlotCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlotCountOutputType
     */
    select?: ParkingSlotCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ParkingSlotCountOutputType without action
   */
  export type ParkingSlotCountOutputTypeCountSlotAvailabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SlotAvailabilityWhereInput
  }

  /**
   * ParkingSlotCountOutputType without action
   */
  export type ParkingSlotCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }


  /**
   * Count Type TariffPlanCountOutputType
   */

  export type TariffPlanCountOutputType = {
    tariffRates: number
  }

  export type TariffPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tariffRates?: boolean | TariffPlanCountOutputTypeCountTariffRatesArgs
  }

  // Custom InputTypes
  /**
   * TariffPlanCountOutputType without action
   */
  export type TariffPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffPlanCountOutputType
     */
    select?: TariffPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TariffPlanCountOutputType without action
   */
  export type TariffPlanCountOutputTypeCountTariffRatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TariffRateWhereInput
  }


  /**
   * Count Type BookingCountOutputType
   */

  export type BookingCountOutputType = {
    bookingStatusLogs: number
    accessLogs: number
    bookingExtensions: number
    placeRatings: number
    notifications: number
  }

  export type BookingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingStatusLogs?: boolean | BookingCountOutputTypeCountBookingStatusLogsArgs
    accessLogs?: boolean | BookingCountOutputTypeCountAccessLogsArgs
    bookingExtensions?: boolean | BookingCountOutputTypeCountBookingExtensionsArgs
    placeRatings?: boolean | BookingCountOutputTypeCountPlaceRatingsArgs
    notifications?: boolean | BookingCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCountOutputType
     */
    select?: BookingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountBookingStatusLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingStatusLogWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountAccessLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccessLogWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountBookingExtensionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingExtensionWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountPlaceRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaceRatingWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type BookingPaymentCountOutputType
   */

  export type BookingPaymentCountOutputType = {
    paymentTransactions: number
    refundTransactions: number
  }

  export type BookingPaymentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paymentTransactions?: boolean | BookingPaymentCountOutputTypeCountPaymentTransactionsArgs
    refundTransactions?: boolean | BookingPaymentCountOutputTypeCountRefundTransactionsArgs
  }

  // Custom InputTypes
  /**
   * BookingPaymentCountOutputType without action
   */
  export type BookingPaymentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingPaymentCountOutputType
     */
    select?: BookingPaymentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookingPaymentCountOutputType without action
   */
  export type BookingPaymentCountOutputTypeCountPaymentTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentTransactionWhereInput
  }

  /**
   * BookingPaymentCountOutputType without action
   */
  export type BookingPaymentCountOutputTypeCountRefundTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefundTransactionWhereInput
  }


  /**
   * Count Type PaymentMethodCountOutputType
   */

  export type PaymentMethodCountOutputType = {
    paymentTransactions: number
    userPaymentMethods: number
    parkingPassPayments: number
  }

  export type PaymentMethodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paymentTransactions?: boolean | PaymentMethodCountOutputTypeCountPaymentTransactionsArgs
    userPaymentMethods?: boolean | PaymentMethodCountOutputTypeCountUserPaymentMethodsArgs
    parkingPassPayments?: boolean | PaymentMethodCountOutputTypeCountParkingPassPaymentsArgs
  }

  // Custom InputTypes
  /**
   * PaymentMethodCountOutputType without action
   */
  export type PaymentMethodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethodCountOutputType
     */
    select?: PaymentMethodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentMethodCountOutputType without action
   */
  export type PaymentMethodCountOutputTypeCountPaymentTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentTransactionWhereInput
  }

  /**
   * PaymentMethodCountOutputType without action
   */
  export type PaymentMethodCountOutputTypeCountUserPaymentMethodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPaymentMethodWhereInput
  }

  /**
   * PaymentMethodCountOutputType without action
   */
  export type PaymentMethodCountOutputTypeCountParkingPassPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParkingPassPaymentWhereInput
  }


  /**
   * Count Type PromoCodeCountOutputType
   */

  export type PromoCodeCountOutputType = {
    bookings: number
  }

  export type PromoCodeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | PromoCodeCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * PromoCodeCountOutputType without action
   */
  export type PromoCodeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCodeCountOutputType
     */
    select?: PromoCodeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PromoCodeCountOutputType without action
   */
  export type PromoCodeCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }


  /**
   * Count Type ParkingPassCountOutputType
   */

  export type ParkingPassCountOutputType = {
    parkingPassPayments: number
  }

  export type ParkingPassCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parkingPassPayments?: boolean | ParkingPassCountOutputTypeCountParkingPassPaymentsArgs
  }

  // Custom InputTypes
  /**
   * ParkingPassCountOutputType without action
   */
  export type ParkingPassCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingPassCountOutputType
     */
    select?: ParkingPassCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ParkingPassCountOutputType without action
   */
  export type ParkingPassCountOutputTypeCountParkingPassPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParkingPassPaymentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    passwordHash: string | null
    phoneNumber: string | null
    accountType: string | null
    emailVerified: boolean | null
    phoneVerified: boolean | null
    accountStatus: string | null
    googleId: string | null
    lastLogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    passwordHash: string | null
    phoneNumber: string | null
    accountType: string | null
    emailVerified: boolean | null
    phoneVerified: boolean | null
    accountStatus: string | null
    googleId: string | null
    lastLogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    email: number
    passwordHash: number
    phoneNumber: number
    accountType: number
    emailVerified: number
    phoneVerified: number
    accountStatus: number
    googleId: number
    lastLogin: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    passwordHash?: true
    phoneNumber?: true
    accountType?: true
    emailVerified?: true
    phoneVerified?: true
    accountStatus?: true
    googleId?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    passwordHash?: true
    phoneNumber?: true
    accountType?: true
    emailVerified?: true
    phoneVerified?: true
    accountStatus?: true
    googleId?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    passwordHash?: true
    phoneNumber?: true
    accountType?: true
    emailVerified?: true
    phoneVerified?: true
    accountStatus?: true
    googleId?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    username: string
    email: string
    passwordHash: string
    phoneNumber: string | null
    accountType: string
    emailVerified: boolean
    phoneVerified: boolean
    accountStatus: string
    googleId: string | null
    lastLogin: Date | null
    createdAt: Date
    updatedAt: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    phoneNumber?: boolean
    accountType?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    accountStatus?: boolean
    googleId?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | User$profileArgs<ExtArgs>
    vehicles?: boolean | User$vehiclesArgs<ExtArgs>
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    userPaymentMethods?: boolean | User$userPaymentMethodsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    parkingPasses?: boolean | User$parkingPassesArgs<ExtArgs>
    placeRatings?: boolean | User$placeRatingsArgs<ExtArgs>
    notificationSettings?: boolean | User$notificationSettingsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    EmailVerificationToken?: boolean | User$EmailVerificationTokenArgs<ExtArgs>
    PhoneVerificationOtp?: boolean | User$PhoneVerificationOtpArgs<ExtArgs>
    PasswordResetToken?: boolean | User$PasswordResetTokenArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    phoneNumber?: boolean
    accountType?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    accountStatus?: boolean
    googleId?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    phoneNumber?: boolean
    accountType?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    accountStatus?: boolean
    googleId?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    phoneNumber?: boolean
    accountType?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    accountStatus?: boolean
    googleId?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "email" | "passwordHash" | "phoneNumber" | "accountType" | "emailVerified" | "phoneVerified" | "accountStatus" | "googleId" | "lastLogin" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | User$profileArgs<ExtArgs>
    vehicles?: boolean | User$vehiclesArgs<ExtArgs>
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    userPaymentMethods?: boolean | User$userPaymentMethodsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    parkingPasses?: boolean | User$parkingPassesArgs<ExtArgs>
    placeRatings?: boolean | User$placeRatingsArgs<ExtArgs>
    notificationSettings?: boolean | User$notificationSettingsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    EmailVerificationToken?: boolean | User$EmailVerificationTokenArgs<ExtArgs>
    PhoneVerificationOtp?: boolean | User$PhoneVerificationOtpArgs<ExtArgs>
    PasswordResetToken?: boolean | User$PasswordResetTokenArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      profile: Prisma.$UserProfilePayload<ExtArgs> | null
      vehicles: Prisma.$VehiclePayload<ExtArgs>[]
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      userPaymentMethods: Prisma.$UserPaymentMethodPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      parkingPasses: Prisma.$ParkingPassPayload<ExtArgs>[]
      placeRatings: Prisma.$PlaceRatingPayload<ExtArgs>[]
      notificationSettings: Prisma.$NotificationSettingPayload<ExtArgs> | null
      sessions: Prisma.$UserSessionPayload<ExtArgs>[]
      EmailVerificationToken: Prisma.$EmailVerificationTokenPayload<ExtArgs>[]
      PhoneVerificationOtp: Prisma.$PhoneVerificationOtpPayload<ExtArgs>[]
      PasswordResetToken: Prisma.$PasswordResetTokenPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      email: string
      passwordHash: string
      phoneNumber: string | null
      accountType: string
      emailVerified: boolean
      phoneVerified: boolean
      accountStatus: string
      googleId: string | null
      lastLogin: Date | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends User$profileArgs<ExtArgs> = {}>(args?: Subset<T, User$profileArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    vehicles<T extends User$vehiclesArgs<ExtArgs> = {}>(args?: Subset<T, User$vehiclesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookings<T extends User$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, User$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userPaymentMethods<T extends User$userPaymentMethodsArgs<ExtArgs> = {}>(args?: Subset<T, User$userPaymentMethodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPaymentMethodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parkingPasses<T extends User$parkingPassesArgs<ExtArgs> = {}>(args?: Subset<T, User$parkingPassesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParkingPassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    placeRatings<T extends User$placeRatingsArgs<ExtArgs> = {}>(args?: Subset<T, User$placeRatingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaceRatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notificationSettings<T extends User$notificationSettingsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationSettingsArgs<ExtArgs>>): Prisma__NotificationSettingClient<$Result.GetResult<Prisma.$NotificationSettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    EmailVerificationToken<T extends User$EmailVerificationTokenArgs<ExtArgs> = {}>(args?: Subset<T, User$EmailVerificationTokenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PhoneVerificationOtp<T extends User$PhoneVerificationOtpArgs<ExtArgs> = {}>(args?: Subset<T, User$PhoneVerificationOtpArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhoneVerificationOtpPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PasswordResetToken<T extends User$PasswordResetTokenArgs<ExtArgs> = {}>(args?: Subset<T, User$PasswordResetTokenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly username: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly phoneNumber: FieldRef<"User", 'String'>
    readonly accountType: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly phoneVerified: FieldRef<"User", 'Boolean'>
    readonly accountStatus: FieldRef<"User", 'String'>
    readonly googleId: FieldRef<"User", 'String'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.profile
   */
  export type User$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    where?: UserProfileWhereInput
  }

  /**
   * User.vehicles
   */
  export type User$vehiclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    where?: VehicleWhereInput
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    cursor?: VehicleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * User.bookings
   */
  export type User$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * User.userPaymentMethods
   */
  export type User$userPaymentMethodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPaymentMethod
     */
    select?: UserPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPaymentMethod
     */
    omit?: UserPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPaymentMethodInclude<ExtArgs> | null
    where?: UserPaymentMethodWhereInput
    orderBy?: UserPaymentMethodOrderByWithRelationInput | UserPaymentMethodOrderByWithRelationInput[]
    cursor?: UserPaymentMethodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPaymentMethodScalarFieldEnum | UserPaymentMethodScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.parkingPasses
   */
  export type User$parkingPassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingPass
     */
    select?: ParkingPassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingPass
     */
    omit?: ParkingPassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingPassInclude<ExtArgs> | null
    where?: ParkingPassWhereInput
    orderBy?: ParkingPassOrderByWithRelationInput | ParkingPassOrderByWithRelationInput[]
    cursor?: ParkingPassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParkingPassScalarFieldEnum | ParkingPassScalarFieldEnum[]
  }

  /**
   * User.placeRatings
   */
  export type User$placeRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceRating
     */
    select?: PlaceRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceRating
     */
    omit?: PlaceRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceRatingInclude<ExtArgs> | null
    where?: PlaceRatingWhereInput
    orderBy?: PlaceRatingOrderByWithRelationInput | PlaceRatingOrderByWithRelationInput[]
    cursor?: PlaceRatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlaceRatingScalarFieldEnum | PlaceRatingScalarFieldEnum[]
  }

  /**
   * User.notificationSettings
   */
  export type User$notificationSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSetting
     */
    select?: NotificationSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSetting
     */
    omit?: NotificationSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingInclude<ExtArgs> | null
    where?: NotificationSettingWhereInput
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    cursor?: UserSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * User.EmailVerificationToken
   */
  export type User$EmailVerificationTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
    where?: EmailVerificationTokenWhereInput
    orderBy?: EmailVerificationTokenOrderByWithRelationInput | EmailVerificationTokenOrderByWithRelationInput[]
    cursor?: EmailVerificationTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailVerificationTokenScalarFieldEnum | EmailVerificationTokenScalarFieldEnum[]
  }

  /**
   * User.PhoneVerificationOtp
   */
  export type User$PhoneVerificationOtpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerificationOtp
     */
    select?: PhoneVerificationOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneVerificationOtp
     */
    omit?: PhoneVerificationOtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneVerificationOtpInclude<ExtArgs> | null
    where?: PhoneVerificationOtpWhereInput
    orderBy?: PhoneVerificationOtpOrderByWithRelationInput | PhoneVerificationOtpOrderByWithRelationInput[]
    cursor?: PhoneVerificationOtpWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PhoneVerificationOtpScalarFieldEnum | PhoneVerificationOtpScalarFieldEnum[]
  }

  /**
   * User.PasswordResetToken
   */
  export type User$PasswordResetTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    cursor?: PasswordResetTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserSession
   */

  export type AggregateUserSession = {
    _count: UserSessionCountAggregateOutputType | null
    _avg: UserSessionAvgAggregateOutputType | null
    _sum: UserSessionSumAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  export type UserSessionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserSessionSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserSessionMinAggregateOutputType = {
    id: number | null
    userId: number | null
    token: string | null
    deviceInfo: string | null
    ipAddress: string | null
    lastActivity: Date | null
    expiryTime: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSessionMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    token: string | null
    deviceInfo: string | null
    ipAddress: string | null
    lastActivity: Date | null
    expiryTime: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSessionCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    deviceInfo: number
    ipAddress: number
    lastActivity: number
    expiryTime: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserSessionAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserSessionSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserSessionMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    deviceInfo?: true
    ipAddress?: true
    lastActivity?: true
    expiryTime?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    deviceInfo?: true
    ipAddress?: true
    lastActivity?: true
    expiryTime?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSessionCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    deviceInfo?: true
    ipAddress?: true
    lastActivity?: true
    expiryTime?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSession to aggregate.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSessions
    **/
    _count?: true | UserSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSessionMaxAggregateInputType
  }

  export type GetUserSessionAggregateType<T extends UserSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSession[P]>
      : GetScalarType<T[P], AggregateUserSession[P]>
  }




  export type UserSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithAggregationInput | UserSessionOrderByWithAggregationInput[]
    by: UserSessionScalarFieldEnum[] | UserSessionScalarFieldEnum
    having?: UserSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSessionCountAggregateInputType | true
    _avg?: UserSessionAvgAggregateInputType
    _sum?: UserSessionSumAggregateInputType
    _min?: UserSessionMinAggregateInputType
    _max?: UserSessionMaxAggregateInputType
  }

  export type UserSessionGroupByOutputType = {
    id: number
    userId: number
    token: string
    deviceInfo: string | null
    ipAddress: string | null
    lastActivity: Date
    expiryTime: Date
    isActive: boolean
    createdAt: Date
    updatedAt: Date | null
    _count: UserSessionCountAggregateOutputType | null
    _avg: UserSessionAvgAggregateOutputType | null
    _sum: UserSessionSumAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  type GetUserSessionGroupByPayload<T extends UserSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
            : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
        }
      >
    >


  export type UserSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    deviceInfo?: boolean
    ipAddress?: boolean
    lastActivity?: boolean
    expiryTime?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    deviceInfo?: boolean
    ipAddress?: boolean
    lastActivity?: boolean
    expiryTime?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    deviceInfo?: boolean
    ipAddress?: boolean
    lastActivity?: boolean
    expiryTime?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    deviceInfo?: boolean
    ipAddress?: boolean
    lastActivity?: boolean
    expiryTime?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "deviceInfo" | "ipAddress" | "lastActivity" | "expiryTime" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["userSession"]>
  export type UserSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      token: string
      deviceInfo: string | null
      ipAddress: string | null
      lastActivity: Date
      expiryTime: Date
      isActive: boolean
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["userSession"]>
    composites: {}
  }

  type UserSessionGetPayload<S extends boolean | null | undefined | UserSessionDefaultArgs> = $Result.GetResult<Prisma.$UserSessionPayload, S>

  type UserSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSessionCountAggregateInputType | true
    }

  export interface UserSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSession'], meta: { name: 'UserSession' } }
    /**
     * Find zero or one UserSession that matches the filter.
     * @param {UserSessionFindUniqueArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSessionFindUniqueArgs>(args: SelectSubset<T, UserSessionFindUniqueArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSessionFindUniqueOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSessionFindFirstArgs>(args?: SelectSubset<T, UserSessionFindFirstArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSessions
     * const userSessions = await prisma.userSession.findMany()
     * 
     * // Get first 10 UserSessions
     * const userSessions = await prisma.userSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSessionWithIdOnly = await prisma.userSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSessionFindManyArgs>(args?: SelectSubset<T, UserSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSession.
     * @param {UserSessionCreateArgs} args - Arguments to create a UserSession.
     * @example
     * // Create one UserSession
     * const UserSession = await prisma.userSession.create({
     *   data: {
     *     // ... data to create a UserSession
     *   }
     * })
     * 
     */
    create<T extends UserSessionCreateArgs>(args: SelectSubset<T, UserSessionCreateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSessions.
     * @param {UserSessionCreateManyArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSessionCreateManyArgs>(args?: SelectSubset<T, UserSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSessions and returns the data saved in the database.
     * @param {UserSessionCreateManyAndReturnArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSessions and only return the `id`
     * const userSessionWithIdOnly = await prisma.userSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSession.
     * @param {UserSessionDeleteArgs} args - Arguments to delete one UserSession.
     * @example
     * // Delete one UserSession
     * const UserSession = await prisma.userSession.delete({
     *   where: {
     *     // ... filter to delete one UserSession
     *   }
     * })
     * 
     */
    delete<T extends UserSessionDeleteArgs>(args: SelectSubset<T, UserSessionDeleteArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSession.
     * @param {UserSessionUpdateArgs} args - Arguments to update one UserSession.
     * @example
     * // Update one UserSession
     * const userSession = await prisma.userSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSessionUpdateArgs>(args: SelectSubset<T, UserSessionUpdateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSessions.
     * @param {UserSessionDeleteManyArgs} args - Arguments to filter UserSessions to delete.
     * @example
     * // Delete a few UserSessions
     * const { count } = await prisma.userSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSessionDeleteManyArgs>(args?: SelectSubset<T, UserSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSessions
     * const userSession = await prisma.userSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSessionUpdateManyArgs>(args: SelectSubset<T, UserSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions and returns the data updated in the database.
     * @param {UserSessionUpdateManyAndReturnArgs} args - Arguments to update many UserSessions.
     * @example
     * // Update many UserSessions
     * const userSession = await prisma.userSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSessions and only return the `id`
     * const userSessionWithIdOnly = await prisma.userSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSession.
     * @param {UserSessionUpsertArgs} args - Arguments to update or create a UserSession.
     * @example
     * // Update or create a UserSession
     * const userSession = await prisma.userSession.upsert({
     *   create: {
     *     // ... data to create a UserSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSession we want to update
     *   }
     * })
     */
    upsert<T extends UserSessionUpsertArgs>(args: SelectSubset<T, UserSessionUpsertArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionCountArgs} args - Arguments to filter UserSessions to count.
     * @example
     * // Count the number of UserSessions
     * const count = await prisma.userSession.count({
     *   where: {
     *     // ... the filter for the UserSessions we want to count
     *   }
     * })
    **/
    count<T extends UserSessionCountArgs>(
      args?: Subset<T, UserSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSessionAggregateArgs>(args: Subset<T, UserSessionAggregateArgs>): Prisma.PrismaPromise<GetUserSessionAggregateType<T>>

    /**
     * Group by UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSessionGroupByArgs['orderBy'] }
        : { orderBy?: UserSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSession model
   */
  readonly fields: UserSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSession model
   */
  interface UserSessionFieldRefs {
    readonly id: FieldRef<"UserSession", 'Int'>
    readonly userId: FieldRef<"UserSession", 'Int'>
    readonly token: FieldRef<"UserSession", 'String'>
    readonly deviceInfo: FieldRef<"UserSession", 'String'>
    readonly ipAddress: FieldRef<"UserSession", 'String'>
    readonly lastActivity: FieldRef<"UserSession", 'DateTime'>
    readonly expiryTime: FieldRef<"UserSession", 'DateTime'>
    readonly isActive: FieldRef<"UserSession", 'Boolean'>
    readonly createdAt: FieldRef<"UserSession", 'DateTime'>
    readonly updatedAt: FieldRef<"UserSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSession findUnique
   */
  export type UserSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findUniqueOrThrow
   */
  export type UserSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findFirst
   */
  export type UserSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findFirstOrThrow
   */
  export type UserSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findMany
   */
  export type UserSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSessions to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession create
   */
  export type UserSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSession.
     */
    data: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
  }

  /**
   * UserSession createMany
   */
  export type UserSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSession createManyAndReturn
   */
  export type UserSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSession update
   */
  export type UserSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSession.
     */
    data: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
    /**
     * Choose, which UserSession to update.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession updateMany
   */
  export type UserSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSessions.
     */
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyInput>
    /**
     * Filter which UserSessions to update
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to update.
     */
    limit?: number
  }

  /**
   * UserSession updateManyAndReturn
   */
  export type UserSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * The data used to update UserSessions.
     */
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyInput>
    /**
     * Filter which UserSessions to update
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSession upsert
   */
  export type UserSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSession to update in case it exists.
     */
    where: UserSessionWhereUniqueInput
    /**
     * In case the UserSession found by the `where` argument doesn't exist, create a new UserSession with this data.
     */
    create: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
    /**
     * In case the UserSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
  }

  /**
   * UserSession delete
   */
  export type UserSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter which UserSession to delete.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession deleteMany
   */
  export type UserSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSessions to delete
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to delete.
     */
    limit?: number
  }

  /**
   * UserSession without action
   */
  export type UserSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
  }


  /**
   * Model UserProfile
   */

  export type AggregateUserProfile = {
    _count: UserProfileCountAggregateOutputType | null
    _avg: UserProfileAvgAggregateOutputType | null
    _sum: UserProfileSumAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  export type UserProfileAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserProfileSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserProfileMinAggregateOutputType = {
    id: number | null
    userId: number | null
    firstName: string | null
    lastName: string | null
    profilePhoto: string | null
    gender: string | null
    dateOfBirth: Date | null
    address: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserProfileMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    firstName: string | null
    lastName: string | null
    profilePhoto: string | null
    gender: string | null
    dateOfBirth: Date | null
    address: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserProfileCountAggregateOutputType = {
    id: number
    userId: number
    firstName: number
    lastName: number
    profilePhoto: number
    gender: number
    dateOfBirth: number
    address: number
    city: number
    state: number
    postalCode: number
    country: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserProfileAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserProfileSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserProfileMinAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    profilePhoto?: true
    gender?: true
    dateOfBirth?: true
    address?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    profilePhoto?: true
    gender?: true
    dateOfBirth?: true
    address?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserProfileCountAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    profilePhoto?: true
    gender?: true
    dateOfBirth?: true
    address?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfile to aggregate.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserProfiles
    **/
    _count?: true | UserProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserProfileMaxAggregateInputType
  }

  export type GetUserProfileAggregateType<T extends UserProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateUserProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserProfile[P]>
      : GetScalarType<T[P], AggregateUserProfile[P]>
  }




  export type UserProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProfileWhereInput
    orderBy?: UserProfileOrderByWithAggregationInput | UserProfileOrderByWithAggregationInput[]
    by: UserProfileScalarFieldEnum[] | UserProfileScalarFieldEnum
    having?: UserProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserProfileCountAggregateInputType | true
    _avg?: UserProfileAvgAggregateInputType
    _sum?: UserProfileSumAggregateInputType
    _min?: UserProfileMinAggregateInputType
    _max?: UserProfileMaxAggregateInputType
  }

  export type UserProfileGroupByOutputType = {
    id: number
    userId: number
    firstName: string | null
    lastName: string | null
    profilePhoto: string | null
    gender: string | null
    dateOfBirth: Date | null
    address: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: UserProfileCountAggregateOutputType | null
    _avg: UserProfileAvgAggregateOutputType | null
    _sum: UserProfileSumAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  type GetUserProfileGroupByPayload<T extends UserProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
            : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
        }
      >
    >


  export type UserProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    profilePhoto?: boolean
    gender?: boolean
    dateOfBirth?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    profilePhoto?: boolean
    gender?: boolean
    dateOfBirth?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    profilePhoto?: boolean
    gender?: boolean
    dateOfBirth?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    profilePhoto?: boolean
    gender?: boolean
    dateOfBirth?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "firstName" | "lastName" | "profilePhoto" | "gender" | "dateOfBirth" | "address" | "city" | "state" | "postalCode" | "country" | "createdAt" | "updatedAt", ExtArgs["result"]["userProfile"]>
  export type UserProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      firstName: string | null
      lastName: string | null
      profilePhoto: string | null
      gender: string | null
      dateOfBirth: Date | null
      address: string | null
      city: string | null
      state: string | null
      postalCode: string | null
      country: string | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["userProfile"]>
    composites: {}
  }

  type UserProfileGetPayload<S extends boolean | null | undefined | UserProfileDefaultArgs> = $Result.GetResult<Prisma.$UserProfilePayload, S>

  type UserProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserProfileCountAggregateInputType | true
    }

  export interface UserProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserProfile'], meta: { name: 'UserProfile' } }
    /**
     * Find zero or one UserProfile that matches the filter.
     * @param {UserProfileFindUniqueArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserProfileFindUniqueArgs>(args: SelectSubset<T, UserProfileFindUniqueArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserProfileFindUniqueOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, UserProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserProfileFindFirstArgs>(args?: SelectSubset<T, UserProfileFindFirstArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, UserProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProfiles
     * const userProfiles = await prisma.userProfile.findMany()
     * 
     * // Get first 10 UserProfiles
     * const userProfiles = await prisma.userProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserProfileFindManyArgs>(args?: SelectSubset<T, UserProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserProfile.
     * @param {UserProfileCreateArgs} args - Arguments to create a UserProfile.
     * @example
     * // Create one UserProfile
     * const UserProfile = await prisma.userProfile.create({
     *   data: {
     *     // ... data to create a UserProfile
     *   }
     * })
     * 
     */
    create<T extends UserProfileCreateArgs>(args: SelectSubset<T, UserProfileCreateArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserProfiles.
     * @param {UserProfileCreateManyArgs} args - Arguments to create many UserProfiles.
     * @example
     * // Create many UserProfiles
     * const userProfile = await prisma.userProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserProfileCreateManyArgs>(args?: SelectSubset<T, UserProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserProfiles and returns the data saved in the database.
     * @param {UserProfileCreateManyAndReturnArgs} args - Arguments to create many UserProfiles.
     * @example
     * // Create many UserProfiles
     * const userProfile = await prisma.userProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserProfiles and only return the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, UserProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserProfile.
     * @param {UserProfileDeleteArgs} args - Arguments to delete one UserProfile.
     * @example
     * // Delete one UserProfile
     * const UserProfile = await prisma.userProfile.delete({
     *   where: {
     *     // ... filter to delete one UserProfile
     *   }
     * })
     * 
     */
    delete<T extends UserProfileDeleteArgs>(args: SelectSubset<T, UserProfileDeleteArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserProfile.
     * @param {UserProfileUpdateArgs} args - Arguments to update one UserProfile.
     * @example
     * // Update one UserProfile
     * const userProfile = await prisma.userProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserProfileUpdateArgs>(args: SelectSubset<T, UserProfileUpdateArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserProfiles.
     * @param {UserProfileDeleteManyArgs} args - Arguments to filter UserProfiles to delete.
     * @example
     * // Delete a few UserProfiles
     * const { count } = await prisma.userProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserProfileDeleteManyArgs>(args?: SelectSubset<T, UserProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProfiles
     * const userProfile = await prisma.userProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserProfileUpdateManyArgs>(args: SelectSubset<T, UserProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfiles and returns the data updated in the database.
     * @param {UserProfileUpdateManyAndReturnArgs} args - Arguments to update many UserProfiles.
     * @example
     * // Update many UserProfiles
     * const userProfile = await prisma.userProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserProfiles and only return the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, UserProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserProfile.
     * @param {UserProfileUpsertArgs} args - Arguments to update or create a UserProfile.
     * @example
     * // Update or create a UserProfile
     * const userProfile = await prisma.userProfile.upsert({
     *   create: {
     *     // ... data to create a UserProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProfile we want to update
     *   }
     * })
     */
    upsert<T extends UserProfileUpsertArgs>(args: SelectSubset<T, UserProfileUpsertArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileCountArgs} args - Arguments to filter UserProfiles to count.
     * @example
     * // Count the number of UserProfiles
     * const count = await prisma.userProfile.count({
     *   where: {
     *     // ... the filter for the UserProfiles we want to count
     *   }
     * })
    **/
    count<T extends UserProfileCountArgs>(
      args?: Subset<T, UserProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserProfileAggregateArgs>(args: Subset<T, UserProfileAggregateArgs>): Prisma.PrismaPromise<GetUserProfileAggregateType<T>>

    /**
     * Group by UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserProfileGroupByArgs['orderBy'] }
        : { orderBy?: UserProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserProfile model
   */
  readonly fields: UserProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserProfile model
   */
  interface UserProfileFieldRefs {
    readonly id: FieldRef<"UserProfile", 'Int'>
    readonly userId: FieldRef<"UserProfile", 'Int'>
    readonly firstName: FieldRef<"UserProfile", 'String'>
    readonly lastName: FieldRef<"UserProfile", 'String'>
    readonly profilePhoto: FieldRef<"UserProfile", 'String'>
    readonly gender: FieldRef<"UserProfile", 'String'>
    readonly dateOfBirth: FieldRef<"UserProfile", 'DateTime'>
    readonly address: FieldRef<"UserProfile", 'String'>
    readonly city: FieldRef<"UserProfile", 'String'>
    readonly state: FieldRef<"UserProfile", 'String'>
    readonly postalCode: FieldRef<"UserProfile", 'String'>
    readonly country: FieldRef<"UserProfile", 'String'>
    readonly createdAt: FieldRef<"UserProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"UserProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserProfile findUnique
   */
  export type UserProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findUniqueOrThrow
   */
  export type UserProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findFirst
   */
  export type UserProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile findFirstOrThrow
   */
  export type UserProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile findMany
   */
  export type UserProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfiles to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile create
   */
  export type UserProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a UserProfile.
     */
    data: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
  }

  /**
   * UserProfile createMany
   */
  export type UserProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserProfiles.
     */
    data: UserProfileCreateManyInput | UserProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserProfile createManyAndReturn
   */
  export type UserProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * The data used to create many UserProfiles.
     */
    data: UserProfileCreateManyInput | UserProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProfile update
   */
  export type UserProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a UserProfile.
     */
    data: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
    /**
     * Choose, which UserProfile to update.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile updateMany
   */
  export type UserProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserProfiles.
     */
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserProfiles to update
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to update.
     */
    limit?: number
  }

  /**
   * UserProfile updateManyAndReturn
   */
  export type UserProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * The data used to update UserProfiles.
     */
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserProfiles to update
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProfile upsert
   */
  export type UserProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the UserProfile to update in case it exists.
     */
    where: UserProfileWhereUniqueInput
    /**
     * In case the UserProfile found by the `where` argument doesn't exist, create a new UserProfile with this data.
     */
    create: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
    /**
     * In case the UserProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
  }

  /**
   * UserProfile delete
   */
  export type UserProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter which UserProfile to delete.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile deleteMany
   */
  export type UserProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfiles to delete
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to delete.
     */
    limit?: number
  }

  /**
   * UserProfile without action
   */
  export type UserProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
  }


  /**
   * Model Vehicle
   */

  export type AggregateVehicle = {
    _count: VehicleCountAggregateOutputType | null
    _avg: VehicleAvgAggregateOutputType | null
    _sum: VehicleSumAggregateOutputType | null
    _min: VehicleMinAggregateOutputType | null
    _max: VehicleMaxAggregateOutputType | null
  }

  export type VehicleAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    length: Decimal | null
    width: Decimal | null
    height: Decimal | null
  }

  export type VehicleSumAggregateOutputType = {
    id: number | null
    userId: number | null
    length: Decimal | null
    width: Decimal | null
    height: Decimal | null
  }

  export type VehicleMinAggregateOutputType = {
    id: number | null
    userId: number | null
    licensePlate: string | null
    vehicleType: string | null
    brand: string | null
    model: string | null
    color: string | null
    rfidTag: string | null
    length: Decimal | null
    width: Decimal | null
    height: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VehicleMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    licensePlate: string | null
    vehicleType: string | null
    brand: string | null
    model: string | null
    color: string | null
    rfidTag: string | null
    length: Decimal | null
    width: Decimal | null
    height: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VehicleCountAggregateOutputType = {
    id: number
    userId: number
    licensePlate: number
    vehicleType: number
    brand: number
    model: number
    color: number
    rfidTag: number
    length: number
    width: number
    height: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VehicleAvgAggregateInputType = {
    id?: true
    userId?: true
    length?: true
    width?: true
    height?: true
  }

  export type VehicleSumAggregateInputType = {
    id?: true
    userId?: true
    length?: true
    width?: true
    height?: true
  }

  export type VehicleMinAggregateInputType = {
    id?: true
    userId?: true
    licensePlate?: true
    vehicleType?: true
    brand?: true
    model?: true
    color?: true
    rfidTag?: true
    length?: true
    width?: true
    height?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VehicleMaxAggregateInputType = {
    id?: true
    userId?: true
    licensePlate?: true
    vehicleType?: true
    brand?: true
    model?: true
    color?: true
    rfidTag?: true
    length?: true
    width?: true
    height?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VehicleCountAggregateInputType = {
    id?: true
    userId?: true
    licensePlate?: true
    vehicleType?: true
    brand?: true
    model?: true
    color?: true
    rfidTag?: true
    length?: true
    width?: true
    height?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VehicleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vehicle to aggregate.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vehicles
    **/
    _count?: true | VehicleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VehicleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VehicleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehicleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehicleMaxAggregateInputType
  }

  export type GetVehicleAggregateType<T extends VehicleAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicle[P]>
      : GetScalarType<T[P], AggregateVehicle[P]>
  }




  export type VehicleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleWhereInput
    orderBy?: VehicleOrderByWithAggregationInput | VehicleOrderByWithAggregationInput[]
    by: VehicleScalarFieldEnum[] | VehicleScalarFieldEnum
    having?: VehicleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehicleCountAggregateInputType | true
    _avg?: VehicleAvgAggregateInputType
    _sum?: VehicleSumAggregateInputType
    _min?: VehicleMinAggregateInputType
    _max?: VehicleMaxAggregateInputType
  }

  export type VehicleGroupByOutputType = {
    id: number
    userId: number
    licensePlate: string
    vehicleType: string
    brand: string | null
    model: string | null
    color: string | null
    rfidTag: string | null
    length: Decimal | null
    width: Decimal | null
    height: Decimal | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date | null
    _count: VehicleCountAggregateOutputType | null
    _avg: VehicleAvgAggregateOutputType | null
    _sum: VehicleSumAggregateOutputType | null
    _min: VehicleMinAggregateOutputType | null
    _max: VehicleMaxAggregateOutputType | null
  }

  type GetVehicleGroupByPayload<T extends VehicleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehicleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehicleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehicleGroupByOutputType[P]>
            : GetScalarType<T[P], VehicleGroupByOutputType[P]>
        }
      >
    >


  export type VehicleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    licensePlate?: boolean
    vehicleType?: boolean
    brand?: boolean
    model?: boolean
    color?: boolean
    rfidTag?: boolean
    length?: boolean
    width?: boolean
    height?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bookings?: boolean | Vehicle$bookingsArgs<ExtArgs>
    _count?: boolean | VehicleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle"]>

  export type VehicleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    licensePlate?: boolean
    vehicleType?: boolean
    brand?: boolean
    model?: boolean
    color?: boolean
    rfidTag?: boolean
    length?: boolean
    width?: boolean
    height?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle"]>

  export type VehicleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    licensePlate?: boolean
    vehicleType?: boolean
    brand?: boolean
    model?: boolean
    color?: boolean
    rfidTag?: boolean
    length?: boolean
    width?: boolean
    height?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle"]>

  export type VehicleSelectScalar = {
    id?: boolean
    userId?: boolean
    licensePlate?: boolean
    vehicleType?: boolean
    brand?: boolean
    model?: boolean
    color?: boolean
    rfidTag?: boolean
    length?: boolean
    width?: boolean
    height?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VehicleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "licensePlate" | "vehicleType" | "brand" | "model" | "color" | "rfidTag" | "length" | "width" | "height" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["vehicle"]>
  export type VehicleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bookings?: boolean | Vehicle$bookingsArgs<ExtArgs>
    _count?: boolean | VehicleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VehicleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VehicleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VehiclePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vehicle"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      bookings: Prisma.$BookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      licensePlate: string
      vehicleType: string
      brand: string | null
      model: string | null
      color: string | null
      rfidTag: string | null
      length: Prisma.Decimal | null
      width: Prisma.Decimal | null
      height: Prisma.Decimal | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["vehicle"]>
    composites: {}
  }

  type VehicleGetPayload<S extends boolean | null | undefined | VehicleDefaultArgs> = $Result.GetResult<Prisma.$VehiclePayload, S>

  type VehicleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VehicleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VehicleCountAggregateInputType | true
    }

  export interface VehicleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vehicle'], meta: { name: 'Vehicle' } }
    /**
     * Find zero or one Vehicle that matches the filter.
     * @param {VehicleFindUniqueArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VehicleFindUniqueArgs>(args: SelectSubset<T, VehicleFindUniqueArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vehicle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VehicleFindUniqueOrThrowArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VehicleFindUniqueOrThrowArgs>(args: SelectSubset<T, VehicleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindFirstArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VehicleFindFirstArgs>(args?: SelectSubset<T, VehicleFindFirstArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindFirstOrThrowArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VehicleFindFirstOrThrowArgs>(args?: SelectSubset<T, VehicleFindFirstOrThrowArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vehicles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vehicles
     * const vehicles = await prisma.vehicle.findMany()
     * 
     * // Get first 10 Vehicles
     * const vehicles = await prisma.vehicle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicleWithIdOnly = await prisma.vehicle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VehicleFindManyArgs>(args?: SelectSubset<T, VehicleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vehicle.
     * @param {VehicleCreateArgs} args - Arguments to create a Vehicle.
     * @example
     * // Create one Vehicle
     * const Vehicle = await prisma.vehicle.create({
     *   data: {
     *     // ... data to create a Vehicle
     *   }
     * })
     * 
     */
    create<T extends VehicleCreateArgs>(args: SelectSubset<T, VehicleCreateArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vehicles.
     * @param {VehicleCreateManyArgs} args - Arguments to create many Vehicles.
     * @example
     * // Create many Vehicles
     * const vehicle = await prisma.vehicle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VehicleCreateManyArgs>(args?: SelectSubset<T, VehicleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vehicles and returns the data saved in the database.
     * @param {VehicleCreateManyAndReturnArgs} args - Arguments to create many Vehicles.
     * @example
     * // Create many Vehicles
     * const vehicle = await prisma.vehicle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vehicles and only return the `id`
     * const vehicleWithIdOnly = await prisma.vehicle.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VehicleCreateManyAndReturnArgs>(args?: SelectSubset<T, VehicleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Vehicle.
     * @param {VehicleDeleteArgs} args - Arguments to delete one Vehicle.
     * @example
     * // Delete one Vehicle
     * const Vehicle = await prisma.vehicle.delete({
     *   where: {
     *     // ... filter to delete one Vehicle
     *   }
     * })
     * 
     */
    delete<T extends VehicleDeleteArgs>(args: SelectSubset<T, VehicleDeleteArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vehicle.
     * @param {VehicleUpdateArgs} args - Arguments to update one Vehicle.
     * @example
     * // Update one Vehicle
     * const vehicle = await prisma.vehicle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VehicleUpdateArgs>(args: SelectSubset<T, VehicleUpdateArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vehicles.
     * @param {VehicleDeleteManyArgs} args - Arguments to filter Vehicles to delete.
     * @example
     * // Delete a few Vehicles
     * const { count } = await prisma.vehicle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VehicleDeleteManyArgs>(args?: SelectSubset<T, VehicleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vehicles
     * const vehicle = await prisma.vehicle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VehicleUpdateManyArgs>(args: SelectSubset<T, VehicleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicles and returns the data updated in the database.
     * @param {VehicleUpdateManyAndReturnArgs} args - Arguments to update many Vehicles.
     * @example
     * // Update many Vehicles
     * const vehicle = await prisma.vehicle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Vehicles and only return the `id`
     * const vehicleWithIdOnly = await prisma.vehicle.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VehicleUpdateManyAndReturnArgs>(args: SelectSubset<T, VehicleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Vehicle.
     * @param {VehicleUpsertArgs} args - Arguments to update or create a Vehicle.
     * @example
     * // Update or create a Vehicle
     * const vehicle = await prisma.vehicle.upsert({
     *   create: {
     *     // ... data to create a Vehicle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vehicle we want to update
     *   }
     * })
     */
    upsert<T extends VehicleUpsertArgs>(args: SelectSubset<T, VehicleUpsertArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleCountArgs} args - Arguments to filter Vehicles to count.
     * @example
     * // Count the number of Vehicles
     * const count = await prisma.vehicle.count({
     *   where: {
     *     // ... the filter for the Vehicles we want to count
     *   }
     * })
    **/
    count<T extends VehicleCountArgs>(
      args?: Subset<T, VehicleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehicleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehicleAggregateArgs>(args: Subset<T, VehicleAggregateArgs>): Prisma.PrismaPromise<GetVehicleAggregateType<T>>

    /**
     * Group by Vehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VehicleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VehicleGroupByArgs['orderBy'] }
        : { orderBy?: VehicleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VehicleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vehicle model
   */
  readonly fields: VehicleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vehicle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VehicleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bookings<T extends Vehicle$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Vehicle$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vehicle model
   */
  interface VehicleFieldRefs {
    readonly id: FieldRef<"Vehicle", 'Int'>
    readonly userId: FieldRef<"Vehicle", 'Int'>
    readonly licensePlate: FieldRef<"Vehicle", 'String'>
    readonly vehicleType: FieldRef<"Vehicle", 'String'>
    readonly brand: FieldRef<"Vehicle", 'String'>
    readonly model: FieldRef<"Vehicle", 'String'>
    readonly color: FieldRef<"Vehicle", 'String'>
    readonly rfidTag: FieldRef<"Vehicle", 'String'>
    readonly length: FieldRef<"Vehicle", 'Decimal'>
    readonly width: FieldRef<"Vehicle", 'Decimal'>
    readonly height: FieldRef<"Vehicle", 'Decimal'>
    readonly isActive: FieldRef<"Vehicle", 'Boolean'>
    readonly createdAt: FieldRef<"Vehicle", 'DateTime'>
    readonly updatedAt: FieldRef<"Vehicle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Vehicle findUnique
   */
  export type VehicleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle findUniqueOrThrow
   */
  export type VehicleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle findFirst
   */
  export type VehicleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vehicles.
     */
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Vehicle findFirstOrThrow
   */
  export type VehicleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vehicles.
     */
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Vehicle findMany
   */
  export type VehicleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicles to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Vehicle create
   */
  export type VehicleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The data needed to create a Vehicle.
     */
    data: XOR<VehicleCreateInput, VehicleUncheckedCreateInput>
  }

  /**
   * Vehicle createMany
   */
  export type VehicleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vehicles.
     */
    data: VehicleCreateManyInput | VehicleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vehicle createManyAndReturn
   */
  export type VehicleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * The data used to create many Vehicles.
     */
    data: VehicleCreateManyInput | VehicleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vehicle update
   */
  export type VehicleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The data needed to update a Vehicle.
     */
    data: XOR<VehicleUpdateInput, VehicleUncheckedUpdateInput>
    /**
     * Choose, which Vehicle to update.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle updateMany
   */
  export type VehicleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vehicles.
     */
    data: XOR<VehicleUpdateManyMutationInput, VehicleUncheckedUpdateManyInput>
    /**
     * Filter which Vehicles to update
     */
    where?: VehicleWhereInput
    /**
     * Limit how many Vehicles to update.
     */
    limit?: number
  }

  /**
   * Vehicle updateManyAndReturn
   */
  export type VehicleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * The data used to update Vehicles.
     */
    data: XOR<VehicleUpdateManyMutationInput, VehicleUncheckedUpdateManyInput>
    /**
     * Filter which Vehicles to update
     */
    where?: VehicleWhereInput
    /**
     * Limit how many Vehicles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vehicle upsert
   */
  export type VehicleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The filter to search for the Vehicle to update in case it exists.
     */
    where: VehicleWhereUniqueInput
    /**
     * In case the Vehicle found by the `where` argument doesn't exist, create a new Vehicle with this data.
     */
    create: XOR<VehicleCreateInput, VehicleUncheckedCreateInput>
    /**
     * In case the Vehicle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VehicleUpdateInput, VehicleUncheckedUpdateInput>
  }

  /**
   * Vehicle delete
   */
  export type VehicleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter which Vehicle to delete.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle deleteMany
   */
  export type VehicleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vehicles to delete
     */
    where?: VehicleWhereInput
    /**
     * Limit how many Vehicles to delete.
     */
    limit?: number
  }

  /**
   * Vehicle.bookings
   */
  export type Vehicle$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Vehicle without action
   */
  export type VehicleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
  }


  /**
   * Model Place
   */

  export type AggregatePlace = {
    _count: PlaceCountAggregateOutputType | null
    _avg: PlaceAvgAggregateOutputType | null
    _sum: PlaceSumAggregateOutputType | null
    _min: PlaceMinAggregateOutputType | null
    _max: PlaceMaxAggregateOutputType | null
  }

  export type PlaceAvgAggregateOutputType = {
    id: number | null
    latitude: Decimal | null
    longitude: Decimal | null
    totalCapacity: number | null
  }

  export type PlaceSumAggregateOutputType = {
    id: number | null
    latitude: Decimal | null
    longitude: Decimal | null
    totalCapacity: number | null
  }

  export type PlaceMinAggregateOutputType = {
    id: number | null
    name: string | null
    image: string | null
    placeType: string | null
    address: string | null
    latitude: Decimal | null
    longitude: Decimal | null
    contactNumber: string | null
    email: string | null
    description: string | null
    totalCapacity: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlaceMaxAggregateOutputType = {
    id: number | null
    name: string | null
    image: string | null
    placeType: string | null
    address: string | null
    latitude: Decimal | null
    longitude: Decimal | null
    contactNumber: string | null
    email: string | null
    description: string | null
    totalCapacity: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlaceCountAggregateOutputType = {
    id: number
    name: number
    image: number
    placeType: number
    address: number
    latitude: number
    longitude: number
    contactNumber: number
    email: number
    description: number
    totalCapacity: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlaceAvgAggregateInputType = {
    id?: true
    latitude?: true
    longitude?: true
    totalCapacity?: true
  }

  export type PlaceSumAggregateInputType = {
    id?: true
    latitude?: true
    longitude?: true
    totalCapacity?: true
  }

  export type PlaceMinAggregateInputType = {
    id?: true
    name?: true
    image?: true
    placeType?: true
    address?: true
    latitude?: true
    longitude?: true
    contactNumber?: true
    email?: true
    description?: true
    totalCapacity?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlaceMaxAggregateInputType = {
    id?: true
    name?: true
    image?: true
    placeType?: true
    address?: true
    latitude?: true
    longitude?: true
    contactNumber?: true
    email?: true
    description?: true
    totalCapacity?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlaceCountAggregateInputType = {
    id?: true
    name?: true
    image?: true
    placeType?: true
    address?: true
    latitude?: true
    longitude?: true
    contactNumber?: true
    email?: true
    description?: true
    totalCapacity?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Place to aggregate.
     */
    where?: PlaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Places to fetch.
     */
    orderBy?: PlaceOrderByWithRelationInput | PlaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Places from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Places.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Places
    **/
    _count?: true | PlaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlaceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlaceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlaceMaxAggregateInputType
  }

  export type GetPlaceAggregateType<T extends PlaceAggregateArgs> = {
        [P in keyof T & keyof AggregatePlace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlace[P]>
      : GetScalarType<T[P], AggregatePlace[P]>
  }




  export type PlaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaceWhereInput
    orderBy?: PlaceOrderByWithAggregationInput | PlaceOrderByWithAggregationInput[]
    by: PlaceScalarFieldEnum[] | PlaceScalarFieldEnum
    having?: PlaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlaceCountAggregateInputType | true
    _avg?: PlaceAvgAggregateInputType
    _sum?: PlaceSumAggregateInputType
    _min?: PlaceMinAggregateInputType
    _max?: PlaceMaxAggregateInputType
  }

  export type PlaceGroupByOutputType = {
    id: number
    name: string
    image: string | null
    placeType: string
    address: string
    latitude: Decimal | null
    longitude: Decimal | null
    contactNumber: string | null
    email: string | null
    description: string | null
    totalCapacity: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date | null
    _count: PlaceCountAggregateOutputType | null
    _avg: PlaceAvgAggregateOutputType | null
    _sum: PlaceSumAggregateOutputType | null
    _min: PlaceMinAggregateOutputType | null
    _max: PlaceMaxAggregateOutputType | null
  }

  type GetPlaceGroupByPayload<T extends PlaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlaceGroupByOutputType[P]>
            : GetScalarType<T[P], PlaceGroupByOutputType[P]>
        }
      >
    >


  export type PlaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    image?: boolean
    placeType?: boolean
    address?: boolean
    latitude?: boolean
    longitude?: boolean
    contactNumber?: boolean
    email?: boolean
    description?: boolean
    totalCapacity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parkingZones?: boolean | Place$parkingZonesArgs<ExtArgs>
    tariffPlans?: boolean | Place$tariffPlansArgs<ExtArgs>
    parkingPasses?: boolean | Place$parkingPassesArgs<ExtArgs>
    operatingHours?: boolean | Place$operatingHoursArgs<ExtArgs>
    placeAdmins?: boolean | Place$placeAdminsArgs<ExtArgs>
    placeRatings?: boolean | Place$placeRatingsArgs<ExtArgs>
    _count?: boolean | PlaceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["place"]>

  export type PlaceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    image?: boolean
    placeType?: boolean
    address?: boolean
    latitude?: boolean
    longitude?: boolean
    contactNumber?: boolean
    email?: boolean
    description?: boolean
    totalCapacity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["place"]>

  export type PlaceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    image?: boolean
    placeType?: boolean
    address?: boolean
    latitude?: boolean
    longitude?: boolean
    contactNumber?: boolean
    email?: boolean
    description?: boolean
    totalCapacity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["place"]>

  export type PlaceSelectScalar = {
    id?: boolean
    name?: boolean
    image?: boolean
    placeType?: boolean
    address?: boolean
    latitude?: boolean
    longitude?: boolean
    contactNumber?: boolean
    email?: boolean
    description?: boolean
    totalCapacity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlaceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "image" | "placeType" | "address" | "latitude" | "longitude" | "contactNumber" | "email" | "description" | "totalCapacity" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["place"]>
  export type PlaceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parkingZones?: boolean | Place$parkingZonesArgs<ExtArgs>
    tariffPlans?: boolean | Place$tariffPlansArgs<ExtArgs>
    parkingPasses?: boolean | Place$parkingPassesArgs<ExtArgs>
    operatingHours?: boolean | Place$operatingHoursArgs<ExtArgs>
    placeAdmins?: boolean | Place$placeAdminsArgs<ExtArgs>
    placeRatings?: boolean | Place$placeRatingsArgs<ExtArgs>
    _count?: boolean | PlaceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlaceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PlaceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PlacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Place"
    objects: {
      parkingZones: Prisma.$ParkingZonePayload<ExtArgs>[]
      tariffPlans: Prisma.$TariffPlanPayload<ExtArgs>[]
      parkingPasses: Prisma.$ParkingPassPayload<ExtArgs>[]
      operatingHours: Prisma.$OperatingHourPayload<ExtArgs>[]
      placeAdmins: Prisma.$PlaceAdminPayload<ExtArgs>[]
      placeRatings: Prisma.$PlaceRatingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      image: string | null
      placeType: string
      address: string
      latitude: Prisma.Decimal | null
      longitude: Prisma.Decimal | null
      contactNumber: string | null
      email: string | null
      description: string | null
      totalCapacity: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["place"]>
    composites: {}
  }

  type PlaceGetPayload<S extends boolean | null | undefined | PlaceDefaultArgs> = $Result.GetResult<Prisma.$PlacePayload, S>

  type PlaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlaceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlaceCountAggregateInputType | true
    }

  export interface PlaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Place'], meta: { name: 'Place' } }
    /**
     * Find zero or one Place that matches the filter.
     * @param {PlaceFindUniqueArgs} args - Arguments to find a Place
     * @example
     * // Get one Place
     * const place = await prisma.place.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlaceFindUniqueArgs>(args: SelectSubset<T, PlaceFindUniqueArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Place that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlaceFindUniqueOrThrowArgs} args - Arguments to find a Place
     * @example
     * // Get one Place
     * const place = await prisma.place.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlaceFindUniqueOrThrowArgs>(args: SelectSubset<T, PlaceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Place that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceFindFirstArgs} args - Arguments to find a Place
     * @example
     * // Get one Place
     * const place = await prisma.place.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlaceFindFirstArgs>(args?: SelectSubset<T, PlaceFindFirstArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Place that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceFindFirstOrThrowArgs} args - Arguments to find a Place
     * @example
     * // Get one Place
     * const place = await prisma.place.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlaceFindFirstOrThrowArgs>(args?: SelectSubset<T, PlaceFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Places that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Places
     * const places = await prisma.place.findMany()
     * 
     * // Get first 10 Places
     * const places = await prisma.place.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const placeWithIdOnly = await prisma.place.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlaceFindManyArgs>(args?: SelectSubset<T, PlaceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Place.
     * @param {PlaceCreateArgs} args - Arguments to create a Place.
     * @example
     * // Create one Place
     * const Place = await prisma.place.create({
     *   data: {
     *     // ... data to create a Place
     *   }
     * })
     * 
     */
    create<T extends PlaceCreateArgs>(args: SelectSubset<T, PlaceCreateArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Places.
     * @param {PlaceCreateManyArgs} args - Arguments to create many Places.
     * @example
     * // Create many Places
     * const place = await prisma.place.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlaceCreateManyArgs>(args?: SelectSubset<T, PlaceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Places and returns the data saved in the database.
     * @param {PlaceCreateManyAndReturnArgs} args - Arguments to create many Places.
     * @example
     * // Create many Places
     * const place = await prisma.place.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Places and only return the `id`
     * const placeWithIdOnly = await prisma.place.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlaceCreateManyAndReturnArgs>(args?: SelectSubset<T, PlaceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Place.
     * @param {PlaceDeleteArgs} args - Arguments to delete one Place.
     * @example
     * // Delete one Place
     * const Place = await prisma.place.delete({
     *   where: {
     *     // ... filter to delete one Place
     *   }
     * })
     * 
     */
    delete<T extends PlaceDeleteArgs>(args: SelectSubset<T, PlaceDeleteArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Place.
     * @param {PlaceUpdateArgs} args - Arguments to update one Place.
     * @example
     * // Update one Place
     * const place = await prisma.place.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlaceUpdateArgs>(args: SelectSubset<T, PlaceUpdateArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Places.
     * @param {PlaceDeleteManyArgs} args - Arguments to filter Places to delete.
     * @example
     * // Delete a few Places
     * const { count } = await prisma.place.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlaceDeleteManyArgs>(args?: SelectSubset<T, PlaceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Places.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Places
     * const place = await prisma.place.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlaceUpdateManyArgs>(args: SelectSubset<T, PlaceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Places and returns the data updated in the database.
     * @param {PlaceUpdateManyAndReturnArgs} args - Arguments to update many Places.
     * @example
     * // Update many Places
     * const place = await prisma.place.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Places and only return the `id`
     * const placeWithIdOnly = await prisma.place.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlaceUpdateManyAndReturnArgs>(args: SelectSubset<T, PlaceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Place.
     * @param {PlaceUpsertArgs} args - Arguments to update or create a Place.
     * @example
     * // Update or create a Place
     * const place = await prisma.place.upsert({
     *   create: {
     *     // ... data to create a Place
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Place we want to update
     *   }
     * })
     */
    upsert<T extends PlaceUpsertArgs>(args: SelectSubset<T, PlaceUpsertArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Places.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceCountArgs} args - Arguments to filter Places to count.
     * @example
     * // Count the number of Places
     * const count = await prisma.place.count({
     *   where: {
     *     // ... the filter for the Places we want to count
     *   }
     * })
    **/
    count<T extends PlaceCountArgs>(
      args?: Subset<T, PlaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Place.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlaceAggregateArgs>(args: Subset<T, PlaceAggregateArgs>): Prisma.PrismaPromise<GetPlaceAggregateType<T>>

    /**
     * Group by Place.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlaceGroupByArgs['orderBy'] }
        : { orderBy?: PlaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Place model
   */
  readonly fields: PlaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Place.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parkingZones<T extends Place$parkingZonesArgs<ExtArgs> = {}>(args?: Subset<T, Place$parkingZonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParkingZonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tariffPlans<T extends Place$tariffPlansArgs<ExtArgs> = {}>(args?: Subset<T, Place$tariffPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TariffPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parkingPasses<T extends Place$parkingPassesArgs<ExtArgs> = {}>(args?: Subset<T, Place$parkingPassesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParkingPassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    operatingHours<T extends Place$operatingHoursArgs<ExtArgs> = {}>(args?: Subset<T, Place$operatingHoursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperatingHourPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    placeAdmins<T extends Place$placeAdminsArgs<ExtArgs> = {}>(args?: Subset<T, Place$placeAdminsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaceAdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    placeRatings<T extends Place$placeRatingsArgs<ExtArgs> = {}>(args?: Subset<T, Place$placeRatingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaceRatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Place model
   */
  interface PlaceFieldRefs {
    readonly id: FieldRef<"Place", 'Int'>
    readonly name: FieldRef<"Place", 'String'>
    readonly image: FieldRef<"Place", 'String'>
    readonly placeType: FieldRef<"Place", 'String'>
    readonly address: FieldRef<"Place", 'String'>
    readonly latitude: FieldRef<"Place", 'Decimal'>
    readonly longitude: FieldRef<"Place", 'Decimal'>
    readonly contactNumber: FieldRef<"Place", 'String'>
    readonly email: FieldRef<"Place", 'String'>
    readonly description: FieldRef<"Place", 'String'>
    readonly totalCapacity: FieldRef<"Place", 'Int'>
    readonly isActive: FieldRef<"Place", 'Boolean'>
    readonly createdAt: FieldRef<"Place", 'DateTime'>
    readonly updatedAt: FieldRef<"Place", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Place findUnique
   */
  export type PlaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * Filter, which Place to fetch.
     */
    where: PlaceWhereUniqueInput
  }

  /**
   * Place findUniqueOrThrow
   */
  export type PlaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * Filter, which Place to fetch.
     */
    where: PlaceWhereUniqueInput
  }

  /**
   * Place findFirst
   */
  export type PlaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * Filter, which Place to fetch.
     */
    where?: PlaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Places to fetch.
     */
    orderBy?: PlaceOrderByWithRelationInput | PlaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Places.
     */
    cursor?: PlaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Places from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Places.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Places.
     */
    distinct?: PlaceScalarFieldEnum | PlaceScalarFieldEnum[]
  }

  /**
   * Place findFirstOrThrow
   */
  export type PlaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * Filter, which Place to fetch.
     */
    where?: PlaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Places to fetch.
     */
    orderBy?: PlaceOrderByWithRelationInput | PlaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Places.
     */
    cursor?: PlaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Places from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Places.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Places.
     */
    distinct?: PlaceScalarFieldEnum | PlaceScalarFieldEnum[]
  }

  /**
   * Place findMany
   */
  export type PlaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * Filter, which Places to fetch.
     */
    where?: PlaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Places to fetch.
     */
    orderBy?: PlaceOrderByWithRelationInput | PlaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Places.
     */
    cursor?: PlaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Places from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Places.
     */
    skip?: number
    distinct?: PlaceScalarFieldEnum | PlaceScalarFieldEnum[]
  }

  /**
   * Place create
   */
  export type PlaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * The data needed to create a Place.
     */
    data: XOR<PlaceCreateInput, PlaceUncheckedCreateInput>
  }

  /**
   * Place createMany
   */
  export type PlaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Places.
     */
    data: PlaceCreateManyInput | PlaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Place createManyAndReturn
   */
  export type PlaceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * The data used to create many Places.
     */
    data: PlaceCreateManyInput | PlaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Place update
   */
  export type PlaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * The data needed to update a Place.
     */
    data: XOR<PlaceUpdateInput, PlaceUncheckedUpdateInput>
    /**
     * Choose, which Place to update.
     */
    where: PlaceWhereUniqueInput
  }

  /**
   * Place updateMany
   */
  export type PlaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Places.
     */
    data: XOR<PlaceUpdateManyMutationInput, PlaceUncheckedUpdateManyInput>
    /**
     * Filter which Places to update
     */
    where?: PlaceWhereInput
    /**
     * Limit how many Places to update.
     */
    limit?: number
  }

  /**
   * Place updateManyAndReturn
   */
  export type PlaceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * The data used to update Places.
     */
    data: XOR<PlaceUpdateManyMutationInput, PlaceUncheckedUpdateManyInput>
    /**
     * Filter which Places to update
     */
    where?: PlaceWhereInput
    /**
     * Limit how many Places to update.
     */
    limit?: number
  }

  /**
   * Place upsert
   */
  export type PlaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * The filter to search for the Place to update in case it exists.
     */
    where: PlaceWhereUniqueInput
    /**
     * In case the Place found by the `where` argument doesn't exist, create a new Place with this data.
     */
    create: XOR<PlaceCreateInput, PlaceUncheckedCreateInput>
    /**
     * In case the Place was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlaceUpdateInput, PlaceUncheckedUpdateInput>
  }

  /**
   * Place delete
   */
  export type PlaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * Filter which Place to delete.
     */
    where: PlaceWhereUniqueInput
  }

  /**
   * Place deleteMany
   */
  export type PlaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Places to delete
     */
    where?: PlaceWhereInput
    /**
     * Limit how many Places to delete.
     */
    limit?: number
  }

  /**
   * Place.parkingZones
   */
  export type Place$parkingZonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingZone
     */
    select?: ParkingZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingZone
     */
    omit?: ParkingZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingZoneInclude<ExtArgs> | null
    where?: ParkingZoneWhereInput
    orderBy?: ParkingZoneOrderByWithRelationInput | ParkingZoneOrderByWithRelationInput[]
    cursor?: ParkingZoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParkingZoneScalarFieldEnum | ParkingZoneScalarFieldEnum[]
  }

  /**
   * Place.tariffPlans
   */
  export type Place$tariffPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffPlan
     */
    select?: TariffPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TariffPlan
     */
    omit?: TariffPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffPlanInclude<ExtArgs> | null
    where?: TariffPlanWhereInput
    orderBy?: TariffPlanOrderByWithRelationInput | TariffPlanOrderByWithRelationInput[]
    cursor?: TariffPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TariffPlanScalarFieldEnum | TariffPlanScalarFieldEnum[]
  }

  /**
   * Place.parkingPasses
   */
  export type Place$parkingPassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingPass
     */
    select?: ParkingPassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingPass
     */
    omit?: ParkingPassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingPassInclude<ExtArgs> | null
    where?: ParkingPassWhereInput
    orderBy?: ParkingPassOrderByWithRelationInput | ParkingPassOrderByWithRelationInput[]
    cursor?: ParkingPassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParkingPassScalarFieldEnum | ParkingPassScalarFieldEnum[]
  }

  /**
   * Place.operatingHours
   */
  export type Place$operatingHoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatingHour
     */
    select?: OperatingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperatingHour
     */
    omit?: OperatingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatingHourInclude<ExtArgs> | null
    where?: OperatingHourWhereInput
    orderBy?: OperatingHourOrderByWithRelationInput | OperatingHourOrderByWithRelationInput[]
    cursor?: OperatingHourWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OperatingHourScalarFieldEnum | OperatingHourScalarFieldEnum[]
  }

  /**
   * Place.placeAdmins
   */
  export type Place$placeAdminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceAdmin
     */
    select?: PlaceAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceAdmin
     */
    omit?: PlaceAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceAdminInclude<ExtArgs> | null
    where?: PlaceAdminWhereInput
    orderBy?: PlaceAdminOrderByWithRelationInput | PlaceAdminOrderByWithRelationInput[]
    cursor?: PlaceAdminWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlaceAdminScalarFieldEnum | PlaceAdminScalarFieldEnum[]
  }

  /**
   * Place.placeRatings
   */
  export type Place$placeRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceRating
     */
    select?: PlaceRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceRating
     */
    omit?: PlaceRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceRatingInclude<ExtArgs> | null
    where?: PlaceRatingWhereInput
    orderBy?: PlaceRatingOrderByWithRelationInput | PlaceRatingOrderByWithRelationInput[]
    cursor?: PlaceRatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlaceRatingScalarFieldEnum | PlaceRatingScalarFieldEnum[]
  }

  /**
   * Place without action
   */
  export type PlaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
  }


  /**
   * Model ParkingZone
   */

  export type AggregateParkingZone = {
    _count: ParkingZoneCountAggregateOutputType | null
    _avg: ParkingZoneAvgAggregateOutputType | null
    _sum: ParkingZoneSumAggregateOutputType | null
    _min: ParkingZoneMinAggregateOutputType | null
    _max: ParkingZoneMaxAggregateOutputType | null
  }

  export type ParkingZoneAvgAggregateOutputType = {
    id: number | null
    placeId: number | null
    totalSlots: number | null
  }

  export type ParkingZoneSumAggregateOutputType = {
    id: number | null
    placeId: number | null
    totalSlots: number | null
  }

  export type ParkingZoneMinAggregateOutputType = {
    id: number | null
    placeId: number | null
    zoneName: string | null
    floorLevel: string | null
    zoneType: string | null
    totalSlots: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParkingZoneMaxAggregateOutputType = {
    id: number | null
    placeId: number | null
    zoneName: string | null
    floorLevel: string | null
    zoneType: string | null
    totalSlots: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParkingZoneCountAggregateOutputType = {
    id: number
    placeId: number
    zoneName: number
    floorLevel: number
    zoneType: number
    totalSlots: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ParkingZoneAvgAggregateInputType = {
    id?: true
    placeId?: true
    totalSlots?: true
  }

  export type ParkingZoneSumAggregateInputType = {
    id?: true
    placeId?: true
    totalSlots?: true
  }

  export type ParkingZoneMinAggregateInputType = {
    id?: true
    placeId?: true
    zoneName?: true
    floorLevel?: true
    zoneType?: true
    totalSlots?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParkingZoneMaxAggregateInputType = {
    id?: true
    placeId?: true
    zoneName?: true
    floorLevel?: true
    zoneType?: true
    totalSlots?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParkingZoneCountAggregateInputType = {
    id?: true
    placeId?: true
    zoneName?: true
    floorLevel?: true
    zoneType?: true
    totalSlots?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ParkingZoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParkingZone to aggregate.
     */
    where?: ParkingZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParkingZones to fetch.
     */
    orderBy?: ParkingZoneOrderByWithRelationInput | ParkingZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParkingZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParkingZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParkingZones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ParkingZones
    **/
    _count?: true | ParkingZoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParkingZoneAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParkingZoneSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParkingZoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParkingZoneMaxAggregateInputType
  }

  export type GetParkingZoneAggregateType<T extends ParkingZoneAggregateArgs> = {
        [P in keyof T & keyof AggregateParkingZone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParkingZone[P]>
      : GetScalarType<T[P], AggregateParkingZone[P]>
  }




  export type ParkingZoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParkingZoneWhereInput
    orderBy?: ParkingZoneOrderByWithAggregationInput | ParkingZoneOrderByWithAggregationInput[]
    by: ParkingZoneScalarFieldEnum[] | ParkingZoneScalarFieldEnum
    having?: ParkingZoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParkingZoneCountAggregateInputType | true
    _avg?: ParkingZoneAvgAggregateInputType
    _sum?: ParkingZoneSumAggregateInputType
    _min?: ParkingZoneMinAggregateInputType
    _max?: ParkingZoneMaxAggregateInputType
  }

  export type ParkingZoneGroupByOutputType = {
    id: number
    placeId: number
    zoneName: string
    floorLevel: string | null
    zoneType: string | null
    totalSlots: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date | null
    _count: ParkingZoneCountAggregateOutputType | null
    _avg: ParkingZoneAvgAggregateOutputType | null
    _sum: ParkingZoneSumAggregateOutputType | null
    _min: ParkingZoneMinAggregateOutputType | null
    _max: ParkingZoneMaxAggregateOutputType | null
  }

  type GetParkingZoneGroupByPayload<T extends ParkingZoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParkingZoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParkingZoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParkingZoneGroupByOutputType[P]>
            : GetScalarType<T[P], ParkingZoneGroupByOutputType[P]>
        }
      >
    >


  export type ParkingZoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    placeId?: boolean
    zoneName?: boolean
    floorLevel?: boolean
    zoneType?: boolean
    totalSlots?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    place?: boolean | PlaceDefaultArgs<ExtArgs>
    parkingSlots?: boolean | ParkingZone$parkingSlotsArgs<ExtArgs>
    _count?: boolean | ParkingZoneCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parkingZone"]>

  export type ParkingZoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    placeId?: boolean
    zoneName?: boolean
    floorLevel?: boolean
    zoneType?: boolean
    totalSlots?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parkingZone"]>

  export type ParkingZoneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    placeId?: boolean
    zoneName?: boolean
    floorLevel?: boolean
    zoneType?: boolean
    totalSlots?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parkingZone"]>

  export type ParkingZoneSelectScalar = {
    id?: boolean
    placeId?: boolean
    zoneName?: boolean
    floorLevel?: boolean
    zoneType?: boolean
    totalSlots?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ParkingZoneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "placeId" | "zoneName" | "floorLevel" | "zoneType" | "totalSlots" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["parkingZone"]>
  export type ParkingZoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    place?: boolean | PlaceDefaultArgs<ExtArgs>
    parkingSlots?: boolean | ParkingZone$parkingSlotsArgs<ExtArgs>
    _count?: boolean | ParkingZoneCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ParkingZoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }
  export type ParkingZoneIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }

  export type $ParkingZonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ParkingZone"
    objects: {
      place: Prisma.$PlacePayload<ExtArgs>
      parkingSlots: Prisma.$ParkingSlotPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      placeId: number
      zoneName: string
      floorLevel: string | null
      zoneType: string | null
      totalSlots: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["parkingZone"]>
    composites: {}
  }

  type ParkingZoneGetPayload<S extends boolean | null | undefined | ParkingZoneDefaultArgs> = $Result.GetResult<Prisma.$ParkingZonePayload, S>

  type ParkingZoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ParkingZoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParkingZoneCountAggregateInputType | true
    }

  export interface ParkingZoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ParkingZone'], meta: { name: 'ParkingZone' } }
    /**
     * Find zero or one ParkingZone that matches the filter.
     * @param {ParkingZoneFindUniqueArgs} args - Arguments to find a ParkingZone
     * @example
     * // Get one ParkingZone
     * const parkingZone = await prisma.parkingZone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParkingZoneFindUniqueArgs>(args: SelectSubset<T, ParkingZoneFindUniqueArgs<ExtArgs>>): Prisma__ParkingZoneClient<$Result.GetResult<Prisma.$ParkingZonePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ParkingZone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ParkingZoneFindUniqueOrThrowArgs} args - Arguments to find a ParkingZone
     * @example
     * // Get one ParkingZone
     * const parkingZone = await prisma.parkingZone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParkingZoneFindUniqueOrThrowArgs>(args: SelectSubset<T, ParkingZoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParkingZoneClient<$Result.GetResult<Prisma.$ParkingZonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParkingZone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingZoneFindFirstArgs} args - Arguments to find a ParkingZone
     * @example
     * // Get one ParkingZone
     * const parkingZone = await prisma.parkingZone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParkingZoneFindFirstArgs>(args?: SelectSubset<T, ParkingZoneFindFirstArgs<ExtArgs>>): Prisma__ParkingZoneClient<$Result.GetResult<Prisma.$ParkingZonePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParkingZone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingZoneFindFirstOrThrowArgs} args - Arguments to find a ParkingZone
     * @example
     * // Get one ParkingZone
     * const parkingZone = await prisma.parkingZone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParkingZoneFindFirstOrThrowArgs>(args?: SelectSubset<T, ParkingZoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParkingZoneClient<$Result.GetResult<Prisma.$ParkingZonePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ParkingZones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingZoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ParkingZones
     * const parkingZones = await prisma.parkingZone.findMany()
     * 
     * // Get first 10 ParkingZones
     * const parkingZones = await prisma.parkingZone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parkingZoneWithIdOnly = await prisma.parkingZone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParkingZoneFindManyArgs>(args?: SelectSubset<T, ParkingZoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParkingZonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ParkingZone.
     * @param {ParkingZoneCreateArgs} args - Arguments to create a ParkingZone.
     * @example
     * // Create one ParkingZone
     * const ParkingZone = await prisma.parkingZone.create({
     *   data: {
     *     // ... data to create a ParkingZone
     *   }
     * })
     * 
     */
    create<T extends ParkingZoneCreateArgs>(args: SelectSubset<T, ParkingZoneCreateArgs<ExtArgs>>): Prisma__ParkingZoneClient<$Result.GetResult<Prisma.$ParkingZonePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ParkingZones.
     * @param {ParkingZoneCreateManyArgs} args - Arguments to create many ParkingZones.
     * @example
     * // Create many ParkingZones
     * const parkingZone = await prisma.parkingZone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParkingZoneCreateManyArgs>(args?: SelectSubset<T, ParkingZoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ParkingZones and returns the data saved in the database.
     * @param {ParkingZoneCreateManyAndReturnArgs} args - Arguments to create many ParkingZones.
     * @example
     * // Create many ParkingZones
     * const parkingZone = await prisma.parkingZone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ParkingZones and only return the `id`
     * const parkingZoneWithIdOnly = await prisma.parkingZone.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParkingZoneCreateManyAndReturnArgs>(args?: SelectSubset<T, ParkingZoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParkingZonePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ParkingZone.
     * @param {ParkingZoneDeleteArgs} args - Arguments to delete one ParkingZone.
     * @example
     * // Delete one ParkingZone
     * const ParkingZone = await prisma.parkingZone.delete({
     *   where: {
     *     // ... filter to delete one ParkingZone
     *   }
     * })
     * 
     */
    delete<T extends ParkingZoneDeleteArgs>(args: SelectSubset<T, ParkingZoneDeleteArgs<ExtArgs>>): Prisma__ParkingZoneClient<$Result.GetResult<Prisma.$ParkingZonePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ParkingZone.
     * @param {ParkingZoneUpdateArgs} args - Arguments to update one ParkingZone.
     * @example
     * // Update one ParkingZone
     * const parkingZone = await prisma.parkingZone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParkingZoneUpdateArgs>(args: SelectSubset<T, ParkingZoneUpdateArgs<ExtArgs>>): Prisma__ParkingZoneClient<$Result.GetResult<Prisma.$ParkingZonePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ParkingZones.
     * @param {ParkingZoneDeleteManyArgs} args - Arguments to filter ParkingZones to delete.
     * @example
     * // Delete a few ParkingZones
     * const { count } = await prisma.parkingZone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParkingZoneDeleteManyArgs>(args?: SelectSubset<T, ParkingZoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParkingZones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingZoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ParkingZones
     * const parkingZone = await prisma.parkingZone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParkingZoneUpdateManyArgs>(args: SelectSubset<T, ParkingZoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParkingZones and returns the data updated in the database.
     * @param {ParkingZoneUpdateManyAndReturnArgs} args - Arguments to update many ParkingZones.
     * @example
     * // Update many ParkingZones
     * const parkingZone = await prisma.parkingZone.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ParkingZones and only return the `id`
     * const parkingZoneWithIdOnly = await prisma.parkingZone.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ParkingZoneUpdateManyAndReturnArgs>(args: SelectSubset<T, ParkingZoneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParkingZonePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ParkingZone.
     * @param {ParkingZoneUpsertArgs} args - Arguments to update or create a ParkingZone.
     * @example
     * // Update or create a ParkingZone
     * const parkingZone = await prisma.parkingZone.upsert({
     *   create: {
     *     // ... data to create a ParkingZone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ParkingZone we want to update
     *   }
     * })
     */
    upsert<T extends ParkingZoneUpsertArgs>(args: SelectSubset<T, ParkingZoneUpsertArgs<ExtArgs>>): Prisma__ParkingZoneClient<$Result.GetResult<Prisma.$ParkingZonePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ParkingZones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingZoneCountArgs} args - Arguments to filter ParkingZones to count.
     * @example
     * // Count the number of ParkingZones
     * const count = await prisma.parkingZone.count({
     *   where: {
     *     // ... the filter for the ParkingZones we want to count
     *   }
     * })
    **/
    count<T extends ParkingZoneCountArgs>(
      args?: Subset<T, ParkingZoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParkingZoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ParkingZone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingZoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParkingZoneAggregateArgs>(args: Subset<T, ParkingZoneAggregateArgs>): Prisma.PrismaPromise<GetParkingZoneAggregateType<T>>

    /**
     * Group by ParkingZone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingZoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParkingZoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParkingZoneGroupByArgs['orderBy'] }
        : { orderBy?: ParkingZoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParkingZoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParkingZoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ParkingZone model
   */
  readonly fields: ParkingZoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ParkingZone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParkingZoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    place<T extends PlaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlaceDefaultArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parkingSlots<T extends ParkingZone$parkingSlotsArgs<ExtArgs> = {}>(args?: Subset<T, ParkingZone$parkingSlotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ParkingZone model
   */
  interface ParkingZoneFieldRefs {
    readonly id: FieldRef<"ParkingZone", 'Int'>
    readonly placeId: FieldRef<"ParkingZone", 'Int'>
    readonly zoneName: FieldRef<"ParkingZone", 'String'>
    readonly floorLevel: FieldRef<"ParkingZone", 'String'>
    readonly zoneType: FieldRef<"ParkingZone", 'String'>
    readonly totalSlots: FieldRef<"ParkingZone", 'Int'>
    readonly isActive: FieldRef<"ParkingZone", 'Boolean'>
    readonly createdAt: FieldRef<"ParkingZone", 'DateTime'>
    readonly updatedAt: FieldRef<"ParkingZone", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ParkingZone findUnique
   */
  export type ParkingZoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingZone
     */
    select?: ParkingZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingZone
     */
    omit?: ParkingZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingZoneInclude<ExtArgs> | null
    /**
     * Filter, which ParkingZone to fetch.
     */
    where: ParkingZoneWhereUniqueInput
  }

  /**
   * ParkingZone findUniqueOrThrow
   */
  export type ParkingZoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingZone
     */
    select?: ParkingZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingZone
     */
    omit?: ParkingZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingZoneInclude<ExtArgs> | null
    /**
     * Filter, which ParkingZone to fetch.
     */
    where: ParkingZoneWhereUniqueInput
  }

  /**
   * ParkingZone findFirst
   */
  export type ParkingZoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingZone
     */
    select?: ParkingZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingZone
     */
    omit?: ParkingZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingZoneInclude<ExtArgs> | null
    /**
     * Filter, which ParkingZone to fetch.
     */
    where?: ParkingZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParkingZones to fetch.
     */
    orderBy?: ParkingZoneOrderByWithRelationInput | ParkingZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParkingZones.
     */
    cursor?: ParkingZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParkingZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParkingZones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParkingZones.
     */
    distinct?: ParkingZoneScalarFieldEnum | ParkingZoneScalarFieldEnum[]
  }

  /**
   * ParkingZone findFirstOrThrow
   */
  export type ParkingZoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingZone
     */
    select?: ParkingZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingZone
     */
    omit?: ParkingZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingZoneInclude<ExtArgs> | null
    /**
     * Filter, which ParkingZone to fetch.
     */
    where?: ParkingZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParkingZones to fetch.
     */
    orderBy?: ParkingZoneOrderByWithRelationInput | ParkingZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParkingZones.
     */
    cursor?: ParkingZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParkingZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParkingZones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParkingZones.
     */
    distinct?: ParkingZoneScalarFieldEnum | ParkingZoneScalarFieldEnum[]
  }

  /**
   * ParkingZone findMany
   */
  export type ParkingZoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingZone
     */
    select?: ParkingZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingZone
     */
    omit?: ParkingZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingZoneInclude<ExtArgs> | null
    /**
     * Filter, which ParkingZones to fetch.
     */
    where?: ParkingZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParkingZones to fetch.
     */
    orderBy?: ParkingZoneOrderByWithRelationInput | ParkingZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ParkingZones.
     */
    cursor?: ParkingZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParkingZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParkingZones.
     */
    skip?: number
    distinct?: ParkingZoneScalarFieldEnum | ParkingZoneScalarFieldEnum[]
  }

  /**
   * ParkingZone create
   */
  export type ParkingZoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingZone
     */
    select?: ParkingZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingZone
     */
    omit?: ParkingZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingZoneInclude<ExtArgs> | null
    /**
     * The data needed to create a ParkingZone.
     */
    data: XOR<ParkingZoneCreateInput, ParkingZoneUncheckedCreateInput>
  }

  /**
   * ParkingZone createMany
   */
  export type ParkingZoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ParkingZones.
     */
    data: ParkingZoneCreateManyInput | ParkingZoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ParkingZone createManyAndReturn
   */
  export type ParkingZoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingZone
     */
    select?: ParkingZoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingZone
     */
    omit?: ParkingZoneOmit<ExtArgs> | null
    /**
     * The data used to create many ParkingZones.
     */
    data: ParkingZoneCreateManyInput | ParkingZoneCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingZoneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ParkingZone update
   */
  export type ParkingZoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingZone
     */
    select?: ParkingZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingZone
     */
    omit?: ParkingZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingZoneInclude<ExtArgs> | null
    /**
     * The data needed to update a ParkingZone.
     */
    data: XOR<ParkingZoneUpdateInput, ParkingZoneUncheckedUpdateInput>
    /**
     * Choose, which ParkingZone to update.
     */
    where: ParkingZoneWhereUniqueInput
  }

  /**
   * ParkingZone updateMany
   */
  export type ParkingZoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ParkingZones.
     */
    data: XOR<ParkingZoneUpdateManyMutationInput, ParkingZoneUncheckedUpdateManyInput>
    /**
     * Filter which ParkingZones to update
     */
    where?: ParkingZoneWhereInput
    /**
     * Limit how many ParkingZones to update.
     */
    limit?: number
  }

  /**
   * ParkingZone updateManyAndReturn
   */
  export type ParkingZoneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingZone
     */
    select?: ParkingZoneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingZone
     */
    omit?: ParkingZoneOmit<ExtArgs> | null
    /**
     * The data used to update ParkingZones.
     */
    data: XOR<ParkingZoneUpdateManyMutationInput, ParkingZoneUncheckedUpdateManyInput>
    /**
     * Filter which ParkingZones to update
     */
    where?: ParkingZoneWhereInput
    /**
     * Limit how many ParkingZones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingZoneIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ParkingZone upsert
   */
  export type ParkingZoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingZone
     */
    select?: ParkingZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingZone
     */
    omit?: ParkingZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingZoneInclude<ExtArgs> | null
    /**
     * The filter to search for the ParkingZone to update in case it exists.
     */
    where: ParkingZoneWhereUniqueInput
    /**
     * In case the ParkingZone found by the `where` argument doesn't exist, create a new ParkingZone with this data.
     */
    create: XOR<ParkingZoneCreateInput, ParkingZoneUncheckedCreateInput>
    /**
     * In case the ParkingZone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParkingZoneUpdateInput, ParkingZoneUncheckedUpdateInput>
  }

  /**
   * ParkingZone delete
   */
  export type ParkingZoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingZone
     */
    select?: ParkingZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingZone
     */
    omit?: ParkingZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingZoneInclude<ExtArgs> | null
    /**
     * Filter which ParkingZone to delete.
     */
    where: ParkingZoneWhereUniqueInput
  }

  /**
   * ParkingZone deleteMany
   */
  export type ParkingZoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParkingZones to delete
     */
    where?: ParkingZoneWhereInput
    /**
     * Limit how many ParkingZones to delete.
     */
    limit?: number
  }

  /**
   * ParkingZone.parkingSlots
   */
  export type ParkingZone$parkingSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
    where?: ParkingSlotWhereInput
    orderBy?: ParkingSlotOrderByWithRelationInput | ParkingSlotOrderByWithRelationInput[]
    cursor?: ParkingSlotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParkingSlotScalarFieldEnum | ParkingSlotScalarFieldEnum[]
  }

  /**
   * ParkingZone without action
   */
  export type ParkingZoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingZone
     */
    select?: ParkingZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingZone
     */
    omit?: ParkingZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingZoneInclude<ExtArgs> | null
  }


  /**
   * Model ParkingSlot
   */

  export type AggregateParkingSlot = {
    _count: ParkingSlotCountAggregateOutputType | null
    _avg: ParkingSlotAvgAggregateOutputType | null
    _sum: ParkingSlotSumAggregateOutputType | null
    _min: ParkingSlotMinAggregateOutputType | null
    _max: ParkingSlotMaxAggregateOutputType | null
  }

  export type ParkingSlotAvgAggregateOutputType = {
    id: number | null
    zoneId: number | null
  }

  export type ParkingSlotSumAggregateOutputType = {
    id: number | null
    zoneId: number | null
  }

  export type ParkingSlotMinAggregateOutputType = {
    id: number | null
    zoneId: number | null
    slotNumber: string | null
    slotType: string | null
    isReserved: boolean | null
    isOccupied: boolean | null
    isDisabledFriendly: boolean | null
    hasEvCharger: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParkingSlotMaxAggregateOutputType = {
    id: number | null
    zoneId: number | null
    slotNumber: string | null
    slotType: string | null
    isReserved: boolean | null
    isOccupied: boolean | null
    isDisabledFriendly: boolean | null
    hasEvCharger: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParkingSlotCountAggregateOutputType = {
    id: number
    zoneId: number
    slotNumber: number
    slotType: number
    isReserved: number
    isOccupied: number
    isDisabledFriendly: number
    hasEvCharger: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ParkingSlotAvgAggregateInputType = {
    id?: true
    zoneId?: true
  }

  export type ParkingSlotSumAggregateInputType = {
    id?: true
    zoneId?: true
  }

  export type ParkingSlotMinAggregateInputType = {
    id?: true
    zoneId?: true
    slotNumber?: true
    slotType?: true
    isReserved?: true
    isOccupied?: true
    isDisabledFriendly?: true
    hasEvCharger?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParkingSlotMaxAggregateInputType = {
    id?: true
    zoneId?: true
    slotNumber?: true
    slotType?: true
    isReserved?: true
    isOccupied?: true
    isDisabledFriendly?: true
    hasEvCharger?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParkingSlotCountAggregateInputType = {
    id?: true
    zoneId?: true
    slotNumber?: true
    slotType?: true
    isReserved?: true
    isOccupied?: true
    isDisabledFriendly?: true
    hasEvCharger?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ParkingSlotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParkingSlot to aggregate.
     */
    where?: ParkingSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParkingSlots to fetch.
     */
    orderBy?: ParkingSlotOrderByWithRelationInput | ParkingSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParkingSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParkingSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParkingSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ParkingSlots
    **/
    _count?: true | ParkingSlotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParkingSlotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParkingSlotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParkingSlotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParkingSlotMaxAggregateInputType
  }

  export type GetParkingSlotAggregateType<T extends ParkingSlotAggregateArgs> = {
        [P in keyof T & keyof AggregateParkingSlot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParkingSlot[P]>
      : GetScalarType<T[P], AggregateParkingSlot[P]>
  }




  export type ParkingSlotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParkingSlotWhereInput
    orderBy?: ParkingSlotOrderByWithAggregationInput | ParkingSlotOrderByWithAggregationInput[]
    by: ParkingSlotScalarFieldEnum[] | ParkingSlotScalarFieldEnum
    having?: ParkingSlotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParkingSlotCountAggregateInputType | true
    _avg?: ParkingSlotAvgAggregateInputType
    _sum?: ParkingSlotSumAggregateInputType
    _min?: ParkingSlotMinAggregateInputType
    _max?: ParkingSlotMaxAggregateInputType
  }

  export type ParkingSlotGroupByOutputType = {
    id: number
    zoneId: number
    slotNumber: string
    slotType: string
    isReserved: boolean
    isOccupied: boolean
    isDisabledFriendly: boolean
    hasEvCharger: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date | null
    _count: ParkingSlotCountAggregateOutputType | null
    _avg: ParkingSlotAvgAggregateOutputType | null
    _sum: ParkingSlotSumAggregateOutputType | null
    _min: ParkingSlotMinAggregateOutputType | null
    _max: ParkingSlotMaxAggregateOutputType | null
  }

  type GetParkingSlotGroupByPayload<T extends ParkingSlotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParkingSlotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParkingSlotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParkingSlotGroupByOutputType[P]>
            : GetScalarType<T[P], ParkingSlotGroupByOutputType[P]>
        }
      >
    >


  export type ParkingSlotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    zoneId?: boolean
    slotNumber?: boolean
    slotType?: boolean
    isReserved?: boolean
    isOccupied?: boolean
    isDisabledFriendly?: boolean
    hasEvCharger?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parkingZone?: boolean | ParkingZoneDefaultArgs<ExtArgs>
    slotAvailability?: boolean | ParkingSlot$slotAvailabilityArgs<ExtArgs>
    bookings?: boolean | ParkingSlot$bookingsArgs<ExtArgs>
    _count?: boolean | ParkingSlotCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parkingSlot"]>

  export type ParkingSlotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    zoneId?: boolean
    slotNumber?: boolean
    slotType?: boolean
    isReserved?: boolean
    isOccupied?: boolean
    isDisabledFriendly?: boolean
    hasEvCharger?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parkingZone?: boolean | ParkingZoneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parkingSlot"]>

  export type ParkingSlotSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    zoneId?: boolean
    slotNumber?: boolean
    slotType?: boolean
    isReserved?: boolean
    isOccupied?: boolean
    isDisabledFriendly?: boolean
    hasEvCharger?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parkingZone?: boolean | ParkingZoneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parkingSlot"]>

  export type ParkingSlotSelectScalar = {
    id?: boolean
    zoneId?: boolean
    slotNumber?: boolean
    slotType?: boolean
    isReserved?: boolean
    isOccupied?: boolean
    isDisabledFriendly?: boolean
    hasEvCharger?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ParkingSlotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "zoneId" | "slotNumber" | "slotType" | "isReserved" | "isOccupied" | "isDisabledFriendly" | "hasEvCharger" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["parkingSlot"]>
  export type ParkingSlotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parkingZone?: boolean | ParkingZoneDefaultArgs<ExtArgs>
    slotAvailability?: boolean | ParkingSlot$slotAvailabilityArgs<ExtArgs>
    bookings?: boolean | ParkingSlot$bookingsArgs<ExtArgs>
    _count?: boolean | ParkingSlotCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ParkingSlotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parkingZone?: boolean | ParkingZoneDefaultArgs<ExtArgs>
  }
  export type ParkingSlotIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parkingZone?: boolean | ParkingZoneDefaultArgs<ExtArgs>
  }

  export type $ParkingSlotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ParkingSlot"
    objects: {
      parkingZone: Prisma.$ParkingZonePayload<ExtArgs>
      slotAvailability: Prisma.$SlotAvailabilityPayload<ExtArgs>[]
      bookings: Prisma.$BookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      zoneId: number
      slotNumber: string
      slotType: string
      isReserved: boolean
      isOccupied: boolean
      isDisabledFriendly: boolean
      hasEvCharger: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["parkingSlot"]>
    composites: {}
  }

  type ParkingSlotGetPayload<S extends boolean | null | undefined | ParkingSlotDefaultArgs> = $Result.GetResult<Prisma.$ParkingSlotPayload, S>

  type ParkingSlotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ParkingSlotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParkingSlotCountAggregateInputType | true
    }

  export interface ParkingSlotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ParkingSlot'], meta: { name: 'ParkingSlot' } }
    /**
     * Find zero or one ParkingSlot that matches the filter.
     * @param {ParkingSlotFindUniqueArgs} args - Arguments to find a ParkingSlot
     * @example
     * // Get one ParkingSlot
     * const parkingSlot = await prisma.parkingSlot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParkingSlotFindUniqueArgs>(args: SelectSubset<T, ParkingSlotFindUniqueArgs<ExtArgs>>): Prisma__ParkingSlotClient<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ParkingSlot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ParkingSlotFindUniqueOrThrowArgs} args - Arguments to find a ParkingSlot
     * @example
     * // Get one ParkingSlot
     * const parkingSlot = await prisma.parkingSlot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParkingSlotFindUniqueOrThrowArgs>(args: SelectSubset<T, ParkingSlotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParkingSlotClient<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParkingSlot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingSlotFindFirstArgs} args - Arguments to find a ParkingSlot
     * @example
     * // Get one ParkingSlot
     * const parkingSlot = await prisma.parkingSlot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParkingSlotFindFirstArgs>(args?: SelectSubset<T, ParkingSlotFindFirstArgs<ExtArgs>>): Prisma__ParkingSlotClient<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParkingSlot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingSlotFindFirstOrThrowArgs} args - Arguments to find a ParkingSlot
     * @example
     * // Get one ParkingSlot
     * const parkingSlot = await prisma.parkingSlot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParkingSlotFindFirstOrThrowArgs>(args?: SelectSubset<T, ParkingSlotFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParkingSlotClient<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ParkingSlots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingSlotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ParkingSlots
     * const parkingSlots = await prisma.parkingSlot.findMany()
     * 
     * // Get first 10 ParkingSlots
     * const parkingSlots = await prisma.parkingSlot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parkingSlotWithIdOnly = await prisma.parkingSlot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParkingSlotFindManyArgs>(args?: SelectSubset<T, ParkingSlotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ParkingSlot.
     * @param {ParkingSlotCreateArgs} args - Arguments to create a ParkingSlot.
     * @example
     * // Create one ParkingSlot
     * const ParkingSlot = await prisma.parkingSlot.create({
     *   data: {
     *     // ... data to create a ParkingSlot
     *   }
     * })
     * 
     */
    create<T extends ParkingSlotCreateArgs>(args: SelectSubset<T, ParkingSlotCreateArgs<ExtArgs>>): Prisma__ParkingSlotClient<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ParkingSlots.
     * @param {ParkingSlotCreateManyArgs} args - Arguments to create many ParkingSlots.
     * @example
     * // Create many ParkingSlots
     * const parkingSlot = await prisma.parkingSlot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParkingSlotCreateManyArgs>(args?: SelectSubset<T, ParkingSlotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ParkingSlots and returns the data saved in the database.
     * @param {ParkingSlotCreateManyAndReturnArgs} args - Arguments to create many ParkingSlots.
     * @example
     * // Create many ParkingSlots
     * const parkingSlot = await prisma.parkingSlot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ParkingSlots and only return the `id`
     * const parkingSlotWithIdOnly = await prisma.parkingSlot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParkingSlotCreateManyAndReturnArgs>(args?: SelectSubset<T, ParkingSlotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ParkingSlot.
     * @param {ParkingSlotDeleteArgs} args - Arguments to delete one ParkingSlot.
     * @example
     * // Delete one ParkingSlot
     * const ParkingSlot = await prisma.parkingSlot.delete({
     *   where: {
     *     // ... filter to delete one ParkingSlot
     *   }
     * })
     * 
     */
    delete<T extends ParkingSlotDeleteArgs>(args: SelectSubset<T, ParkingSlotDeleteArgs<ExtArgs>>): Prisma__ParkingSlotClient<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ParkingSlot.
     * @param {ParkingSlotUpdateArgs} args - Arguments to update one ParkingSlot.
     * @example
     * // Update one ParkingSlot
     * const parkingSlot = await prisma.parkingSlot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParkingSlotUpdateArgs>(args: SelectSubset<T, ParkingSlotUpdateArgs<ExtArgs>>): Prisma__ParkingSlotClient<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ParkingSlots.
     * @param {ParkingSlotDeleteManyArgs} args - Arguments to filter ParkingSlots to delete.
     * @example
     * // Delete a few ParkingSlots
     * const { count } = await prisma.parkingSlot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParkingSlotDeleteManyArgs>(args?: SelectSubset<T, ParkingSlotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParkingSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingSlotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ParkingSlots
     * const parkingSlot = await prisma.parkingSlot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParkingSlotUpdateManyArgs>(args: SelectSubset<T, ParkingSlotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParkingSlots and returns the data updated in the database.
     * @param {ParkingSlotUpdateManyAndReturnArgs} args - Arguments to update many ParkingSlots.
     * @example
     * // Update many ParkingSlots
     * const parkingSlot = await prisma.parkingSlot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ParkingSlots and only return the `id`
     * const parkingSlotWithIdOnly = await prisma.parkingSlot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ParkingSlotUpdateManyAndReturnArgs>(args: SelectSubset<T, ParkingSlotUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ParkingSlot.
     * @param {ParkingSlotUpsertArgs} args - Arguments to update or create a ParkingSlot.
     * @example
     * // Update or create a ParkingSlot
     * const parkingSlot = await prisma.parkingSlot.upsert({
     *   create: {
     *     // ... data to create a ParkingSlot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ParkingSlot we want to update
     *   }
     * })
     */
    upsert<T extends ParkingSlotUpsertArgs>(args: SelectSubset<T, ParkingSlotUpsertArgs<ExtArgs>>): Prisma__ParkingSlotClient<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ParkingSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingSlotCountArgs} args - Arguments to filter ParkingSlots to count.
     * @example
     * // Count the number of ParkingSlots
     * const count = await prisma.parkingSlot.count({
     *   where: {
     *     // ... the filter for the ParkingSlots we want to count
     *   }
     * })
    **/
    count<T extends ParkingSlotCountArgs>(
      args?: Subset<T, ParkingSlotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParkingSlotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ParkingSlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingSlotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParkingSlotAggregateArgs>(args: Subset<T, ParkingSlotAggregateArgs>): Prisma.PrismaPromise<GetParkingSlotAggregateType<T>>

    /**
     * Group by ParkingSlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingSlotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParkingSlotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParkingSlotGroupByArgs['orderBy'] }
        : { orderBy?: ParkingSlotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParkingSlotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParkingSlotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ParkingSlot model
   */
  readonly fields: ParkingSlotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ParkingSlot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParkingSlotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parkingZone<T extends ParkingZoneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParkingZoneDefaultArgs<ExtArgs>>): Prisma__ParkingZoneClient<$Result.GetResult<Prisma.$ParkingZonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    slotAvailability<T extends ParkingSlot$slotAvailabilityArgs<ExtArgs> = {}>(args?: Subset<T, ParkingSlot$slotAvailabilityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SlotAvailabilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookings<T extends ParkingSlot$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, ParkingSlot$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ParkingSlot model
   */
  interface ParkingSlotFieldRefs {
    readonly id: FieldRef<"ParkingSlot", 'Int'>
    readonly zoneId: FieldRef<"ParkingSlot", 'Int'>
    readonly slotNumber: FieldRef<"ParkingSlot", 'String'>
    readonly slotType: FieldRef<"ParkingSlot", 'String'>
    readonly isReserved: FieldRef<"ParkingSlot", 'Boolean'>
    readonly isOccupied: FieldRef<"ParkingSlot", 'Boolean'>
    readonly isDisabledFriendly: FieldRef<"ParkingSlot", 'Boolean'>
    readonly hasEvCharger: FieldRef<"ParkingSlot", 'Boolean'>
    readonly isActive: FieldRef<"ParkingSlot", 'Boolean'>
    readonly createdAt: FieldRef<"ParkingSlot", 'DateTime'>
    readonly updatedAt: FieldRef<"ParkingSlot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ParkingSlot findUnique
   */
  export type ParkingSlotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
    /**
     * Filter, which ParkingSlot to fetch.
     */
    where: ParkingSlotWhereUniqueInput
  }

  /**
   * ParkingSlot findUniqueOrThrow
   */
  export type ParkingSlotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
    /**
     * Filter, which ParkingSlot to fetch.
     */
    where: ParkingSlotWhereUniqueInput
  }

  /**
   * ParkingSlot findFirst
   */
  export type ParkingSlotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
    /**
     * Filter, which ParkingSlot to fetch.
     */
    where?: ParkingSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParkingSlots to fetch.
     */
    orderBy?: ParkingSlotOrderByWithRelationInput | ParkingSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParkingSlots.
     */
    cursor?: ParkingSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParkingSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParkingSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParkingSlots.
     */
    distinct?: ParkingSlotScalarFieldEnum | ParkingSlotScalarFieldEnum[]
  }

  /**
   * ParkingSlot findFirstOrThrow
   */
  export type ParkingSlotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
    /**
     * Filter, which ParkingSlot to fetch.
     */
    where?: ParkingSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParkingSlots to fetch.
     */
    orderBy?: ParkingSlotOrderByWithRelationInput | ParkingSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParkingSlots.
     */
    cursor?: ParkingSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParkingSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParkingSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParkingSlots.
     */
    distinct?: ParkingSlotScalarFieldEnum | ParkingSlotScalarFieldEnum[]
  }

  /**
   * ParkingSlot findMany
   */
  export type ParkingSlotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
    /**
     * Filter, which ParkingSlots to fetch.
     */
    where?: ParkingSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParkingSlots to fetch.
     */
    orderBy?: ParkingSlotOrderByWithRelationInput | ParkingSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ParkingSlots.
     */
    cursor?: ParkingSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParkingSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParkingSlots.
     */
    skip?: number
    distinct?: ParkingSlotScalarFieldEnum | ParkingSlotScalarFieldEnum[]
  }

  /**
   * ParkingSlot create
   */
  export type ParkingSlotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
    /**
     * The data needed to create a ParkingSlot.
     */
    data: XOR<ParkingSlotCreateInput, ParkingSlotUncheckedCreateInput>
  }

  /**
   * ParkingSlot createMany
   */
  export type ParkingSlotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ParkingSlots.
     */
    data: ParkingSlotCreateManyInput | ParkingSlotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ParkingSlot createManyAndReturn
   */
  export type ParkingSlotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * The data used to create many ParkingSlots.
     */
    data: ParkingSlotCreateManyInput | ParkingSlotCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ParkingSlot update
   */
  export type ParkingSlotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
    /**
     * The data needed to update a ParkingSlot.
     */
    data: XOR<ParkingSlotUpdateInput, ParkingSlotUncheckedUpdateInput>
    /**
     * Choose, which ParkingSlot to update.
     */
    where: ParkingSlotWhereUniqueInput
  }

  /**
   * ParkingSlot updateMany
   */
  export type ParkingSlotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ParkingSlots.
     */
    data: XOR<ParkingSlotUpdateManyMutationInput, ParkingSlotUncheckedUpdateManyInput>
    /**
     * Filter which ParkingSlots to update
     */
    where?: ParkingSlotWhereInput
    /**
     * Limit how many ParkingSlots to update.
     */
    limit?: number
  }

  /**
   * ParkingSlot updateManyAndReturn
   */
  export type ParkingSlotUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * The data used to update ParkingSlots.
     */
    data: XOR<ParkingSlotUpdateManyMutationInput, ParkingSlotUncheckedUpdateManyInput>
    /**
     * Filter which ParkingSlots to update
     */
    where?: ParkingSlotWhereInput
    /**
     * Limit how many ParkingSlots to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ParkingSlot upsert
   */
  export type ParkingSlotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
    /**
     * The filter to search for the ParkingSlot to update in case it exists.
     */
    where: ParkingSlotWhereUniqueInput
    /**
     * In case the ParkingSlot found by the `where` argument doesn't exist, create a new ParkingSlot with this data.
     */
    create: XOR<ParkingSlotCreateInput, ParkingSlotUncheckedCreateInput>
    /**
     * In case the ParkingSlot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParkingSlotUpdateInput, ParkingSlotUncheckedUpdateInput>
  }

  /**
   * ParkingSlot delete
   */
  export type ParkingSlotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
    /**
     * Filter which ParkingSlot to delete.
     */
    where: ParkingSlotWhereUniqueInput
  }

  /**
   * ParkingSlot deleteMany
   */
  export type ParkingSlotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParkingSlots to delete
     */
    where?: ParkingSlotWhereInput
    /**
     * Limit how many ParkingSlots to delete.
     */
    limit?: number
  }

  /**
   * ParkingSlot.slotAvailability
   */
  export type ParkingSlot$slotAvailabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlotAvailability
     */
    select?: SlotAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlotAvailability
     */
    omit?: SlotAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotAvailabilityInclude<ExtArgs> | null
    where?: SlotAvailabilityWhereInput
    orderBy?: SlotAvailabilityOrderByWithRelationInput | SlotAvailabilityOrderByWithRelationInput[]
    cursor?: SlotAvailabilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SlotAvailabilityScalarFieldEnum | SlotAvailabilityScalarFieldEnum[]
  }

  /**
   * ParkingSlot.bookings
   */
  export type ParkingSlot$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * ParkingSlot without action
   */
  export type ParkingSlotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingSlot
     */
    select?: ParkingSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingSlot
     */
    omit?: ParkingSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingSlotInclude<ExtArgs> | null
  }


  /**
   * Model SlotAvailability
   */

  export type AggregateSlotAvailability = {
    _count: SlotAvailabilityCountAggregateOutputType | null
    _avg: SlotAvailabilityAvgAggregateOutputType | null
    _sum: SlotAvailabilitySumAggregateOutputType | null
    _min: SlotAvailabilityMinAggregateOutputType | null
    _max: SlotAvailabilityMaxAggregateOutputType | null
  }

  export type SlotAvailabilityAvgAggregateOutputType = {
    id: number | null
    slotId: number | null
  }

  export type SlotAvailabilitySumAggregateOutputType = {
    id: number | null
    slotId: number | null
  }

  export type SlotAvailabilityMinAggregateOutputType = {
    id: number | null
    slotId: number | null
    availableFrom: Date | null
    availableUntil: Date | null
    isBookable: boolean | null
    statusReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SlotAvailabilityMaxAggregateOutputType = {
    id: number | null
    slotId: number | null
    availableFrom: Date | null
    availableUntil: Date | null
    isBookable: boolean | null
    statusReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SlotAvailabilityCountAggregateOutputType = {
    id: number
    slotId: number
    availableFrom: number
    availableUntil: number
    isBookable: number
    statusReason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SlotAvailabilityAvgAggregateInputType = {
    id?: true
    slotId?: true
  }

  export type SlotAvailabilitySumAggregateInputType = {
    id?: true
    slotId?: true
  }

  export type SlotAvailabilityMinAggregateInputType = {
    id?: true
    slotId?: true
    availableFrom?: true
    availableUntil?: true
    isBookable?: true
    statusReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SlotAvailabilityMaxAggregateInputType = {
    id?: true
    slotId?: true
    availableFrom?: true
    availableUntil?: true
    isBookable?: true
    statusReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SlotAvailabilityCountAggregateInputType = {
    id?: true
    slotId?: true
    availableFrom?: true
    availableUntil?: true
    isBookable?: true
    statusReason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SlotAvailabilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SlotAvailability to aggregate.
     */
    where?: SlotAvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SlotAvailabilities to fetch.
     */
    orderBy?: SlotAvailabilityOrderByWithRelationInput | SlotAvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SlotAvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SlotAvailabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SlotAvailabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SlotAvailabilities
    **/
    _count?: true | SlotAvailabilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SlotAvailabilityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SlotAvailabilitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SlotAvailabilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SlotAvailabilityMaxAggregateInputType
  }

  export type GetSlotAvailabilityAggregateType<T extends SlotAvailabilityAggregateArgs> = {
        [P in keyof T & keyof AggregateSlotAvailability]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSlotAvailability[P]>
      : GetScalarType<T[P], AggregateSlotAvailability[P]>
  }




  export type SlotAvailabilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SlotAvailabilityWhereInput
    orderBy?: SlotAvailabilityOrderByWithAggregationInput | SlotAvailabilityOrderByWithAggregationInput[]
    by: SlotAvailabilityScalarFieldEnum[] | SlotAvailabilityScalarFieldEnum
    having?: SlotAvailabilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SlotAvailabilityCountAggregateInputType | true
    _avg?: SlotAvailabilityAvgAggregateInputType
    _sum?: SlotAvailabilitySumAggregateInputType
    _min?: SlotAvailabilityMinAggregateInputType
    _max?: SlotAvailabilityMaxAggregateInputType
  }

  export type SlotAvailabilityGroupByOutputType = {
    id: number
    slotId: number
    availableFrom: Date
    availableUntil: Date
    isBookable: boolean
    statusReason: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: SlotAvailabilityCountAggregateOutputType | null
    _avg: SlotAvailabilityAvgAggregateOutputType | null
    _sum: SlotAvailabilitySumAggregateOutputType | null
    _min: SlotAvailabilityMinAggregateOutputType | null
    _max: SlotAvailabilityMaxAggregateOutputType | null
  }

  type GetSlotAvailabilityGroupByPayload<T extends SlotAvailabilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SlotAvailabilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SlotAvailabilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SlotAvailabilityGroupByOutputType[P]>
            : GetScalarType<T[P], SlotAvailabilityGroupByOutputType[P]>
        }
      >
    >


  export type SlotAvailabilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slotId?: boolean
    availableFrom?: boolean
    availableUntil?: boolean
    isBookable?: boolean
    statusReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parkingSlot?: boolean | ParkingSlotDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["slotAvailability"]>

  export type SlotAvailabilitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slotId?: boolean
    availableFrom?: boolean
    availableUntil?: boolean
    isBookable?: boolean
    statusReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parkingSlot?: boolean | ParkingSlotDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["slotAvailability"]>

  export type SlotAvailabilitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slotId?: boolean
    availableFrom?: boolean
    availableUntil?: boolean
    isBookable?: boolean
    statusReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parkingSlot?: boolean | ParkingSlotDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["slotAvailability"]>

  export type SlotAvailabilitySelectScalar = {
    id?: boolean
    slotId?: boolean
    availableFrom?: boolean
    availableUntil?: boolean
    isBookable?: boolean
    statusReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SlotAvailabilityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slotId" | "availableFrom" | "availableUntil" | "isBookable" | "statusReason" | "createdAt" | "updatedAt", ExtArgs["result"]["slotAvailability"]>
  export type SlotAvailabilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parkingSlot?: boolean | ParkingSlotDefaultArgs<ExtArgs>
  }
  export type SlotAvailabilityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parkingSlot?: boolean | ParkingSlotDefaultArgs<ExtArgs>
  }
  export type SlotAvailabilityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parkingSlot?: boolean | ParkingSlotDefaultArgs<ExtArgs>
  }

  export type $SlotAvailabilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SlotAvailability"
    objects: {
      parkingSlot: Prisma.$ParkingSlotPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      slotId: number
      availableFrom: Date
      availableUntil: Date
      isBookable: boolean
      statusReason: string | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["slotAvailability"]>
    composites: {}
  }

  type SlotAvailabilityGetPayload<S extends boolean | null | undefined | SlotAvailabilityDefaultArgs> = $Result.GetResult<Prisma.$SlotAvailabilityPayload, S>

  type SlotAvailabilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SlotAvailabilityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SlotAvailabilityCountAggregateInputType | true
    }

  export interface SlotAvailabilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SlotAvailability'], meta: { name: 'SlotAvailability' } }
    /**
     * Find zero or one SlotAvailability that matches the filter.
     * @param {SlotAvailabilityFindUniqueArgs} args - Arguments to find a SlotAvailability
     * @example
     * // Get one SlotAvailability
     * const slotAvailability = await prisma.slotAvailability.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SlotAvailabilityFindUniqueArgs>(args: SelectSubset<T, SlotAvailabilityFindUniqueArgs<ExtArgs>>): Prisma__SlotAvailabilityClient<$Result.GetResult<Prisma.$SlotAvailabilityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SlotAvailability that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SlotAvailabilityFindUniqueOrThrowArgs} args - Arguments to find a SlotAvailability
     * @example
     * // Get one SlotAvailability
     * const slotAvailability = await prisma.slotAvailability.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SlotAvailabilityFindUniqueOrThrowArgs>(args: SelectSubset<T, SlotAvailabilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SlotAvailabilityClient<$Result.GetResult<Prisma.$SlotAvailabilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SlotAvailability that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlotAvailabilityFindFirstArgs} args - Arguments to find a SlotAvailability
     * @example
     * // Get one SlotAvailability
     * const slotAvailability = await prisma.slotAvailability.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SlotAvailabilityFindFirstArgs>(args?: SelectSubset<T, SlotAvailabilityFindFirstArgs<ExtArgs>>): Prisma__SlotAvailabilityClient<$Result.GetResult<Prisma.$SlotAvailabilityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SlotAvailability that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlotAvailabilityFindFirstOrThrowArgs} args - Arguments to find a SlotAvailability
     * @example
     * // Get one SlotAvailability
     * const slotAvailability = await prisma.slotAvailability.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SlotAvailabilityFindFirstOrThrowArgs>(args?: SelectSubset<T, SlotAvailabilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__SlotAvailabilityClient<$Result.GetResult<Prisma.$SlotAvailabilityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SlotAvailabilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlotAvailabilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SlotAvailabilities
     * const slotAvailabilities = await prisma.slotAvailability.findMany()
     * 
     * // Get first 10 SlotAvailabilities
     * const slotAvailabilities = await prisma.slotAvailability.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const slotAvailabilityWithIdOnly = await prisma.slotAvailability.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SlotAvailabilityFindManyArgs>(args?: SelectSubset<T, SlotAvailabilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SlotAvailabilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SlotAvailability.
     * @param {SlotAvailabilityCreateArgs} args - Arguments to create a SlotAvailability.
     * @example
     * // Create one SlotAvailability
     * const SlotAvailability = await prisma.slotAvailability.create({
     *   data: {
     *     // ... data to create a SlotAvailability
     *   }
     * })
     * 
     */
    create<T extends SlotAvailabilityCreateArgs>(args: SelectSubset<T, SlotAvailabilityCreateArgs<ExtArgs>>): Prisma__SlotAvailabilityClient<$Result.GetResult<Prisma.$SlotAvailabilityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SlotAvailabilities.
     * @param {SlotAvailabilityCreateManyArgs} args - Arguments to create many SlotAvailabilities.
     * @example
     * // Create many SlotAvailabilities
     * const slotAvailability = await prisma.slotAvailability.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SlotAvailabilityCreateManyArgs>(args?: SelectSubset<T, SlotAvailabilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SlotAvailabilities and returns the data saved in the database.
     * @param {SlotAvailabilityCreateManyAndReturnArgs} args - Arguments to create many SlotAvailabilities.
     * @example
     * // Create many SlotAvailabilities
     * const slotAvailability = await prisma.slotAvailability.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SlotAvailabilities and only return the `id`
     * const slotAvailabilityWithIdOnly = await prisma.slotAvailability.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SlotAvailabilityCreateManyAndReturnArgs>(args?: SelectSubset<T, SlotAvailabilityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SlotAvailabilityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SlotAvailability.
     * @param {SlotAvailabilityDeleteArgs} args - Arguments to delete one SlotAvailability.
     * @example
     * // Delete one SlotAvailability
     * const SlotAvailability = await prisma.slotAvailability.delete({
     *   where: {
     *     // ... filter to delete one SlotAvailability
     *   }
     * })
     * 
     */
    delete<T extends SlotAvailabilityDeleteArgs>(args: SelectSubset<T, SlotAvailabilityDeleteArgs<ExtArgs>>): Prisma__SlotAvailabilityClient<$Result.GetResult<Prisma.$SlotAvailabilityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SlotAvailability.
     * @param {SlotAvailabilityUpdateArgs} args - Arguments to update one SlotAvailability.
     * @example
     * // Update one SlotAvailability
     * const slotAvailability = await prisma.slotAvailability.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SlotAvailabilityUpdateArgs>(args: SelectSubset<T, SlotAvailabilityUpdateArgs<ExtArgs>>): Prisma__SlotAvailabilityClient<$Result.GetResult<Prisma.$SlotAvailabilityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SlotAvailabilities.
     * @param {SlotAvailabilityDeleteManyArgs} args - Arguments to filter SlotAvailabilities to delete.
     * @example
     * // Delete a few SlotAvailabilities
     * const { count } = await prisma.slotAvailability.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SlotAvailabilityDeleteManyArgs>(args?: SelectSubset<T, SlotAvailabilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SlotAvailabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlotAvailabilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SlotAvailabilities
     * const slotAvailability = await prisma.slotAvailability.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SlotAvailabilityUpdateManyArgs>(args: SelectSubset<T, SlotAvailabilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SlotAvailabilities and returns the data updated in the database.
     * @param {SlotAvailabilityUpdateManyAndReturnArgs} args - Arguments to update many SlotAvailabilities.
     * @example
     * // Update many SlotAvailabilities
     * const slotAvailability = await prisma.slotAvailability.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SlotAvailabilities and only return the `id`
     * const slotAvailabilityWithIdOnly = await prisma.slotAvailability.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SlotAvailabilityUpdateManyAndReturnArgs>(args: SelectSubset<T, SlotAvailabilityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SlotAvailabilityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SlotAvailability.
     * @param {SlotAvailabilityUpsertArgs} args - Arguments to update or create a SlotAvailability.
     * @example
     * // Update or create a SlotAvailability
     * const slotAvailability = await prisma.slotAvailability.upsert({
     *   create: {
     *     // ... data to create a SlotAvailability
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SlotAvailability we want to update
     *   }
     * })
     */
    upsert<T extends SlotAvailabilityUpsertArgs>(args: SelectSubset<T, SlotAvailabilityUpsertArgs<ExtArgs>>): Prisma__SlotAvailabilityClient<$Result.GetResult<Prisma.$SlotAvailabilityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SlotAvailabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlotAvailabilityCountArgs} args - Arguments to filter SlotAvailabilities to count.
     * @example
     * // Count the number of SlotAvailabilities
     * const count = await prisma.slotAvailability.count({
     *   where: {
     *     // ... the filter for the SlotAvailabilities we want to count
     *   }
     * })
    **/
    count<T extends SlotAvailabilityCountArgs>(
      args?: Subset<T, SlotAvailabilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SlotAvailabilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SlotAvailability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlotAvailabilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SlotAvailabilityAggregateArgs>(args: Subset<T, SlotAvailabilityAggregateArgs>): Prisma.PrismaPromise<GetSlotAvailabilityAggregateType<T>>

    /**
     * Group by SlotAvailability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlotAvailabilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SlotAvailabilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SlotAvailabilityGroupByArgs['orderBy'] }
        : { orderBy?: SlotAvailabilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SlotAvailabilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSlotAvailabilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SlotAvailability model
   */
  readonly fields: SlotAvailabilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SlotAvailability.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SlotAvailabilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parkingSlot<T extends ParkingSlotDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParkingSlotDefaultArgs<ExtArgs>>): Prisma__ParkingSlotClient<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SlotAvailability model
   */
  interface SlotAvailabilityFieldRefs {
    readonly id: FieldRef<"SlotAvailability", 'Int'>
    readonly slotId: FieldRef<"SlotAvailability", 'Int'>
    readonly availableFrom: FieldRef<"SlotAvailability", 'DateTime'>
    readonly availableUntil: FieldRef<"SlotAvailability", 'DateTime'>
    readonly isBookable: FieldRef<"SlotAvailability", 'Boolean'>
    readonly statusReason: FieldRef<"SlotAvailability", 'String'>
    readonly createdAt: FieldRef<"SlotAvailability", 'DateTime'>
    readonly updatedAt: FieldRef<"SlotAvailability", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SlotAvailability findUnique
   */
  export type SlotAvailabilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlotAvailability
     */
    select?: SlotAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlotAvailability
     */
    omit?: SlotAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotAvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which SlotAvailability to fetch.
     */
    where: SlotAvailabilityWhereUniqueInput
  }

  /**
   * SlotAvailability findUniqueOrThrow
   */
  export type SlotAvailabilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlotAvailability
     */
    select?: SlotAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlotAvailability
     */
    omit?: SlotAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotAvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which SlotAvailability to fetch.
     */
    where: SlotAvailabilityWhereUniqueInput
  }

  /**
   * SlotAvailability findFirst
   */
  export type SlotAvailabilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlotAvailability
     */
    select?: SlotAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlotAvailability
     */
    omit?: SlotAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotAvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which SlotAvailability to fetch.
     */
    where?: SlotAvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SlotAvailabilities to fetch.
     */
    orderBy?: SlotAvailabilityOrderByWithRelationInput | SlotAvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SlotAvailabilities.
     */
    cursor?: SlotAvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SlotAvailabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SlotAvailabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SlotAvailabilities.
     */
    distinct?: SlotAvailabilityScalarFieldEnum | SlotAvailabilityScalarFieldEnum[]
  }

  /**
   * SlotAvailability findFirstOrThrow
   */
  export type SlotAvailabilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlotAvailability
     */
    select?: SlotAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlotAvailability
     */
    omit?: SlotAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotAvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which SlotAvailability to fetch.
     */
    where?: SlotAvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SlotAvailabilities to fetch.
     */
    orderBy?: SlotAvailabilityOrderByWithRelationInput | SlotAvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SlotAvailabilities.
     */
    cursor?: SlotAvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SlotAvailabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SlotAvailabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SlotAvailabilities.
     */
    distinct?: SlotAvailabilityScalarFieldEnum | SlotAvailabilityScalarFieldEnum[]
  }

  /**
   * SlotAvailability findMany
   */
  export type SlotAvailabilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlotAvailability
     */
    select?: SlotAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlotAvailability
     */
    omit?: SlotAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotAvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which SlotAvailabilities to fetch.
     */
    where?: SlotAvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SlotAvailabilities to fetch.
     */
    orderBy?: SlotAvailabilityOrderByWithRelationInput | SlotAvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SlotAvailabilities.
     */
    cursor?: SlotAvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SlotAvailabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SlotAvailabilities.
     */
    skip?: number
    distinct?: SlotAvailabilityScalarFieldEnum | SlotAvailabilityScalarFieldEnum[]
  }

  /**
   * SlotAvailability create
   */
  export type SlotAvailabilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlotAvailability
     */
    select?: SlotAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlotAvailability
     */
    omit?: SlotAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotAvailabilityInclude<ExtArgs> | null
    /**
     * The data needed to create a SlotAvailability.
     */
    data: XOR<SlotAvailabilityCreateInput, SlotAvailabilityUncheckedCreateInput>
  }

  /**
   * SlotAvailability createMany
   */
  export type SlotAvailabilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SlotAvailabilities.
     */
    data: SlotAvailabilityCreateManyInput | SlotAvailabilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SlotAvailability createManyAndReturn
   */
  export type SlotAvailabilityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlotAvailability
     */
    select?: SlotAvailabilitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SlotAvailability
     */
    omit?: SlotAvailabilityOmit<ExtArgs> | null
    /**
     * The data used to create many SlotAvailabilities.
     */
    data: SlotAvailabilityCreateManyInput | SlotAvailabilityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotAvailabilityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SlotAvailability update
   */
  export type SlotAvailabilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlotAvailability
     */
    select?: SlotAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlotAvailability
     */
    omit?: SlotAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotAvailabilityInclude<ExtArgs> | null
    /**
     * The data needed to update a SlotAvailability.
     */
    data: XOR<SlotAvailabilityUpdateInput, SlotAvailabilityUncheckedUpdateInput>
    /**
     * Choose, which SlotAvailability to update.
     */
    where: SlotAvailabilityWhereUniqueInput
  }

  /**
   * SlotAvailability updateMany
   */
  export type SlotAvailabilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SlotAvailabilities.
     */
    data: XOR<SlotAvailabilityUpdateManyMutationInput, SlotAvailabilityUncheckedUpdateManyInput>
    /**
     * Filter which SlotAvailabilities to update
     */
    where?: SlotAvailabilityWhereInput
    /**
     * Limit how many SlotAvailabilities to update.
     */
    limit?: number
  }

  /**
   * SlotAvailability updateManyAndReturn
   */
  export type SlotAvailabilityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlotAvailability
     */
    select?: SlotAvailabilitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SlotAvailability
     */
    omit?: SlotAvailabilityOmit<ExtArgs> | null
    /**
     * The data used to update SlotAvailabilities.
     */
    data: XOR<SlotAvailabilityUpdateManyMutationInput, SlotAvailabilityUncheckedUpdateManyInput>
    /**
     * Filter which SlotAvailabilities to update
     */
    where?: SlotAvailabilityWhereInput
    /**
     * Limit how many SlotAvailabilities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotAvailabilityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SlotAvailability upsert
   */
  export type SlotAvailabilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlotAvailability
     */
    select?: SlotAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlotAvailability
     */
    omit?: SlotAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotAvailabilityInclude<ExtArgs> | null
    /**
     * The filter to search for the SlotAvailability to update in case it exists.
     */
    where: SlotAvailabilityWhereUniqueInput
    /**
     * In case the SlotAvailability found by the `where` argument doesn't exist, create a new SlotAvailability with this data.
     */
    create: XOR<SlotAvailabilityCreateInput, SlotAvailabilityUncheckedCreateInput>
    /**
     * In case the SlotAvailability was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SlotAvailabilityUpdateInput, SlotAvailabilityUncheckedUpdateInput>
  }

  /**
   * SlotAvailability delete
   */
  export type SlotAvailabilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlotAvailability
     */
    select?: SlotAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlotAvailability
     */
    omit?: SlotAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotAvailabilityInclude<ExtArgs> | null
    /**
     * Filter which SlotAvailability to delete.
     */
    where: SlotAvailabilityWhereUniqueInput
  }

  /**
   * SlotAvailability deleteMany
   */
  export type SlotAvailabilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SlotAvailabilities to delete
     */
    where?: SlotAvailabilityWhereInput
    /**
     * Limit how many SlotAvailabilities to delete.
     */
    limit?: number
  }

  /**
   * SlotAvailability without action
   */
  export type SlotAvailabilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlotAvailability
     */
    select?: SlotAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlotAvailability
     */
    omit?: SlotAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotAvailabilityInclude<ExtArgs> | null
  }


  /**
   * Model TariffPlan
   */

  export type AggregateTariffPlan = {
    _count: TariffPlanCountAggregateOutputType | null
    _avg: TariffPlanAvgAggregateOutputType | null
    _sum: TariffPlanSumAggregateOutputType | null
    _min: TariffPlanMinAggregateOutputType | null
    _max: TariffPlanMaxAggregateOutputType | null
  }

  export type TariffPlanAvgAggregateOutputType = {
    id: number | null
    placeId: number | null
  }

  export type TariffPlanSumAggregateOutputType = {
    id: number | null
    placeId: number | null
  }

  export type TariffPlanMinAggregateOutputType = {
    id: number | null
    placeId: number | null
    planName: string | null
    description: string | null
    effectiveFrom: Date | null
    effectiveUntil: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TariffPlanMaxAggregateOutputType = {
    id: number | null
    placeId: number | null
    planName: string | null
    description: string | null
    effectiveFrom: Date | null
    effectiveUntil: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TariffPlanCountAggregateOutputType = {
    id: number
    placeId: number
    planName: number
    description: number
    effectiveFrom: number
    effectiveUntil: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TariffPlanAvgAggregateInputType = {
    id?: true
    placeId?: true
  }

  export type TariffPlanSumAggregateInputType = {
    id?: true
    placeId?: true
  }

  export type TariffPlanMinAggregateInputType = {
    id?: true
    placeId?: true
    planName?: true
    description?: true
    effectiveFrom?: true
    effectiveUntil?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TariffPlanMaxAggregateInputType = {
    id?: true
    placeId?: true
    planName?: true
    description?: true
    effectiveFrom?: true
    effectiveUntil?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TariffPlanCountAggregateInputType = {
    id?: true
    placeId?: true
    planName?: true
    description?: true
    effectiveFrom?: true
    effectiveUntil?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TariffPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TariffPlan to aggregate.
     */
    where?: TariffPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TariffPlans to fetch.
     */
    orderBy?: TariffPlanOrderByWithRelationInput | TariffPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TariffPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TariffPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TariffPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TariffPlans
    **/
    _count?: true | TariffPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TariffPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TariffPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TariffPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TariffPlanMaxAggregateInputType
  }

  export type GetTariffPlanAggregateType<T extends TariffPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateTariffPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTariffPlan[P]>
      : GetScalarType<T[P], AggregateTariffPlan[P]>
  }




  export type TariffPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TariffPlanWhereInput
    orderBy?: TariffPlanOrderByWithAggregationInput | TariffPlanOrderByWithAggregationInput[]
    by: TariffPlanScalarFieldEnum[] | TariffPlanScalarFieldEnum
    having?: TariffPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TariffPlanCountAggregateInputType | true
    _avg?: TariffPlanAvgAggregateInputType
    _sum?: TariffPlanSumAggregateInputType
    _min?: TariffPlanMinAggregateInputType
    _max?: TariffPlanMaxAggregateInputType
  }

  export type TariffPlanGroupByOutputType = {
    id: number
    placeId: number
    planName: string
    description: string | null
    effectiveFrom: Date
    effectiveUntil: Date | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date | null
    _count: TariffPlanCountAggregateOutputType | null
    _avg: TariffPlanAvgAggregateOutputType | null
    _sum: TariffPlanSumAggregateOutputType | null
    _min: TariffPlanMinAggregateOutputType | null
    _max: TariffPlanMaxAggregateOutputType | null
  }

  type GetTariffPlanGroupByPayload<T extends TariffPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TariffPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TariffPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TariffPlanGroupByOutputType[P]>
            : GetScalarType<T[P], TariffPlanGroupByOutputType[P]>
        }
      >
    >


  export type TariffPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    placeId?: boolean
    planName?: boolean
    description?: boolean
    effectiveFrom?: boolean
    effectiveUntil?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    place?: boolean | PlaceDefaultArgs<ExtArgs>
    tariffRates?: boolean | TariffPlan$tariffRatesArgs<ExtArgs>
    _count?: boolean | TariffPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tariffPlan"]>

  export type TariffPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    placeId?: boolean
    planName?: boolean
    description?: boolean
    effectiveFrom?: boolean
    effectiveUntil?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tariffPlan"]>

  export type TariffPlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    placeId?: boolean
    planName?: boolean
    description?: boolean
    effectiveFrom?: boolean
    effectiveUntil?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tariffPlan"]>

  export type TariffPlanSelectScalar = {
    id?: boolean
    placeId?: boolean
    planName?: boolean
    description?: boolean
    effectiveFrom?: boolean
    effectiveUntil?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TariffPlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "placeId" | "planName" | "description" | "effectiveFrom" | "effectiveUntil" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["tariffPlan"]>
  export type TariffPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    place?: boolean | PlaceDefaultArgs<ExtArgs>
    tariffRates?: boolean | TariffPlan$tariffRatesArgs<ExtArgs>
    _count?: boolean | TariffPlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TariffPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }
  export type TariffPlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }

  export type $TariffPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TariffPlan"
    objects: {
      place: Prisma.$PlacePayload<ExtArgs>
      tariffRates: Prisma.$TariffRatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      placeId: number
      planName: string
      description: string | null
      effectiveFrom: Date
      effectiveUntil: Date | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["tariffPlan"]>
    composites: {}
  }

  type TariffPlanGetPayload<S extends boolean | null | undefined | TariffPlanDefaultArgs> = $Result.GetResult<Prisma.$TariffPlanPayload, S>

  type TariffPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TariffPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TariffPlanCountAggregateInputType | true
    }

  export interface TariffPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TariffPlan'], meta: { name: 'TariffPlan' } }
    /**
     * Find zero or one TariffPlan that matches the filter.
     * @param {TariffPlanFindUniqueArgs} args - Arguments to find a TariffPlan
     * @example
     * // Get one TariffPlan
     * const tariffPlan = await prisma.tariffPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TariffPlanFindUniqueArgs>(args: SelectSubset<T, TariffPlanFindUniqueArgs<ExtArgs>>): Prisma__TariffPlanClient<$Result.GetResult<Prisma.$TariffPlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TariffPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TariffPlanFindUniqueOrThrowArgs} args - Arguments to find a TariffPlan
     * @example
     * // Get one TariffPlan
     * const tariffPlan = await prisma.tariffPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TariffPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, TariffPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TariffPlanClient<$Result.GetResult<Prisma.$TariffPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TariffPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffPlanFindFirstArgs} args - Arguments to find a TariffPlan
     * @example
     * // Get one TariffPlan
     * const tariffPlan = await prisma.tariffPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TariffPlanFindFirstArgs>(args?: SelectSubset<T, TariffPlanFindFirstArgs<ExtArgs>>): Prisma__TariffPlanClient<$Result.GetResult<Prisma.$TariffPlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TariffPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffPlanFindFirstOrThrowArgs} args - Arguments to find a TariffPlan
     * @example
     * // Get one TariffPlan
     * const tariffPlan = await prisma.tariffPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TariffPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, TariffPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__TariffPlanClient<$Result.GetResult<Prisma.$TariffPlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TariffPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TariffPlans
     * const tariffPlans = await prisma.tariffPlan.findMany()
     * 
     * // Get first 10 TariffPlans
     * const tariffPlans = await prisma.tariffPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tariffPlanWithIdOnly = await prisma.tariffPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TariffPlanFindManyArgs>(args?: SelectSubset<T, TariffPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TariffPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TariffPlan.
     * @param {TariffPlanCreateArgs} args - Arguments to create a TariffPlan.
     * @example
     * // Create one TariffPlan
     * const TariffPlan = await prisma.tariffPlan.create({
     *   data: {
     *     // ... data to create a TariffPlan
     *   }
     * })
     * 
     */
    create<T extends TariffPlanCreateArgs>(args: SelectSubset<T, TariffPlanCreateArgs<ExtArgs>>): Prisma__TariffPlanClient<$Result.GetResult<Prisma.$TariffPlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TariffPlans.
     * @param {TariffPlanCreateManyArgs} args - Arguments to create many TariffPlans.
     * @example
     * // Create many TariffPlans
     * const tariffPlan = await prisma.tariffPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TariffPlanCreateManyArgs>(args?: SelectSubset<T, TariffPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TariffPlans and returns the data saved in the database.
     * @param {TariffPlanCreateManyAndReturnArgs} args - Arguments to create many TariffPlans.
     * @example
     * // Create many TariffPlans
     * const tariffPlan = await prisma.tariffPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TariffPlans and only return the `id`
     * const tariffPlanWithIdOnly = await prisma.tariffPlan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TariffPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, TariffPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TariffPlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TariffPlan.
     * @param {TariffPlanDeleteArgs} args - Arguments to delete one TariffPlan.
     * @example
     * // Delete one TariffPlan
     * const TariffPlan = await prisma.tariffPlan.delete({
     *   where: {
     *     // ... filter to delete one TariffPlan
     *   }
     * })
     * 
     */
    delete<T extends TariffPlanDeleteArgs>(args: SelectSubset<T, TariffPlanDeleteArgs<ExtArgs>>): Prisma__TariffPlanClient<$Result.GetResult<Prisma.$TariffPlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TariffPlan.
     * @param {TariffPlanUpdateArgs} args - Arguments to update one TariffPlan.
     * @example
     * // Update one TariffPlan
     * const tariffPlan = await prisma.tariffPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TariffPlanUpdateArgs>(args: SelectSubset<T, TariffPlanUpdateArgs<ExtArgs>>): Prisma__TariffPlanClient<$Result.GetResult<Prisma.$TariffPlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TariffPlans.
     * @param {TariffPlanDeleteManyArgs} args - Arguments to filter TariffPlans to delete.
     * @example
     * // Delete a few TariffPlans
     * const { count } = await prisma.tariffPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TariffPlanDeleteManyArgs>(args?: SelectSubset<T, TariffPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TariffPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TariffPlans
     * const tariffPlan = await prisma.tariffPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TariffPlanUpdateManyArgs>(args: SelectSubset<T, TariffPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TariffPlans and returns the data updated in the database.
     * @param {TariffPlanUpdateManyAndReturnArgs} args - Arguments to update many TariffPlans.
     * @example
     * // Update many TariffPlans
     * const tariffPlan = await prisma.tariffPlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TariffPlans and only return the `id`
     * const tariffPlanWithIdOnly = await prisma.tariffPlan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TariffPlanUpdateManyAndReturnArgs>(args: SelectSubset<T, TariffPlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TariffPlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TariffPlan.
     * @param {TariffPlanUpsertArgs} args - Arguments to update or create a TariffPlan.
     * @example
     * // Update or create a TariffPlan
     * const tariffPlan = await prisma.tariffPlan.upsert({
     *   create: {
     *     // ... data to create a TariffPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TariffPlan we want to update
     *   }
     * })
     */
    upsert<T extends TariffPlanUpsertArgs>(args: SelectSubset<T, TariffPlanUpsertArgs<ExtArgs>>): Prisma__TariffPlanClient<$Result.GetResult<Prisma.$TariffPlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TariffPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffPlanCountArgs} args - Arguments to filter TariffPlans to count.
     * @example
     * // Count the number of TariffPlans
     * const count = await prisma.tariffPlan.count({
     *   where: {
     *     // ... the filter for the TariffPlans we want to count
     *   }
     * })
    **/
    count<T extends TariffPlanCountArgs>(
      args?: Subset<T, TariffPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TariffPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TariffPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TariffPlanAggregateArgs>(args: Subset<T, TariffPlanAggregateArgs>): Prisma.PrismaPromise<GetTariffPlanAggregateType<T>>

    /**
     * Group by TariffPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TariffPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TariffPlanGroupByArgs['orderBy'] }
        : { orderBy?: TariffPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TariffPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTariffPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TariffPlan model
   */
  readonly fields: TariffPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TariffPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TariffPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    place<T extends PlaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlaceDefaultArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tariffRates<T extends TariffPlan$tariffRatesArgs<ExtArgs> = {}>(args?: Subset<T, TariffPlan$tariffRatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TariffRatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TariffPlan model
   */
  interface TariffPlanFieldRefs {
    readonly id: FieldRef<"TariffPlan", 'Int'>
    readonly placeId: FieldRef<"TariffPlan", 'Int'>
    readonly planName: FieldRef<"TariffPlan", 'String'>
    readonly description: FieldRef<"TariffPlan", 'String'>
    readonly effectiveFrom: FieldRef<"TariffPlan", 'DateTime'>
    readonly effectiveUntil: FieldRef<"TariffPlan", 'DateTime'>
    readonly isActive: FieldRef<"TariffPlan", 'Boolean'>
    readonly createdAt: FieldRef<"TariffPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"TariffPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TariffPlan findUnique
   */
  export type TariffPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffPlan
     */
    select?: TariffPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TariffPlan
     */
    omit?: TariffPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffPlanInclude<ExtArgs> | null
    /**
     * Filter, which TariffPlan to fetch.
     */
    where: TariffPlanWhereUniqueInput
  }

  /**
   * TariffPlan findUniqueOrThrow
   */
  export type TariffPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffPlan
     */
    select?: TariffPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TariffPlan
     */
    omit?: TariffPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffPlanInclude<ExtArgs> | null
    /**
     * Filter, which TariffPlan to fetch.
     */
    where: TariffPlanWhereUniqueInput
  }

  /**
   * TariffPlan findFirst
   */
  export type TariffPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffPlan
     */
    select?: TariffPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TariffPlan
     */
    omit?: TariffPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffPlanInclude<ExtArgs> | null
    /**
     * Filter, which TariffPlan to fetch.
     */
    where?: TariffPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TariffPlans to fetch.
     */
    orderBy?: TariffPlanOrderByWithRelationInput | TariffPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TariffPlans.
     */
    cursor?: TariffPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TariffPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TariffPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TariffPlans.
     */
    distinct?: TariffPlanScalarFieldEnum | TariffPlanScalarFieldEnum[]
  }

  /**
   * TariffPlan findFirstOrThrow
   */
  export type TariffPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffPlan
     */
    select?: TariffPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TariffPlan
     */
    omit?: TariffPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffPlanInclude<ExtArgs> | null
    /**
     * Filter, which TariffPlan to fetch.
     */
    where?: TariffPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TariffPlans to fetch.
     */
    orderBy?: TariffPlanOrderByWithRelationInput | TariffPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TariffPlans.
     */
    cursor?: TariffPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TariffPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TariffPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TariffPlans.
     */
    distinct?: TariffPlanScalarFieldEnum | TariffPlanScalarFieldEnum[]
  }

  /**
   * TariffPlan findMany
   */
  export type TariffPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffPlan
     */
    select?: TariffPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TariffPlan
     */
    omit?: TariffPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffPlanInclude<ExtArgs> | null
    /**
     * Filter, which TariffPlans to fetch.
     */
    where?: TariffPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TariffPlans to fetch.
     */
    orderBy?: TariffPlanOrderByWithRelationInput | TariffPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TariffPlans.
     */
    cursor?: TariffPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TariffPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TariffPlans.
     */
    skip?: number
    distinct?: TariffPlanScalarFieldEnum | TariffPlanScalarFieldEnum[]
  }

  /**
   * TariffPlan create
   */
  export type TariffPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffPlan
     */
    select?: TariffPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TariffPlan
     */
    omit?: TariffPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a TariffPlan.
     */
    data: XOR<TariffPlanCreateInput, TariffPlanUncheckedCreateInput>
  }

  /**
   * TariffPlan createMany
   */
  export type TariffPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TariffPlans.
     */
    data: TariffPlanCreateManyInput | TariffPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TariffPlan createManyAndReturn
   */
  export type TariffPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffPlan
     */
    select?: TariffPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TariffPlan
     */
    omit?: TariffPlanOmit<ExtArgs> | null
    /**
     * The data used to create many TariffPlans.
     */
    data: TariffPlanCreateManyInput | TariffPlanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TariffPlan update
   */
  export type TariffPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffPlan
     */
    select?: TariffPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TariffPlan
     */
    omit?: TariffPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a TariffPlan.
     */
    data: XOR<TariffPlanUpdateInput, TariffPlanUncheckedUpdateInput>
    /**
     * Choose, which TariffPlan to update.
     */
    where: TariffPlanWhereUniqueInput
  }

  /**
   * TariffPlan updateMany
   */
  export type TariffPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TariffPlans.
     */
    data: XOR<TariffPlanUpdateManyMutationInput, TariffPlanUncheckedUpdateManyInput>
    /**
     * Filter which TariffPlans to update
     */
    where?: TariffPlanWhereInput
    /**
     * Limit how many TariffPlans to update.
     */
    limit?: number
  }

  /**
   * TariffPlan updateManyAndReturn
   */
  export type TariffPlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffPlan
     */
    select?: TariffPlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TariffPlan
     */
    omit?: TariffPlanOmit<ExtArgs> | null
    /**
     * The data used to update TariffPlans.
     */
    data: XOR<TariffPlanUpdateManyMutationInput, TariffPlanUncheckedUpdateManyInput>
    /**
     * Filter which TariffPlans to update
     */
    where?: TariffPlanWhereInput
    /**
     * Limit how many TariffPlans to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffPlanIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TariffPlan upsert
   */
  export type TariffPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffPlan
     */
    select?: TariffPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TariffPlan
     */
    omit?: TariffPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the TariffPlan to update in case it exists.
     */
    where: TariffPlanWhereUniqueInput
    /**
     * In case the TariffPlan found by the `where` argument doesn't exist, create a new TariffPlan with this data.
     */
    create: XOR<TariffPlanCreateInput, TariffPlanUncheckedCreateInput>
    /**
     * In case the TariffPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TariffPlanUpdateInput, TariffPlanUncheckedUpdateInput>
  }

  /**
   * TariffPlan delete
   */
  export type TariffPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffPlan
     */
    select?: TariffPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TariffPlan
     */
    omit?: TariffPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffPlanInclude<ExtArgs> | null
    /**
     * Filter which TariffPlan to delete.
     */
    where: TariffPlanWhereUniqueInput
  }

  /**
   * TariffPlan deleteMany
   */
  export type TariffPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TariffPlans to delete
     */
    where?: TariffPlanWhereInput
    /**
     * Limit how many TariffPlans to delete.
     */
    limit?: number
  }

  /**
   * TariffPlan.tariffRates
   */
  export type TariffPlan$tariffRatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffRate
     */
    select?: TariffRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TariffRate
     */
    omit?: TariffRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffRateInclude<ExtArgs> | null
    where?: TariffRateWhereInput
    orderBy?: TariffRateOrderByWithRelationInput | TariffRateOrderByWithRelationInput[]
    cursor?: TariffRateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TariffRateScalarFieldEnum | TariffRateScalarFieldEnum[]
  }

  /**
   * TariffPlan without action
   */
  export type TariffPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffPlan
     */
    select?: TariffPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TariffPlan
     */
    omit?: TariffPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffPlanInclude<ExtArgs> | null
  }


  /**
   * Model TariffRate
   */

  export type AggregateTariffRate = {
    _count: TariffRateCountAggregateOutputType | null
    _avg: TariffRateAvgAggregateOutputType | null
    _sum: TariffRateSumAggregateOutputType | null
    _min: TariffRateMinAggregateOutputType | null
    _max: TariffRateMaxAggregateOutputType | null
  }

  export type TariffRateAvgAggregateOutputType = {
    id: number | null
    planId: number | null
    basePrice: Decimal | null
    hourlyRate: Decimal | null
    dayRate: Decimal | null
    minimumCharge: Decimal | null
    gracePeriodMinutes: number | null
  }

  export type TariffRateSumAggregateOutputType = {
    id: number | null
    planId: number | null
    basePrice: Decimal | null
    hourlyRate: Decimal | null
    dayRate: Decimal | null
    minimumCharge: Decimal | null
    gracePeriodMinutes: number | null
  }

  export type TariffRateMinAggregateOutputType = {
    id: number | null
    planId: number | null
    vehicleType: string | null
    slotType: string | null
    startTime: Date | null
    endTime: Date | null
    dayCategory: string | null
    basePrice: Decimal | null
    hourlyRate: Decimal | null
    dayRate: Decimal | null
    minimumCharge: Decimal | null
    gracePeriodMinutes: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TariffRateMaxAggregateOutputType = {
    id: number | null
    planId: number | null
    vehicleType: string | null
    slotType: string | null
    startTime: Date | null
    endTime: Date | null
    dayCategory: string | null
    basePrice: Decimal | null
    hourlyRate: Decimal | null
    dayRate: Decimal | null
    minimumCharge: Decimal | null
    gracePeriodMinutes: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TariffRateCountAggregateOutputType = {
    id: number
    planId: number
    vehicleType: number
    slotType: number
    startTime: number
    endTime: number
    dayCategory: number
    basePrice: number
    hourlyRate: number
    dayRate: number
    minimumCharge: number
    gracePeriodMinutes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TariffRateAvgAggregateInputType = {
    id?: true
    planId?: true
    basePrice?: true
    hourlyRate?: true
    dayRate?: true
    minimumCharge?: true
    gracePeriodMinutes?: true
  }

  export type TariffRateSumAggregateInputType = {
    id?: true
    planId?: true
    basePrice?: true
    hourlyRate?: true
    dayRate?: true
    minimumCharge?: true
    gracePeriodMinutes?: true
  }

  export type TariffRateMinAggregateInputType = {
    id?: true
    planId?: true
    vehicleType?: true
    slotType?: true
    startTime?: true
    endTime?: true
    dayCategory?: true
    basePrice?: true
    hourlyRate?: true
    dayRate?: true
    minimumCharge?: true
    gracePeriodMinutes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TariffRateMaxAggregateInputType = {
    id?: true
    planId?: true
    vehicleType?: true
    slotType?: true
    startTime?: true
    endTime?: true
    dayCategory?: true
    basePrice?: true
    hourlyRate?: true
    dayRate?: true
    minimumCharge?: true
    gracePeriodMinutes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TariffRateCountAggregateInputType = {
    id?: true
    planId?: true
    vehicleType?: true
    slotType?: true
    startTime?: true
    endTime?: true
    dayCategory?: true
    basePrice?: true
    hourlyRate?: true
    dayRate?: true
    minimumCharge?: true
    gracePeriodMinutes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TariffRateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TariffRate to aggregate.
     */
    where?: TariffRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TariffRates to fetch.
     */
    orderBy?: TariffRateOrderByWithRelationInput | TariffRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TariffRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TariffRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TariffRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TariffRates
    **/
    _count?: true | TariffRateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TariffRateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TariffRateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TariffRateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TariffRateMaxAggregateInputType
  }

  export type GetTariffRateAggregateType<T extends TariffRateAggregateArgs> = {
        [P in keyof T & keyof AggregateTariffRate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTariffRate[P]>
      : GetScalarType<T[P], AggregateTariffRate[P]>
  }




  export type TariffRateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TariffRateWhereInput
    orderBy?: TariffRateOrderByWithAggregationInput | TariffRateOrderByWithAggregationInput[]
    by: TariffRateScalarFieldEnum[] | TariffRateScalarFieldEnum
    having?: TariffRateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TariffRateCountAggregateInputType | true
    _avg?: TariffRateAvgAggregateInputType
    _sum?: TariffRateSumAggregateInputType
    _min?: TariffRateMinAggregateInputType
    _max?: TariffRateMaxAggregateInputType
  }

  export type TariffRateGroupByOutputType = {
    id: number
    planId: number
    vehicleType: string
    slotType: string
    startTime: Date | null
    endTime: Date | null
    dayCategory: string | null
    basePrice: Decimal
    hourlyRate: Decimal
    dayRate: Decimal | null
    minimumCharge: Decimal
    gracePeriodMinutes: number
    createdAt: Date
    updatedAt: Date | null
    _count: TariffRateCountAggregateOutputType | null
    _avg: TariffRateAvgAggregateOutputType | null
    _sum: TariffRateSumAggregateOutputType | null
    _min: TariffRateMinAggregateOutputType | null
    _max: TariffRateMaxAggregateOutputType | null
  }

  type GetTariffRateGroupByPayload<T extends TariffRateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TariffRateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TariffRateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TariffRateGroupByOutputType[P]>
            : GetScalarType<T[P], TariffRateGroupByOutputType[P]>
        }
      >
    >


  export type TariffRateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    vehicleType?: boolean
    slotType?: boolean
    startTime?: boolean
    endTime?: boolean
    dayCategory?: boolean
    basePrice?: boolean
    hourlyRate?: boolean
    dayRate?: boolean
    minimumCharge?: boolean
    gracePeriodMinutes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tariffPlan?: boolean | TariffPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tariffRate"]>

  export type TariffRateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    vehicleType?: boolean
    slotType?: boolean
    startTime?: boolean
    endTime?: boolean
    dayCategory?: boolean
    basePrice?: boolean
    hourlyRate?: boolean
    dayRate?: boolean
    minimumCharge?: boolean
    gracePeriodMinutes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tariffPlan?: boolean | TariffPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tariffRate"]>

  export type TariffRateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    vehicleType?: boolean
    slotType?: boolean
    startTime?: boolean
    endTime?: boolean
    dayCategory?: boolean
    basePrice?: boolean
    hourlyRate?: boolean
    dayRate?: boolean
    minimumCharge?: boolean
    gracePeriodMinutes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tariffPlan?: boolean | TariffPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tariffRate"]>

  export type TariffRateSelectScalar = {
    id?: boolean
    planId?: boolean
    vehicleType?: boolean
    slotType?: boolean
    startTime?: boolean
    endTime?: boolean
    dayCategory?: boolean
    basePrice?: boolean
    hourlyRate?: boolean
    dayRate?: boolean
    minimumCharge?: boolean
    gracePeriodMinutes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TariffRateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "planId" | "vehicleType" | "slotType" | "startTime" | "endTime" | "dayCategory" | "basePrice" | "hourlyRate" | "dayRate" | "minimumCharge" | "gracePeriodMinutes" | "createdAt" | "updatedAt", ExtArgs["result"]["tariffRate"]>
  export type TariffRateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tariffPlan?: boolean | TariffPlanDefaultArgs<ExtArgs>
  }
  export type TariffRateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tariffPlan?: boolean | TariffPlanDefaultArgs<ExtArgs>
  }
  export type TariffRateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tariffPlan?: boolean | TariffPlanDefaultArgs<ExtArgs>
  }

  export type $TariffRatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TariffRate"
    objects: {
      tariffPlan: Prisma.$TariffPlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      planId: number
      vehicleType: string
      slotType: string
      startTime: Date | null
      endTime: Date | null
      dayCategory: string | null
      basePrice: Prisma.Decimal
      hourlyRate: Prisma.Decimal
      dayRate: Prisma.Decimal | null
      minimumCharge: Prisma.Decimal
      gracePeriodMinutes: number
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["tariffRate"]>
    composites: {}
  }

  type TariffRateGetPayload<S extends boolean | null | undefined | TariffRateDefaultArgs> = $Result.GetResult<Prisma.$TariffRatePayload, S>

  type TariffRateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TariffRateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TariffRateCountAggregateInputType | true
    }

  export interface TariffRateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TariffRate'], meta: { name: 'TariffRate' } }
    /**
     * Find zero or one TariffRate that matches the filter.
     * @param {TariffRateFindUniqueArgs} args - Arguments to find a TariffRate
     * @example
     * // Get one TariffRate
     * const tariffRate = await prisma.tariffRate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TariffRateFindUniqueArgs>(args: SelectSubset<T, TariffRateFindUniqueArgs<ExtArgs>>): Prisma__TariffRateClient<$Result.GetResult<Prisma.$TariffRatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TariffRate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TariffRateFindUniqueOrThrowArgs} args - Arguments to find a TariffRate
     * @example
     * // Get one TariffRate
     * const tariffRate = await prisma.tariffRate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TariffRateFindUniqueOrThrowArgs>(args: SelectSubset<T, TariffRateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TariffRateClient<$Result.GetResult<Prisma.$TariffRatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TariffRate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffRateFindFirstArgs} args - Arguments to find a TariffRate
     * @example
     * // Get one TariffRate
     * const tariffRate = await prisma.tariffRate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TariffRateFindFirstArgs>(args?: SelectSubset<T, TariffRateFindFirstArgs<ExtArgs>>): Prisma__TariffRateClient<$Result.GetResult<Prisma.$TariffRatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TariffRate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffRateFindFirstOrThrowArgs} args - Arguments to find a TariffRate
     * @example
     * // Get one TariffRate
     * const tariffRate = await prisma.tariffRate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TariffRateFindFirstOrThrowArgs>(args?: SelectSubset<T, TariffRateFindFirstOrThrowArgs<ExtArgs>>): Prisma__TariffRateClient<$Result.GetResult<Prisma.$TariffRatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TariffRates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffRateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TariffRates
     * const tariffRates = await prisma.tariffRate.findMany()
     * 
     * // Get first 10 TariffRates
     * const tariffRates = await prisma.tariffRate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tariffRateWithIdOnly = await prisma.tariffRate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TariffRateFindManyArgs>(args?: SelectSubset<T, TariffRateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TariffRatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TariffRate.
     * @param {TariffRateCreateArgs} args - Arguments to create a TariffRate.
     * @example
     * // Create one TariffRate
     * const TariffRate = await prisma.tariffRate.create({
     *   data: {
     *     // ... data to create a TariffRate
     *   }
     * })
     * 
     */
    create<T extends TariffRateCreateArgs>(args: SelectSubset<T, TariffRateCreateArgs<ExtArgs>>): Prisma__TariffRateClient<$Result.GetResult<Prisma.$TariffRatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TariffRates.
     * @param {TariffRateCreateManyArgs} args - Arguments to create many TariffRates.
     * @example
     * // Create many TariffRates
     * const tariffRate = await prisma.tariffRate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TariffRateCreateManyArgs>(args?: SelectSubset<T, TariffRateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TariffRates and returns the data saved in the database.
     * @param {TariffRateCreateManyAndReturnArgs} args - Arguments to create many TariffRates.
     * @example
     * // Create many TariffRates
     * const tariffRate = await prisma.tariffRate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TariffRates and only return the `id`
     * const tariffRateWithIdOnly = await prisma.tariffRate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TariffRateCreateManyAndReturnArgs>(args?: SelectSubset<T, TariffRateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TariffRatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TariffRate.
     * @param {TariffRateDeleteArgs} args - Arguments to delete one TariffRate.
     * @example
     * // Delete one TariffRate
     * const TariffRate = await prisma.tariffRate.delete({
     *   where: {
     *     // ... filter to delete one TariffRate
     *   }
     * })
     * 
     */
    delete<T extends TariffRateDeleteArgs>(args: SelectSubset<T, TariffRateDeleteArgs<ExtArgs>>): Prisma__TariffRateClient<$Result.GetResult<Prisma.$TariffRatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TariffRate.
     * @param {TariffRateUpdateArgs} args - Arguments to update one TariffRate.
     * @example
     * // Update one TariffRate
     * const tariffRate = await prisma.tariffRate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TariffRateUpdateArgs>(args: SelectSubset<T, TariffRateUpdateArgs<ExtArgs>>): Prisma__TariffRateClient<$Result.GetResult<Prisma.$TariffRatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TariffRates.
     * @param {TariffRateDeleteManyArgs} args - Arguments to filter TariffRates to delete.
     * @example
     * // Delete a few TariffRates
     * const { count } = await prisma.tariffRate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TariffRateDeleteManyArgs>(args?: SelectSubset<T, TariffRateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TariffRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffRateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TariffRates
     * const tariffRate = await prisma.tariffRate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TariffRateUpdateManyArgs>(args: SelectSubset<T, TariffRateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TariffRates and returns the data updated in the database.
     * @param {TariffRateUpdateManyAndReturnArgs} args - Arguments to update many TariffRates.
     * @example
     * // Update many TariffRates
     * const tariffRate = await prisma.tariffRate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TariffRates and only return the `id`
     * const tariffRateWithIdOnly = await prisma.tariffRate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TariffRateUpdateManyAndReturnArgs>(args: SelectSubset<T, TariffRateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TariffRatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TariffRate.
     * @param {TariffRateUpsertArgs} args - Arguments to update or create a TariffRate.
     * @example
     * // Update or create a TariffRate
     * const tariffRate = await prisma.tariffRate.upsert({
     *   create: {
     *     // ... data to create a TariffRate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TariffRate we want to update
     *   }
     * })
     */
    upsert<T extends TariffRateUpsertArgs>(args: SelectSubset<T, TariffRateUpsertArgs<ExtArgs>>): Prisma__TariffRateClient<$Result.GetResult<Prisma.$TariffRatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TariffRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffRateCountArgs} args - Arguments to filter TariffRates to count.
     * @example
     * // Count the number of TariffRates
     * const count = await prisma.tariffRate.count({
     *   where: {
     *     // ... the filter for the TariffRates we want to count
     *   }
     * })
    **/
    count<T extends TariffRateCountArgs>(
      args?: Subset<T, TariffRateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TariffRateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TariffRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffRateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TariffRateAggregateArgs>(args: Subset<T, TariffRateAggregateArgs>): Prisma.PrismaPromise<GetTariffRateAggregateType<T>>

    /**
     * Group by TariffRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffRateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TariffRateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TariffRateGroupByArgs['orderBy'] }
        : { orderBy?: TariffRateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TariffRateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTariffRateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TariffRate model
   */
  readonly fields: TariffRateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TariffRate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TariffRateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tariffPlan<T extends TariffPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TariffPlanDefaultArgs<ExtArgs>>): Prisma__TariffPlanClient<$Result.GetResult<Prisma.$TariffPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TariffRate model
   */
  interface TariffRateFieldRefs {
    readonly id: FieldRef<"TariffRate", 'Int'>
    readonly planId: FieldRef<"TariffRate", 'Int'>
    readonly vehicleType: FieldRef<"TariffRate", 'String'>
    readonly slotType: FieldRef<"TariffRate", 'String'>
    readonly startTime: FieldRef<"TariffRate", 'DateTime'>
    readonly endTime: FieldRef<"TariffRate", 'DateTime'>
    readonly dayCategory: FieldRef<"TariffRate", 'String'>
    readonly basePrice: FieldRef<"TariffRate", 'Decimal'>
    readonly hourlyRate: FieldRef<"TariffRate", 'Decimal'>
    readonly dayRate: FieldRef<"TariffRate", 'Decimal'>
    readonly minimumCharge: FieldRef<"TariffRate", 'Decimal'>
    readonly gracePeriodMinutes: FieldRef<"TariffRate", 'Int'>
    readonly createdAt: FieldRef<"TariffRate", 'DateTime'>
    readonly updatedAt: FieldRef<"TariffRate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TariffRate findUnique
   */
  export type TariffRateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffRate
     */
    select?: TariffRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TariffRate
     */
    omit?: TariffRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffRateInclude<ExtArgs> | null
    /**
     * Filter, which TariffRate to fetch.
     */
    where: TariffRateWhereUniqueInput
  }

  /**
   * TariffRate findUniqueOrThrow
   */
  export type TariffRateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffRate
     */
    select?: TariffRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TariffRate
     */
    omit?: TariffRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffRateInclude<ExtArgs> | null
    /**
     * Filter, which TariffRate to fetch.
     */
    where: TariffRateWhereUniqueInput
  }

  /**
   * TariffRate findFirst
   */
  export type TariffRateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffRate
     */
    select?: TariffRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TariffRate
     */
    omit?: TariffRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffRateInclude<ExtArgs> | null
    /**
     * Filter, which TariffRate to fetch.
     */
    where?: TariffRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TariffRates to fetch.
     */
    orderBy?: TariffRateOrderByWithRelationInput | TariffRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TariffRates.
     */
    cursor?: TariffRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TariffRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TariffRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TariffRates.
     */
    distinct?: TariffRateScalarFieldEnum | TariffRateScalarFieldEnum[]
  }

  /**
   * TariffRate findFirstOrThrow
   */
  export type TariffRateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffRate
     */
    select?: TariffRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TariffRate
     */
    omit?: TariffRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffRateInclude<ExtArgs> | null
    /**
     * Filter, which TariffRate to fetch.
     */
    where?: TariffRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TariffRates to fetch.
     */
    orderBy?: TariffRateOrderByWithRelationInput | TariffRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TariffRates.
     */
    cursor?: TariffRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TariffRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TariffRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TariffRates.
     */
    distinct?: TariffRateScalarFieldEnum | TariffRateScalarFieldEnum[]
  }

  /**
   * TariffRate findMany
   */
  export type TariffRateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffRate
     */
    select?: TariffRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TariffRate
     */
    omit?: TariffRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffRateInclude<ExtArgs> | null
    /**
     * Filter, which TariffRates to fetch.
     */
    where?: TariffRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TariffRates to fetch.
     */
    orderBy?: TariffRateOrderByWithRelationInput | TariffRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TariffRates.
     */
    cursor?: TariffRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TariffRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TariffRates.
     */
    skip?: number
    distinct?: TariffRateScalarFieldEnum | TariffRateScalarFieldEnum[]
  }

  /**
   * TariffRate create
   */
  export type TariffRateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffRate
     */
    select?: TariffRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TariffRate
     */
    omit?: TariffRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffRateInclude<ExtArgs> | null
    /**
     * The data needed to create a TariffRate.
     */
    data: XOR<TariffRateCreateInput, TariffRateUncheckedCreateInput>
  }

  /**
   * TariffRate createMany
   */
  export type TariffRateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TariffRates.
     */
    data: TariffRateCreateManyInput | TariffRateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TariffRate createManyAndReturn
   */
  export type TariffRateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffRate
     */
    select?: TariffRateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TariffRate
     */
    omit?: TariffRateOmit<ExtArgs> | null
    /**
     * The data used to create many TariffRates.
     */
    data: TariffRateCreateManyInput | TariffRateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffRateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TariffRate update
   */
  export type TariffRateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffRate
     */
    select?: TariffRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TariffRate
     */
    omit?: TariffRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffRateInclude<ExtArgs> | null
    /**
     * The data needed to update a TariffRate.
     */
    data: XOR<TariffRateUpdateInput, TariffRateUncheckedUpdateInput>
    /**
     * Choose, which TariffRate to update.
     */
    where: TariffRateWhereUniqueInput
  }

  /**
   * TariffRate updateMany
   */
  export type TariffRateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TariffRates.
     */
    data: XOR<TariffRateUpdateManyMutationInput, TariffRateUncheckedUpdateManyInput>
    /**
     * Filter which TariffRates to update
     */
    where?: TariffRateWhereInput
    /**
     * Limit how many TariffRates to update.
     */
    limit?: number
  }

  /**
   * TariffRate updateManyAndReturn
   */
  export type TariffRateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffRate
     */
    select?: TariffRateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TariffRate
     */
    omit?: TariffRateOmit<ExtArgs> | null
    /**
     * The data used to update TariffRates.
     */
    data: XOR<TariffRateUpdateManyMutationInput, TariffRateUncheckedUpdateManyInput>
    /**
     * Filter which TariffRates to update
     */
    where?: TariffRateWhereInput
    /**
     * Limit how many TariffRates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffRateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TariffRate upsert
   */
  export type TariffRateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffRate
     */
    select?: TariffRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TariffRate
     */
    omit?: TariffRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffRateInclude<ExtArgs> | null
    /**
     * The filter to search for the TariffRate to update in case it exists.
     */
    where: TariffRateWhereUniqueInput
    /**
     * In case the TariffRate found by the `where` argument doesn't exist, create a new TariffRate with this data.
     */
    create: XOR<TariffRateCreateInput, TariffRateUncheckedCreateInput>
    /**
     * In case the TariffRate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TariffRateUpdateInput, TariffRateUncheckedUpdateInput>
  }

  /**
   * TariffRate delete
   */
  export type TariffRateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffRate
     */
    select?: TariffRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TariffRate
     */
    omit?: TariffRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffRateInclude<ExtArgs> | null
    /**
     * Filter which TariffRate to delete.
     */
    where: TariffRateWhereUniqueInput
  }

  /**
   * TariffRate deleteMany
   */
  export type TariffRateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TariffRates to delete
     */
    where?: TariffRateWhereInput
    /**
     * Limit how many TariffRates to delete.
     */
    limit?: number
  }

  /**
   * TariffRate without action
   */
  export type TariffRateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffRate
     */
    select?: TariffRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TariffRate
     */
    omit?: TariffRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffRateInclude<ExtArgs> | null
  }


  /**
   * Model Booking
   */

  export type AggregateBooking = {
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  export type BookingAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    vehicleId: number | null
    slotId: number | null
    promoCodeId: number | null
    estimatedPrice: Decimal | null
    finalPrice: Decimal | null
    cancellationTimeMinutes: number | null
  }

  export type BookingSumAggregateOutputType = {
    id: number | null
    userId: number | null
    vehicleId: number | null
    slotId: number | null
    promoCodeId: number | null
    estimatedPrice: Decimal | null
    finalPrice: Decimal | null
    cancellationTimeMinutes: number | null
  }

  export type BookingMinAggregateOutputType = {
    id: number | null
    userId: number | null
    vehicleId: number | null
    slotId: number | null
    promoCodeId: number | null
    bookingReference: string | null
    bookingTime: Date | null
    scheduledEntry: Date | null
    scheduledExit: Date | null
    actualEntry: Date | null
    actualExit: Date | null
    qrCode: string | null
    bookingStatus: string | null
    estimatedPrice: Decimal | null
    finalPrice: Decimal | null
    cancellationReason: string | null
    cancellationTimeMinutes: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    vehicleId: number | null
    slotId: number | null
    promoCodeId: number | null
    bookingReference: string | null
    bookingTime: Date | null
    scheduledEntry: Date | null
    scheduledExit: Date | null
    actualEntry: Date | null
    actualExit: Date | null
    qrCode: string | null
    bookingStatus: string | null
    estimatedPrice: Decimal | null
    finalPrice: Decimal | null
    cancellationReason: string | null
    cancellationTimeMinutes: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingCountAggregateOutputType = {
    id: number
    userId: number
    vehicleId: number
    slotId: number
    promoCodeId: number
    bookingReference: number
    bookingTime: number
    scheduledEntry: number
    scheduledExit: number
    actualEntry: number
    actualExit: number
    qrCode: number
    bookingStatus: number
    estimatedPrice: number
    finalPrice: number
    cancellationReason: number
    cancellationTimeMinutes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BookingAvgAggregateInputType = {
    id?: true
    userId?: true
    vehicleId?: true
    slotId?: true
    promoCodeId?: true
    estimatedPrice?: true
    finalPrice?: true
    cancellationTimeMinutes?: true
  }

  export type BookingSumAggregateInputType = {
    id?: true
    userId?: true
    vehicleId?: true
    slotId?: true
    promoCodeId?: true
    estimatedPrice?: true
    finalPrice?: true
    cancellationTimeMinutes?: true
  }

  export type BookingMinAggregateInputType = {
    id?: true
    userId?: true
    vehicleId?: true
    slotId?: true
    promoCodeId?: true
    bookingReference?: true
    bookingTime?: true
    scheduledEntry?: true
    scheduledExit?: true
    actualEntry?: true
    actualExit?: true
    qrCode?: true
    bookingStatus?: true
    estimatedPrice?: true
    finalPrice?: true
    cancellationReason?: true
    cancellationTimeMinutes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingMaxAggregateInputType = {
    id?: true
    userId?: true
    vehicleId?: true
    slotId?: true
    promoCodeId?: true
    bookingReference?: true
    bookingTime?: true
    scheduledEntry?: true
    scheduledExit?: true
    actualEntry?: true
    actualExit?: true
    qrCode?: true
    bookingStatus?: true
    estimatedPrice?: true
    finalPrice?: true
    cancellationReason?: true
    cancellationTimeMinutes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingCountAggregateInputType = {
    id?: true
    userId?: true
    vehicleId?: true
    slotId?: true
    promoCodeId?: true
    bookingReference?: true
    bookingTime?: true
    scheduledEntry?: true
    scheduledExit?: true
    actualEntry?: true
    actualExit?: true
    qrCode?: true
    bookingStatus?: true
    estimatedPrice?: true
    finalPrice?: true
    cancellationReason?: true
    cancellationTimeMinutes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Booking to aggregate.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMaxAggregateInputType
  }

  export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking[P]>
      : GetScalarType<T[P], AggregateBooking[P]>
  }




  export type BookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithAggregationInput | BookingOrderByWithAggregationInput[]
    by: BookingScalarFieldEnum[] | BookingScalarFieldEnum
    having?: BookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCountAggregateInputType | true
    _avg?: BookingAvgAggregateInputType
    _sum?: BookingSumAggregateInputType
    _min?: BookingMinAggregateInputType
    _max?: BookingMaxAggregateInputType
  }

  export type BookingGroupByOutputType = {
    id: number
    userId: number
    vehicleId: number
    slotId: number
    promoCodeId: number | null
    bookingReference: string
    bookingTime: Date
    scheduledEntry: Date
    scheduledExit: Date
    actualEntry: Date | null
    actualExit: Date | null
    qrCode: string | null
    bookingStatus: string
    estimatedPrice: Decimal
    finalPrice: Decimal | null
    cancellationReason: string | null
    cancellationTimeMinutes: number | null
    createdAt: Date
    updatedAt: Date | null
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  type GetBookingGroupByPayload<T extends BookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGroupByOutputType[P]>
        }
      >
    >


  export type BookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    vehicleId?: boolean
    slotId?: boolean
    promoCodeId?: boolean
    bookingReference?: boolean
    bookingTime?: boolean
    scheduledEntry?: boolean
    scheduledExit?: boolean
    actualEntry?: boolean
    actualExit?: boolean
    qrCode?: boolean
    bookingStatus?: boolean
    estimatedPrice?: boolean
    finalPrice?: boolean
    cancellationReason?: boolean
    cancellationTimeMinutes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
    parkingSlot?: boolean | ParkingSlotDefaultArgs<ExtArgs>
    promoCode?: boolean | Booking$promoCodeArgs<ExtArgs>
    bookingStatusLogs?: boolean | Booking$bookingStatusLogsArgs<ExtArgs>
    bookingPayment?: boolean | Booking$bookingPaymentArgs<ExtArgs>
    accessLogs?: boolean | Booking$accessLogsArgs<ExtArgs>
    bookingExtensions?: boolean | Booking$bookingExtensionsArgs<ExtArgs>
    placeRatings?: boolean | Booking$placeRatingsArgs<ExtArgs>
    notifications?: boolean | Booking$notificationsArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    vehicleId?: boolean
    slotId?: boolean
    promoCodeId?: boolean
    bookingReference?: boolean
    bookingTime?: boolean
    scheduledEntry?: boolean
    scheduledExit?: boolean
    actualEntry?: boolean
    actualExit?: boolean
    qrCode?: boolean
    bookingStatus?: boolean
    estimatedPrice?: boolean
    finalPrice?: boolean
    cancellationReason?: boolean
    cancellationTimeMinutes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
    parkingSlot?: boolean | ParkingSlotDefaultArgs<ExtArgs>
    promoCode?: boolean | Booking$promoCodeArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    vehicleId?: boolean
    slotId?: boolean
    promoCodeId?: boolean
    bookingReference?: boolean
    bookingTime?: boolean
    scheduledEntry?: boolean
    scheduledExit?: boolean
    actualEntry?: boolean
    actualExit?: boolean
    qrCode?: boolean
    bookingStatus?: boolean
    estimatedPrice?: boolean
    finalPrice?: boolean
    cancellationReason?: boolean
    cancellationTimeMinutes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
    parkingSlot?: boolean | ParkingSlotDefaultArgs<ExtArgs>
    promoCode?: boolean | Booking$promoCodeArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectScalar = {
    id?: boolean
    userId?: boolean
    vehicleId?: boolean
    slotId?: boolean
    promoCodeId?: boolean
    bookingReference?: boolean
    bookingTime?: boolean
    scheduledEntry?: boolean
    scheduledExit?: boolean
    actualEntry?: boolean
    actualExit?: boolean
    qrCode?: boolean
    bookingStatus?: boolean
    estimatedPrice?: boolean
    finalPrice?: boolean
    cancellationReason?: boolean
    cancellationTimeMinutes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BookingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "vehicleId" | "slotId" | "promoCodeId" | "bookingReference" | "bookingTime" | "scheduledEntry" | "scheduledExit" | "actualEntry" | "actualExit" | "qrCode" | "bookingStatus" | "estimatedPrice" | "finalPrice" | "cancellationReason" | "cancellationTimeMinutes" | "createdAt" | "updatedAt", ExtArgs["result"]["booking"]>
  export type BookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
    parkingSlot?: boolean | ParkingSlotDefaultArgs<ExtArgs>
    promoCode?: boolean | Booking$promoCodeArgs<ExtArgs>
    bookingStatusLogs?: boolean | Booking$bookingStatusLogsArgs<ExtArgs>
    bookingPayment?: boolean | Booking$bookingPaymentArgs<ExtArgs>
    accessLogs?: boolean | Booking$accessLogsArgs<ExtArgs>
    bookingExtensions?: boolean | Booking$bookingExtensionsArgs<ExtArgs>
    placeRatings?: boolean | Booking$placeRatingsArgs<ExtArgs>
    notifications?: boolean | Booking$notificationsArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
    parkingSlot?: boolean | ParkingSlotDefaultArgs<ExtArgs>
    promoCode?: boolean | Booking$promoCodeArgs<ExtArgs>
  }
  export type BookingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
    parkingSlot?: boolean | ParkingSlotDefaultArgs<ExtArgs>
    promoCode?: boolean | Booking$promoCodeArgs<ExtArgs>
  }

  export type $BookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Booking"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      vehicle: Prisma.$VehiclePayload<ExtArgs>
      parkingSlot: Prisma.$ParkingSlotPayload<ExtArgs>
      promoCode: Prisma.$PromoCodePayload<ExtArgs> | null
      bookingStatusLogs: Prisma.$BookingStatusLogPayload<ExtArgs>[]
      bookingPayment: Prisma.$BookingPaymentPayload<ExtArgs> | null
      accessLogs: Prisma.$AccessLogPayload<ExtArgs>[]
      bookingExtensions: Prisma.$BookingExtensionPayload<ExtArgs>[]
      placeRatings: Prisma.$PlaceRatingPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      vehicleId: number
      slotId: number
      promoCodeId: number | null
      bookingReference: string
      bookingTime: Date
      scheduledEntry: Date
      scheduledExit: Date
      actualEntry: Date | null
      actualExit: Date | null
      qrCode: string | null
      bookingStatus: string
      estimatedPrice: Prisma.Decimal
      finalPrice: Prisma.Decimal | null
      cancellationReason: string | null
      cancellationTimeMinutes: number | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["booking"]>
    composites: {}
  }

  type BookingGetPayload<S extends boolean | null | undefined | BookingDefaultArgs> = $Result.GetResult<Prisma.$BookingPayload, S>

  type BookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingCountAggregateInputType | true
    }

  export interface BookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Booking'], meta: { name: 'Booking' } }
    /**
     * Find zero or one Booking that matches the filter.
     * @param {BookingFindUniqueArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingFindUniqueArgs>(args: SelectSubset<T, BookingFindUniqueArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Booking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingFindFirstArgs>(args?: SelectSubset<T, BookingFindFirstArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.booking.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.booking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingWithIdOnly = await prisma.booking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingFindManyArgs>(args?: SelectSubset<T, BookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Booking.
     * @param {BookingCreateArgs} args - Arguments to create a Booking.
     * @example
     * // Create one Booking
     * const Booking = await prisma.booking.create({
     *   data: {
     *     // ... data to create a Booking
     *   }
     * })
     * 
     */
    create<T extends BookingCreateArgs>(args: SelectSubset<T, BookingCreateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bookings.
     * @param {BookingCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingCreateManyArgs>(args?: SelectSubset<T, BookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookings and returns the data saved in the database.
     * @param {BookingCreateManyAndReturnArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Booking.
     * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
     * @example
     * // Delete one Booking
     * const Booking = await prisma.booking.delete({
     *   where: {
     *     // ... filter to delete one Booking
     *   }
     * })
     * 
     */
    delete<T extends BookingDeleteArgs>(args: SelectSubset<T, BookingDeleteArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Booking.
     * @param {BookingUpdateArgs} args - Arguments to update one Booking.
     * @example
     * // Update one Booking
     * const booking = await prisma.booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingUpdateArgs>(args: SelectSubset<T, BookingUpdateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bookings.
     * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingDeleteManyArgs>(args?: SelectSubset<T, BookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingUpdateManyArgs>(args: SelectSubset<T, BookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings and returns the data updated in the database.
     * @param {BookingUpdateManyAndReturnArgs} args - Arguments to update many Bookings.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Booking.
     * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
     * @example
     * // Update or create a Booking
     * const booking = await prisma.booking.upsert({
     *   create: {
     *     // ... data to create a Booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking we want to update
     *   }
     * })
     */
    upsert<T extends BookingUpsertArgs>(args: SelectSubset<T, BookingUpsertArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.booking.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingCountArgs>(
      args?: Subset<T, BookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAggregateArgs>(args: Subset<T, BookingAggregateArgs>): Prisma.PrismaPromise<GetBookingAggregateType<T>>

    /**
     * Group by Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingGroupByArgs['orderBy'] }
        : { orderBy?: BookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Booking model
   */
  readonly fields: BookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vehicle<T extends VehicleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VehicleDefaultArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parkingSlot<T extends ParkingSlotDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParkingSlotDefaultArgs<ExtArgs>>): Prisma__ParkingSlotClient<$Result.GetResult<Prisma.$ParkingSlotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    promoCode<T extends Booking$promoCodeArgs<ExtArgs> = {}>(args?: Subset<T, Booking$promoCodeArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    bookingStatusLogs<T extends Booking$bookingStatusLogsArgs<ExtArgs> = {}>(args?: Subset<T, Booking$bookingStatusLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingStatusLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookingPayment<T extends Booking$bookingPaymentArgs<ExtArgs> = {}>(args?: Subset<T, Booking$bookingPaymentArgs<ExtArgs>>): Prisma__BookingPaymentClient<$Result.GetResult<Prisma.$BookingPaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    accessLogs<T extends Booking$accessLogsArgs<ExtArgs> = {}>(args?: Subset<T, Booking$accessLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookingExtensions<T extends Booking$bookingExtensionsArgs<ExtArgs> = {}>(args?: Subset<T, Booking$bookingExtensionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingExtensionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    placeRatings<T extends Booking$placeRatingsArgs<ExtArgs> = {}>(args?: Subset<T, Booking$placeRatingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaceRatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Booking$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Booking$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Booking model
   */
  interface BookingFieldRefs {
    readonly id: FieldRef<"Booking", 'Int'>
    readonly userId: FieldRef<"Booking", 'Int'>
    readonly vehicleId: FieldRef<"Booking", 'Int'>
    readonly slotId: FieldRef<"Booking", 'Int'>
    readonly promoCodeId: FieldRef<"Booking", 'Int'>
    readonly bookingReference: FieldRef<"Booking", 'String'>
    readonly bookingTime: FieldRef<"Booking", 'DateTime'>
    readonly scheduledEntry: FieldRef<"Booking", 'DateTime'>
    readonly scheduledExit: FieldRef<"Booking", 'DateTime'>
    readonly actualEntry: FieldRef<"Booking", 'DateTime'>
    readonly actualExit: FieldRef<"Booking", 'DateTime'>
    readonly qrCode: FieldRef<"Booking", 'String'>
    readonly bookingStatus: FieldRef<"Booking", 'String'>
    readonly estimatedPrice: FieldRef<"Booking", 'Decimal'>
    readonly finalPrice: FieldRef<"Booking", 'Decimal'>
    readonly cancellationReason: FieldRef<"Booking", 'String'>
    readonly cancellationTimeMinutes: FieldRef<"Booking", 'Int'>
    readonly createdAt: FieldRef<"Booking", 'DateTime'>
    readonly updatedAt: FieldRef<"Booking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Booking findUnique
   */
  export type BookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findUniqueOrThrow
   */
  export type BookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findFirst
   */
  export type BookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findFirstOrThrow
   */
  export type BookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findMany
   */
  export type BookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking create
   */
  export type BookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to create a Booking.
     */
    data: XOR<BookingCreateInput, BookingUncheckedCreateInput>
  }

  /**
   * Booking createMany
   */
  export type BookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Booking createManyAndReturn
   */
  export type BookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking update
   */
  export type BookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to update a Booking.
     */
    data: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
    /**
     * Choose, which Booking to update.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking updateMany
   */
  export type BookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to update.
     */
    limit?: number
  }

  /**
   * Booking updateManyAndReturn
   */
  export type BookingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking upsert
   */
  export type BookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The filter to search for the Booking to update in case it exists.
     */
    where: BookingWhereUniqueInput
    /**
     * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
     */
    create: XOR<BookingCreateInput, BookingUncheckedCreateInput>
    /**
     * In case the Booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
  }

  /**
   * Booking delete
   */
  export type BookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter which Booking to delete.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking deleteMany
   */
  export type BookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to delete.
     */
    limit?: number
  }

  /**
   * Booking.promoCode
   */
  export type Booking$promoCodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    where?: PromoCodeWhereInput
  }

  /**
   * Booking.bookingStatusLogs
   */
  export type Booking$bookingStatusLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStatusLog
     */
    select?: BookingStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingStatusLog
     */
    omit?: BookingStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStatusLogInclude<ExtArgs> | null
    where?: BookingStatusLogWhereInput
    orderBy?: BookingStatusLogOrderByWithRelationInput | BookingStatusLogOrderByWithRelationInput[]
    cursor?: BookingStatusLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingStatusLogScalarFieldEnum | BookingStatusLogScalarFieldEnum[]
  }

  /**
   * Booking.bookingPayment
   */
  export type Booking$bookingPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingPayment
     */
    select?: BookingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingPayment
     */
    omit?: BookingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingPaymentInclude<ExtArgs> | null
    where?: BookingPaymentWhereInput
  }

  /**
   * Booking.accessLogs
   */
  export type Booking$accessLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessLog
     */
    select?: AccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessLog
     */
    omit?: AccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessLogInclude<ExtArgs> | null
    where?: AccessLogWhereInput
    orderBy?: AccessLogOrderByWithRelationInput | AccessLogOrderByWithRelationInput[]
    cursor?: AccessLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccessLogScalarFieldEnum | AccessLogScalarFieldEnum[]
  }

  /**
   * Booking.bookingExtensions
   */
  export type Booking$bookingExtensionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingExtension
     */
    select?: BookingExtensionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingExtension
     */
    omit?: BookingExtensionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingExtensionInclude<ExtArgs> | null
    where?: BookingExtensionWhereInput
    orderBy?: BookingExtensionOrderByWithRelationInput | BookingExtensionOrderByWithRelationInput[]
    cursor?: BookingExtensionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingExtensionScalarFieldEnum | BookingExtensionScalarFieldEnum[]
  }

  /**
   * Booking.placeRatings
   */
  export type Booking$placeRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceRating
     */
    select?: PlaceRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceRating
     */
    omit?: PlaceRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceRatingInclude<ExtArgs> | null
    where?: PlaceRatingWhereInput
    orderBy?: PlaceRatingOrderByWithRelationInput | PlaceRatingOrderByWithRelationInput[]
    cursor?: PlaceRatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlaceRatingScalarFieldEnum | PlaceRatingScalarFieldEnum[]
  }

  /**
   * Booking.notifications
   */
  export type Booking$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Booking without action
   */
  export type BookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
  }


  /**
   * Model BookingStatusLog
   */

  export type AggregateBookingStatusLog = {
    _count: BookingStatusLogCountAggregateOutputType | null
    _avg: BookingStatusLogAvgAggregateOutputType | null
    _sum: BookingStatusLogSumAggregateOutputType | null
    _min: BookingStatusLogMinAggregateOutputType | null
    _max: BookingStatusLogMaxAggregateOutputType | null
  }

  export type BookingStatusLogAvgAggregateOutputType = {
    id: number | null
    bookingId: number | null
  }

  export type BookingStatusLogSumAggregateOutputType = {
    id: number | null
    bookingId: number | null
  }

  export type BookingStatusLogMinAggregateOutputType = {
    id: number | null
    bookingId: number | null
    previousStatus: string | null
    newStatus: string | null
    changedBy: string | null
    reason: string | null
    statusTime: Date | null
    createdAt: Date | null
  }

  export type BookingStatusLogMaxAggregateOutputType = {
    id: number | null
    bookingId: number | null
    previousStatus: string | null
    newStatus: string | null
    changedBy: string | null
    reason: string | null
    statusTime: Date | null
    createdAt: Date | null
  }

  export type BookingStatusLogCountAggregateOutputType = {
    id: number
    bookingId: number
    previousStatus: number
    newStatus: number
    changedBy: number
    reason: number
    statusTime: number
    createdAt: number
    _all: number
  }


  export type BookingStatusLogAvgAggregateInputType = {
    id?: true
    bookingId?: true
  }

  export type BookingStatusLogSumAggregateInputType = {
    id?: true
    bookingId?: true
  }

  export type BookingStatusLogMinAggregateInputType = {
    id?: true
    bookingId?: true
    previousStatus?: true
    newStatus?: true
    changedBy?: true
    reason?: true
    statusTime?: true
    createdAt?: true
  }

  export type BookingStatusLogMaxAggregateInputType = {
    id?: true
    bookingId?: true
    previousStatus?: true
    newStatus?: true
    changedBy?: true
    reason?: true
    statusTime?: true
    createdAt?: true
  }

  export type BookingStatusLogCountAggregateInputType = {
    id?: true
    bookingId?: true
    previousStatus?: true
    newStatus?: true
    changedBy?: true
    reason?: true
    statusTime?: true
    createdAt?: true
    _all?: true
  }

  export type BookingStatusLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingStatusLog to aggregate.
     */
    where?: BookingStatusLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingStatusLogs to fetch.
     */
    orderBy?: BookingStatusLogOrderByWithRelationInput | BookingStatusLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingStatusLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingStatusLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingStatusLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookingStatusLogs
    **/
    _count?: true | BookingStatusLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingStatusLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingStatusLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingStatusLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingStatusLogMaxAggregateInputType
  }

  export type GetBookingStatusLogAggregateType<T extends BookingStatusLogAggregateArgs> = {
        [P in keyof T & keyof AggregateBookingStatusLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookingStatusLog[P]>
      : GetScalarType<T[P], AggregateBookingStatusLog[P]>
  }




  export type BookingStatusLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingStatusLogWhereInput
    orderBy?: BookingStatusLogOrderByWithAggregationInput | BookingStatusLogOrderByWithAggregationInput[]
    by: BookingStatusLogScalarFieldEnum[] | BookingStatusLogScalarFieldEnum
    having?: BookingStatusLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingStatusLogCountAggregateInputType | true
    _avg?: BookingStatusLogAvgAggregateInputType
    _sum?: BookingStatusLogSumAggregateInputType
    _min?: BookingStatusLogMinAggregateInputType
    _max?: BookingStatusLogMaxAggregateInputType
  }

  export type BookingStatusLogGroupByOutputType = {
    id: number
    bookingId: number
    previousStatus: string
    newStatus: string
    changedBy: string
    reason: string | null
    statusTime: Date
    createdAt: Date
    _count: BookingStatusLogCountAggregateOutputType | null
    _avg: BookingStatusLogAvgAggregateOutputType | null
    _sum: BookingStatusLogSumAggregateOutputType | null
    _min: BookingStatusLogMinAggregateOutputType | null
    _max: BookingStatusLogMaxAggregateOutputType | null
  }

  type GetBookingStatusLogGroupByPayload<T extends BookingStatusLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingStatusLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingStatusLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingStatusLogGroupByOutputType[P]>
            : GetScalarType<T[P], BookingStatusLogGroupByOutputType[P]>
        }
      >
    >


  export type BookingStatusLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    previousStatus?: boolean
    newStatus?: boolean
    changedBy?: boolean
    reason?: boolean
    statusTime?: boolean
    createdAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingStatusLog"]>

  export type BookingStatusLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    previousStatus?: boolean
    newStatus?: boolean
    changedBy?: boolean
    reason?: boolean
    statusTime?: boolean
    createdAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingStatusLog"]>

  export type BookingStatusLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    previousStatus?: boolean
    newStatus?: boolean
    changedBy?: boolean
    reason?: boolean
    statusTime?: boolean
    createdAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingStatusLog"]>

  export type BookingStatusLogSelectScalar = {
    id?: boolean
    bookingId?: boolean
    previousStatus?: boolean
    newStatus?: boolean
    changedBy?: boolean
    reason?: boolean
    statusTime?: boolean
    createdAt?: boolean
  }

  export type BookingStatusLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "previousStatus" | "newStatus" | "changedBy" | "reason" | "statusTime" | "createdAt", ExtArgs["result"]["bookingStatusLog"]>
  export type BookingStatusLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }
  export type BookingStatusLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }
  export type BookingStatusLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }

  export type $BookingStatusLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookingStatusLog"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bookingId: number
      previousStatus: string
      newStatus: string
      changedBy: string
      reason: string | null
      statusTime: Date
      createdAt: Date
    }, ExtArgs["result"]["bookingStatusLog"]>
    composites: {}
  }

  type BookingStatusLogGetPayload<S extends boolean | null | undefined | BookingStatusLogDefaultArgs> = $Result.GetResult<Prisma.$BookingStatusLogPayload, S>

  type BookingStatusLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingStatusLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingStatusLogCountAggregateInputType | true
    }

  export interface BookingStatusLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookingStatusLog'], meta: { name: 'BookingStatusLog' } }
    /**
     * Find zero or one BookingStatusLog that matches the filter.
     * @param {BookingStatusLogFindUniqueArgs} args - Arguments to find a BookingStatusLog
     * @example
     * // Get one BookingStatusLog
     * const bookingStatusLog = await prisma.bookingStatusLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingStatusLogFindUniqueArgs>(args: SelectSubset<T, BookingStatusLogFindUniqueArgs<ExtArgs>>): Prisma__BookingStatusLogClient<$Result.GetResult<Prisma.$BookingStatusLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BookingStatusLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingStatusLogFindUniqueOrThrowArgs} args - Arguments to find a BookingStatusLog
     * @example
     * // Get one BookingStatusLog
     * const bookingStatusLog = await prisma.bookingStatusLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingStatusLogFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingStatusLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingStatusLogClient<$Result.GetResult<Prisma.$BookingStatusLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingStatusLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingStatusLogFindFirstArgs} args - Arguments to find a BookingStatusLog
     * @example
     * // Get one BookingStatusLog
     * const bookingStatusLog = await prisma.bookingStatusLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingStatusLogFindFirstArgs>(args?: SelectSubset<T, BookingStatusLogFindFirstArgs<ExtArgs>>): Prisma__BookingStatusLogClient<$Result.GetResult<Prisma.$BookingStatusLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingStatusLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingStatusLogFindFirstOrThrowArgs} args - Arguments to find a BookingStatusLog
     * @example
     * // Get one BookingStatusLog
     * const bookingStatusLog = await prisma.bookingStatusLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingStatusLogFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingStatusLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingStatusLogClient<$Result.GetResult<Prisma.$BookingStatusLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BookingStatusLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingStatusLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookingStatusLogs
     * const bookingStatusLogs = await prisma.bookingStatusLog.findMany()
     * 
     * // Get first 10 BookingStatusLogs
     * const bookingStatusLogs = await prisma.bookingStatusLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingStatusLogWithIdOnly = await prisma.bookingStatusLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingStatusLogFindManyArgs>(args?: SelectSubset<T, BookingStatusLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingStatusLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BookingStatusLog.
     * @param {BookingStatusLogCreateArgs} args - Arguments to create a BookingStatusLog.
     * @example
     * // Create one BookingStatusLog
     * const BookingStatusLog = await prisma.bookingStatusLog.create({
     *   data: {
     *     // ... data to create a BookingStatusLog
     *   }
     * })
     * 
     */
    create<T extends BookingStatusLogCreateArgs>(args: SelectSubset<T, BookingStatusLogCreateArgs<ExtArgs>>): Prisma__BookingStatusLogClient<$Result.GetResult<Prisma.$BookingStatusLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BookingStatusLogs.
     * @param {BookingStatusLogCreateManyArgs} args - Arguments to create many BookingStatusLogs.
     * @example
     * // Create many BookingStatusLogs
     * const bookingStatusLog = await prisma.bookingStatusLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingStatusLogCreateManyArgs>(args?: SelectSubset<T, BookingStatusLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BookingStatusLogs and returns the data saved in the database.
     * @param {BookingStatusLogCreateManyAndReturnArgs} args - Arguments to create many BookingStatusLogs.
     * @example
     * // Create many BookingStatusLogs
     * const bookingStatusLog = await prisma.bookingStatusLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BookingStatusLogs and only return the `id`
     * const bookingStatusLogWithIdOnly = await prisma.bookingStatusLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingStatusLogCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingStatusLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingStatusLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BookingStatusLog.
     * @param {BookingStatusLogDeleteArgs} args - Arguments to delete one BookingStatusLog.
     * @example
     * // Delete one BookingStatusLog
     * const BookingStatusLog = await prisma.bookingStatusLog.delete({
     *   where: {
     *     // ... filter to delete one BookingStatusLog
     *   }
     * })
     * 
     */
    delete<T extends BookingStatusLogDeleteArgs>(args: SelectSubset<T, BookingStatusLogDeleteArgs<ExtArgs>>): Prisma__BookingStatusLogClient<$Result.GetResult<Prisma.$BookingStatusLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BookingStatusLog.
     * @param {BookingStatusLogUpdateArgs} args - Arguments to update one BookingStatusLog.
     * @example
     * // Update one BookingStatusLog
     * const bookingStatusLog = await prisma.bookingStatusLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingStatusLogUpdateArgs>(args: SelectSubset<T, BookingStatusLogUpdateArgs<ExtArgs>>): Prisma__BookingStatusLogClient<$Result.GetResult<Prisma.$BookingStatusLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BookingStatusLogs.
     * @param {BookingStatusLogDeleteManyArgs} args - Arguments to filter BookingStatusLogs to delete.
     * @example
     * // Delete a few BookingStatusLogs
     * const { count } = await prisma.bookingStatusLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingStatusLogDeleteManyArgs>(args?: SelectSubset<T, BookingStatusLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingStatusLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingStatusLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookingStatusLogs
     * const bookingStatusLog = await prisma.bookingStatusLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingStatusLogUpdateManyArgs>(args: SelectSubset<T, BookingStatusLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingStatusLogs and returns the data updated in the database.
     * @param {BookingStatusLogUpdateManyAndReturnArgs} args - Arguments to update many BookingStatusLogs.
     * @example
     * // Update many BookingStatusLogs
     * const bookingStatusLog = await prisma.bookingStatusLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BookingStatusLogs and only return the `id`
     * const bookingStatusLogWithIdOnly = await prisma.bookingStatusLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingStatusLogUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingStatusLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingStatusLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BookingStatusLog.
     * @param {BookingStatusLogUpsertArgs} args - Arguments to update or create a BookingStatusLog.
     * @example
     * // Update or create a BookingStatusLog
     * const bookingStatusLog = await prisma.bookingStatusLog.upsert({
     *   create: {
     *     // ... data to create a BookingStatusLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookingStatusLog we want to update
     *   }
     * })
     */
    upsert<T extends BookingStatusLogUpsertArgs>(args: SelectSubset<T, BookingStatusLogUpsertArgs<ExtArgs>>): Prisma__BookingStatusLogClient<$Result.GetResult<Prisma.$BookingStatusLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BookingStatusLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingStatusLogCountArgs} args - Arguments to filter BookingStatusLogs to count.
     * @example
     * // Count the number of BookingStatusLogs
     * const count = await prisma.bookingStatusLog.count({
     *   where: {
     *     // ... the filter for the BookingStatusLogs we want to count
     *   }
     * })
    **/
    count<T extends BookingStatusLogCountArgs>(
      args?: Subset<T, BookingStatusLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingStatusLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookingStatusLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingStatusLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingStatusLogAggregateArgs>(args: Subset<T, BookingStatusLogAggregateArgs>): Prisma.PrismaPromise<GetBookingStatusLogAggregateType<T>>

    /**
     * Group by BookingStatusLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingStatusLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingStatusLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingStatusLogGroupByArgs['orderBy'] }
        : { orderBy?: BookingStatusLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingStatusLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingStatusLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookingStatusLog model
   */
  readonly fields: BookingStatusLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookingStatusLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingStatusLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookingStatusLog model
   */
  interface BookingStatusLogFieldRefs {
    readonly id: FieldRef<"BookingStatusLog", 'Int'>
    readonly bookingId: FieldRef<"BookingStatusLog", 'Int'>
    readonly previousStatus: FieldRef<"BookingStatusLog", 'String'>
    readonly newStatus: FieldRef<"BookingStatusLog", 'String'>
    readonly changedBy: FieldRef<"BookingStatusLog", 'String'>
    readonly reason: FieldRef<"BookingStatusLog", 'String'>
    readonly statusTime: FieldRef<"BookingStatusLog", 'DateTime'>
    readonly createdAt: FieldRef<"BookingStatusLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BookingStatusLog findUnique
   */
  export type BookingStatusLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStatusLog
     */
    select?: BookingStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingStatusLog
     */
    omit?: BookingStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStatusLogInclude<ExtArgs> | null
    /**
     * Filter, which BookingStatusLog to fetch.
     */
    where: BookingStatusLogWhereUniqueInput
  }

  /**
   * BookingStatusLog findUniqueOrThrow
   */
  export type BookingStatusLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStatusLog
     */
    select?: BookingStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingStatusLog
     */
    omit?: BookingStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStatusLogInclude<ExtArgs> | null
    /**
     * Filter, which BookingStatusLog to fetch.
     */
    where: BookingStatusLogWhereUniqueInput
  }

  /**
   * BookingStatusLog findFirst
   */
  export type BookingStatusLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStatusLog
     */
    select?: BookingStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingStatusLog
     */
    omit?: BookingStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStatusLogInclude<ExtArgs> | null
    /**
     * Filter, which BookingStatusLog to fetch.
     */
    where?: BookingStatusLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingStatusLogs to fetch.
     */
    orderBy?: BookingStatusLogOrderByWithRelationInput | BookingStatusLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingStatusLogs.
     */
    cursor?: BookingStatusLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingStatusLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingStatusLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingStatusLogs.
     */
    distinct?: BookingStatusLogScalarFieldEnum | BookingStatusLogScalarFieldEnum[]
  }

  /**
   * BookingStatusLog findFirstOrThrow
   */
  export type BookingStatusLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStatusLog
     */
    select?: BookingStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingStatusLog
     */
    omit?: BookingStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStatusLogInclude<ExtArgs> | null
    /**
     * Filter, which BookingStatusLog to fetch.
     */
    where?: BookingStatusLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingStatusLogs to fetch.
     */
    orderBy?: BookingStatusLogOrderByWithRelationInput | BookingStatusLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingStatusLogs.
     */
    cursor?: BookingStatusLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingStatusLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingStatusLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingStatusLogs.
     */
    distinct?: BookingStatusLogScalarFieldEnum | BookingStatusLogScalarFieldEnum[]
  }

  /**
   * BookingStatusLog findMany
   */
  export type BookingStatusLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStatusLog
     */
    select?: BookingStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingStatusLog
     */
    omit?: BookingStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStatusLogInclude<ExtArgs> | null
    /**
     * Filter, which BookingStatusLogs to fetch.
     */
    where?: BookingStatusLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingStatusLogs to fetch.
     */
    orderBy?: BookingStatusLogOrderByWithRelationInput | BookingStatusLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookingStatusLogs.
     */
    cursor?: BookingStatusLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingStatusLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingStatusLogs.
     */
    skip?: number
    distinct?: BookingStatusLogScalarFieldEnum | BookingStatusLogScalarFieldEnum[]
  }

  /**
   * BookingStatusLog create
   */
  export type BookingStatusLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStatusLog
     */
    select?: BookingStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingStatusLog
     */
    omit?: BookingStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStatusLogInclude<ExtArgs> | null
    /**
     * The data needed to create a BookingStatusLog.
     */
    data: XOR<BookingStatusLogCreateInput, BookingStatusLogUncheckedCreateInput>
  }

  /**
   * BookingStatusLog createMany
   */
  export type BookingStatusLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookingStatusLogs.
     */
    data: BookingStatusLogCreateManyInput | BookingStatusLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookingStatusLog createManyAndReturn
   */
  export type BookingStatusLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStatusLog
     */
    select?: BookingStatusLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingStatusLog
     */
    omit?: BookingStatusLogOmit<ExtArgs> | null
    /**
     * The data used to create many BookingStatusLogs.
     */
    data: BookingStatusLogCreateManyInput | BookingStatusLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStatusLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingStatusLog update
   */
  export type BookingStatusLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStatusLog
     */
    select?: BookingStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingStatusLog
     */
    omit?: BookingStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStatusLogInclude<ExtArgs> | null
    /**
     * The data needed to update a BookingStatusLog.
     */
    data: XOR<BookingStatusLogUpdateInput, BookingStatusLogUncheckedUpdateInput>
    /**
     * Choose, which BookingStatusLog to update.
     */
    where: BookingStatusLogWhereUniqueInput
  }

  /**
   * BookingStatusLog updateMany
   */
  export type BookingStatusLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookingStatusLogs.
     */
    data: XOR<BookingStatusLogUpdateManyMutationInput, BookingStatusLogUncheckedUpdateManyInput>
    /**
     * Filter which BookingStatusLogs to update
     */
    where?: BookingStatusLogWhereInput
    /**
     * Limit how many BookingStatusLogs to update.
     */
    limit?: number
  }

  /**
   * BookingStatusLog updateManyAndReturn
   */
  export type BookingStatusLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStatusLog
     */
    select?: BookingStatusLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingStatusLog
     */
    omit?: BookingStatusLogOmit<ExtArgs> | null
    /**
     * The data used to update BookingStatusLogs.
     */
    data: XOR<BookingStatusLogUpdateManyMutationInput, BookingStatusLogUncheckedUpdateManyInput>
    /**
     * Filter which BookingStatusLogs to update
     */
    where?: BookingStatusLogWhereInput
    /**
     * Limit how many BookingStatusLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStatusLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingStatusLog upsert
   */
  export type BookingStatusLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStatusLog
     */
    select?: BookingStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingStatusLog
     */
    omit?: BookingStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStatusLogInclude<ExtArgs> | null
    /**
     * The filter to search for the BookingStatusLog to update in case it exists.
     */
    where: BookingStatusLogWhereUniqueInput
    /**
     * In case the BookingStatusLog found by the `where` argument doesn't exist, create a new BookingStatusLog with this data.
     */
    create: XOR<BookingStatusLogCreateInput, BookingStatusLogUncheckedCreateInput>
    /**
     * In case the BookingStatusLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingStatusLogUpdateInput, BookingStatusLogUncheckedUpdateInput>
  }

  /**
   * BookingStatusLog delete
   */
  export type BookingStatusLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStatusLog
     */
    select?: BookingStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingStatusLog
     */
    omit?: BookingStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStatusLogInclude<ExtArgs> | null
    /**
     * Filter which BookingStatusLog to delete.
     */
    where: BookingStatusLogWhereUniqueInput
  }

  /**
   * BookingStatusLog deleteMany
   */
  export type BookingStatusLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingStatusLogs to delete
     */
    where?: BookingStatusLogWhereInput
    /**
     * Limit how many BookingStatusLogs to delete.
     */
    limit?: number
  }

  /**
   * BookingStatusLog without action
   */
  export type BookingStatusLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStatusLog
     */
    select?: BookingStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingStatusLog
     */
    omit?: BookingStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStatusLogInclude<ExtArgs> | null
  }


  /**
   * Model BookingPayment
   */

  export type AggregateBookingPayment = {
    _count: BookingPaymentCountAggregateOutputType | null
    _avg: BookingPaymentAvgAggregateOutputType | null
    _sum: BookingPaymentSumAggregateOutputType | null
    _min: BookingPaymentMinAggregateOutputType | null
    _max: BookingPaymentMaxAggregateOutputType | null
  }

  export type BookingPaymentAvgAggregateOutputType = {
    id: number | null
    bookingId: number | null
    originalAmount: Decimal | null
    discountAmount: Decimal | null
    taxAmount: Decimal | null
    surchargeAmount: Decimal | null
    finalAmount: Decimal | null
  }

  export type BookingPaymentSumAggregateOutputType = {
    id: number | null
    bookingId: number | null
    originalAmount: Decimal | null
    discountAmount: Decimal | null
    taxAmount: Decimal | null
    surchargeAmount: Decimal | null
    finalAmount: Decimal | null
  }

  export type BookingPaymentMinAggregateOutputType = {
    id: number | null
    bookingId: number | null
    paymentReference: string | null
    paymentStatus: string | null
    originalAmount: Decimal | null
    discountAmount: Decimal | null
    taxAmount: Decimal | null
    surchargeAmount: Decimal | null
    finalAmount: Decimal | null
    isPrepaid: boolean | null
    isRefunded: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingPaymentMaxAggregateOutputType = {
    id: number | null
    bookingId: number | null
    paymentReference: string | null
    paymentStatus: string | null
    originalAmount: Decimal | null
    discountAmount: Decimal | null
    taxAmount: Decimal | null
    surchargeAmount: Decimal | null
    finalAmount: Decimal | null
    isPrepaid: boolean | null
    isRefunded: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingPaymentCountAggregateOutputType = {
    id: number
    bookingId: number
    paymentReference: number
    paymentStatus: number
    originalAmount: number
    discountAmount: number
    taxAmount: number
    surchargeAmount: number
    finalAmount: number
    isPrepaid: number
    isRefunded: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BookingPaymentAvgAggregateInputType = {
    id?: true
    bookingId?: true
    originalAmount?: true
    discountAmount?: true
    taxAmount?: true
    surchargeAmount?: true
    finalAmount?: true
  }

  export type BookingPaymentSumAggregateInputType = {
    id?: true
    bookingId?: true
    originalAmount?: true
    discountAmount?: true
    taxAmount?: true
    surchargeAmount?: true
    finalAmount?: true
  }

  export type BookingPaymentMinAggregateInputType = {
    id?: true
    bookingId?: true
    paymentReference?: true
    paymentStatus?: true
    originalAmount?: true
    discountAmount?: true
    taxAmount?: true
    surchargeAmount?: true
    finalAmount?: true
    isPrepaid?: true
    isRefunded?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingPaymentMaxAggregateInputType = {
    id?: true
    bookingId?: true
    paymentReference?: true
    paymentStatus?: true
    originalAmount?: true
    discountAmount?: true
    taxAmount?: true
    surchargeAmount?: true
    finalAmount?: true
    isPrepaid?: true
    isRefunded?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingPaymentCountAggregateInputType = {
    id?: true
    bookingId?: true
    paymentReference?: true
    paymentStatus?: true
    originalAmount?: true
    discountAmount?: true
    taxAmount?: true
    surchargeAmount?: true
    finalAmount?: true
    isPrepaid?: true
    isRefunded?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BookingPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingPayment to aggregate.
     */
    where?: BookingPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingPayments to fetch.
     */
    orderBy?: BookingPaymentOrderByWithRelationInput | BookingPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookingPayments
    **/
    _count?: true | BookingPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingPaymentMaxAggregateInputType
  }

  export type GetBookingPaymentAggregateType<T extends BookingPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateBookingPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookingPayment[P]>
      : GetScalarType<T[P], AggregateBookingPayment[P]>
  }




  export type BookingPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingPaymentWhereInput
    orderBy?: BookingPaymentOrderByWithAggregationInput | BookingPaymentOrderByWithAggregationInput[]
    by: BookingPaymentScalarFieldEnum[] | BookingPaymentScalarFieldEnum
    having?: BookingPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingPaymentCountAggregateInputType | true
    _avg?: BookingPaymentAvgAggregateInputType
    _sum?: BookingPaymentSumAggregateInputType
    _min?: BookingPaymentMinAggregateInputType
    _max?: BookingPaymentMaxAggregateInputType
  }

  export type BookingPaymentGroupByOutputType = {
    id: number
    bookingId: number
    paymentReference: string | null
    paymentStatus: string
    originalAmount: Decimal
    discountAmount: Decimal
    taxAmount: Decimal
    surchargeAmount: Decimal
    finalAmount: Decimal
    isPrepaid: boolean
    isRefunded: boolean
    createdAt: Date
    updatedAt: Date | null
    _count: BookingPaymentCountAggregateOutputType | null
    _avg: BookingPaymentAvgAggregateOutputType | null
    _sum: BookingPaymentSumAggregateOutputType | null
    _min: BookingPaymentMinAggregateOutputType | null
    _max: BookingPaymentMaxAggregateOutputType | null
  }

  type GetBookingPaymentGroupByPayload<T extends BookingPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], BookingPaymentGroupByOutputType[P]>
        }
      >
    >


  export type BookingPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    paymentReference?: boolean
    paymentStatus?: boolean
    originalAmount?: boolean
    discountAmount?: boolean
    taxAmount?: boolean
    surchargeAmount?: boolean
    finalAmount?: boolean
    isPrepaid?: boolean
    isRefunded?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    paymentTransactions?: boolean | BookingPayment$paymentTransactionsArgs<ExtArgs>
    refundTransactions?: boolean | BookingPayment$refundTransactionsArgs<ExtArgs>
    _count?: boolean | BookingPaymentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingPayment"]>

  export type BookingPaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    paymentReference?: boolean
    paymentStatus?: boolean
    originalAmount?: boolean
    discountAmount?: boolean
    taxAmount?: boolean
    surchargeAmount?: boolean
    finalAmount?: boolean
    isPrepaid?: boolean
    isRefunded?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingPayment"]>

  export type BookingPaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    paymentReference?: boolean
    paymentStatus?: boolean
    originalAmount?: boolean
    discountAmount?: boolean
    taxAmount?: boolean
    surchargeAmount?: boolean
    finalAmount?: boolean
    isPrepaid?: boolean
    isRefunded?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingPayment"]>

  export type BookingPaymentSelectScalar = {
    id?: boolean
    bookingId?: boolean
    paymentReference?: boolean
    paymentStatus?: boolean
    originalAmount?: boolean
    discountAmount?: boolean
    taxAmount?: boolean
    surchargeAmount?: boolean
    finalAmount?: boolean
    isPrepaid?: boolean
    isRefunded?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BookingPaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "paymentReference" | "paymentStatus" | "originalAmount" | "discountAmount" | "taxAmount" | "surchargeAmount" | "finalAmount" | "isPrepaid" | "isRefunded" | "createdAt" | "updatedAt", ExtArgs["result"]["bookingPayment"]>
  export type BookingPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    paymentTransactions?: boolean | BookingPayment$paymentTransactionsArgs<ExtArgs>
    refundTransactions?: boolean | BookingPayment$refundTransactionsArgs<ExtArgs>
    _count?: boolean | BookingPaymentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BookingPaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }
  export type BookingPaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }

  export type $BookingPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookingPayment"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
      paymentTransactions: Prisma.$PaymentTransactionPayload<ExtArgs>[]
      refundTransactions: Prisma.$RefundTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bookingId: number
      paymentReference: string | null
      paymentStatus: string
      originalAmount: Prisma.Decimal
      discountAmount: Prisma.Decimal
      taxAmount: Prisma.Decimal
      surchargeAmount: Prisma.Decimal
      finalAmount: Prisma.Decimal
      isPrepaid: boolean
      isRefunded: boolean
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["bookingPayment"]>
    composites: {}
  }

  type BookingPaymentGetPayload<S extends boolean | null | undefined | BookingPaymentDefaultArgs> = $Result.GetResult<Prisma.$BookingPaymentPayload, S>

  type BookingPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingPaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingPaymentCountAggregateInputType | true
    }

  export interface BookingPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookingPayment'], meta: { name: 'BookingPayment' } }
    /**
     * Find zero or one BookingPayment that matches the filter.
     * @param {BookingPaymentFindUniqueArgs} args - Arguments to find a BookingPayment
     * @example
     * // Get one BookingPayment
     * const bookingPayment = await prisma.bookingPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingPaymentFindUniqueArgs>(args: SelectSubset<T, BookingPaymentFindUniqueArgs<ExtArgs>>): Prisma__BookingPaymentClient<$Result.GetResult<Prisma.$BookingPaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BookingPayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingPaymentFindUniqueOrThrowArgs} args - Arguments to find a BookingPayment
     * @example
     * // Get one BookingPayment
     * const bookingPayment = await prisma.bookingPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingPaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingPaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingPaymentClient<$Result.GetResult<Prisma.$BookingPaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingPaymentFindFirstArgs} args - Arguments to find a BookingPayment
     * @example
     * // Get one BookingPayment
     * const bookingPayment = await prisma.bookingPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingPaymentFindFirstArgs>(args?: SelectSubset<T, BookingPaymentFindFirstArgs<ExtArgs>>): Prisma__BookingPaymentClient<$Result.GetResult<Prisma.$BookingPaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingPaymentFindFirstOrThrowArgs} args - Arguments to find a BookingPayment
     * @example
     * // Get one BookingPayment
     * const bookingPayment = await prisma.bookingPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingPaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingPaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingPaymentClient<$Result.GetResult<Prisma.$BookingPaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BookingPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookingPayments
     * const bookingPayments = await prisma.bookingPayment.findMany()
     * 
     * // Get first 10 BookingPayments
     * const bookingPayments = await prisma.bookingPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingPaymentWithIdOnly = await prisma.bookingPayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingPaymentFindManyArgs>(args?: SelectSubset<T, BookingPaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BookingPayment.
     * @param {BookingPaymentCreateArgs} args - Arguments to create a BookingPayment.
     * @example
     * // Create one BookingPayment
     * const BookingPayment = await prisma.bookingPayment.create({
     *   data: {
     *     // ... data to create a BookingPayment
     *   }
     * })
     * 
     */
    create<T extends BookingPaymentCreateArgs>(args: SelectSubset<T, BookingPaymentCreateArgs<ExtArgs>>): Prisma__BookingPaymentClient<$Result.GetResult<Prisma.$BookingPaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BookingPayments.
     * @param {BookingPaymentCreateManyArgs} args - Arguments to create many BookingPayments.
     * @example
     * // Create many BookingPayments
     * const bookingPayment = await prisma.bookingPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingPaymentCreateManyArgs>(args?: SelectSubset<T, BookingPaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BookingPayments and returns the data saved in the database.
     * @param {BookingPaymentCreateManyAndReturnArgs} args - Arguments to create many BookingPayments.
     * @example
     * // Create many BookingPayments
     * const bookingPayment = await prisma.bookingPayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BookingPayments and only return the `id`
     * const bookingPaymentWithIdOnly = await prisma.bookingPayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingPaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingPaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BookingPayment.
     * @param {BookingPaymentDeleteArgs} args - Arguments to delete one BookingPayment.
     * @example
     * // Delete one BookingPayment
     * const BookingPayment = await prisma.bookingPayment.delete({
     *   where: {
     *     // ... filter to delete one BookingPayment
     *   }
     * })
     * 
     */
    delete<T extends BookingPaymentDeleteArgs>(args: SelectSubset<T, BookingPaymentDeleteArgs<ExtArgs>>): Prisma__BookingPaymentClient<$Result.GetResult<Prisma.$BookingPaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BookingPayment.
     * @param {BookingPaymentUpdateArgs} args - Arguments to update one BookingPayment.
     * @example
     * // Update one BookingPayment
     * const bookingPayment = await prisma.bookingPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingPaymentUpdateArgs>(args: SelectSubset<T, BookingPaymentUpdateArgs<ExtArgs>>): Prisma__BookingPaymentClient<$Result.GetResult<Prisma.$BookingPaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BookingPayments.
     * @param {BookingPaymentDeleteManyArgs} args - Arguments to filter BookingPayments to delete.
     * @example
     * // Delete a few BookingPayments
     * const { count } = await prisma.bookingPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingPaymentDeleteManyArgs>(args?: SelectSubset<T, BookingPaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookingPayments
     * const bookingPayment = await prisma.bookingPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingPaymentUpdateManyArgs>(args: SelectSubset<T, BookingPaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingPayments and returns the data updated in the database.
     * @param {BookingPaymentUpdateManyAndReturnArgs} args - Arguments to update many BookingPayments.
     * @example
     * // Update many BookingPayments
     * const bookingPayment = await prisma.bookingPayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BookingPayments and only return the `id`
     * const bookingPaymentWithIdOnly = await prisma.bookingPayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingPaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingPaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BookingPayment.
     * @param {BookingPaymentUpsertArgs} args - Arguments to update or create a BookingPayment.
     * @example
     * // Update or create a BookingPayment
     * const bookingPayment = await prisma.bookingPayment.upsert({
     *   create: {
     *     // ... data to create a BookingPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookingPayment we want to update
     *   }
     * })
     */
    upsert<T extends BookingPaymentUpsertArgs>(args: SelectSubset<T, BookingPaymentUpsertArgs<ExtArgs>>): Prisma__BookingPaymentClient<$Result.GetResult<Prisma.$BookingPaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BookingPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingPaymentCountArgs} args - Arguments to filter BookingPayments to count.
     * @example
     * // Count the number of BookingPayments
     * const count = await prisma.bookingPayment.count({
     *   where: {
     *     // ... the filter for the BookingPayments we want to count
     *   }
     * })
    **/
    count<T extends BookingPaymentCountArgs>(
      args?: Subset<T, BookingPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookingPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingPaymentAggregateArgs>(args: Subset<T, BookingPaymentAggregateArgs>): Prisma.PrismaPromise<GetBookingPaymentAggregateType<T>>

    /**
     * Group by BookingPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingPaymentGroupByArgs['orderBy'] }
        : { orderBy?: BookingPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookingPayment model
   */
  readonly fields: BookingPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookingPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    paymentTransactions<T extends BookingPayment$paymentTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, BookingPayment$paymentTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    refundTransactions<T extends BookingPayment$refundTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, BookingPayment$refundTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookingPayment model
   */
  interface BookingPaymentFieldRefs {
    readonly id: FieldRef<"BookingPayment", 'Int'>
    readonly bookingId: FieldRef<"BookingPayment", 'Int'>
    readonly paymentReference: FieldRef<"BookingPayment", 'String'>
    readonly paymentStatus: FieldRef<"BookingPayment", 'String'>
    readonly originalAmount: FieldRef<"BookingPayment", 'Decimal'>
    readonly discountAmount: FieldRef<"BookingPayment", 'Decimal'>
    readonly taxAmount: FieldRef<"BookingPayment", 'Decimal'>
    readonly surchargeAmount: FieldRef<"BookingPayment", 'Decimal'>
    readonly finalAmount: FieldRef<"BookingPayment", 'Decimal'>
    readonly isPrepaid: FieldRef<"BookingPayment", 'Boolean'>
    readonly isRefunded: FieldRef<"BookingPayment", 'Boolean'>
    readonly createdAt: FieldRef<"BookingPayment", 'DateTime'>
    readonly updatedAt: FieldRef<"BookingPayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BookingPayment findUnique
   */
  export type BookingPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingPayment
     */
    select?: BookingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingPayment
     */
    omit?: BookingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingPaymentInclude<ExtArgs> | null
    /**
     * Filter, which BookingPayment to fetch.
     */
    where: BookingPaymentWhereUniqueInput
  }

  /**
   * BookingPayment findUniqueOrThrow
   */
  export type BookingPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingPayment
     */
    select?: BookingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingPayment
     */
    omit?: BookingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingPaymentInclude<ExtArgs> | null
    /**
     * Filter, which BookingPayment to fetch.
     */
    where: BookingPaymentWhereUniqueInput
  }

  /**
   * BookingPayment findFirst
   */
  export type BookingPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingPayment
     */
    select?: BookingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingPayment
     */
    omit?: BookingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingPaymentInclude<ExtArgs> | null
    /**
     * Filter, which BookingPayment to fetch.
     */
    where?: BookingPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingPayments to fetch.
     */
    orderBy?: BookingPaymentOrderByWithRelationInput | BookingPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingPayments.
     */
    cursor?: BookingPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingPayments.
     */
    distinct?: BookingPaymentScalarFieldEnum | BookingPaymentScalarFieldEnum[]
  }

  /**
   * BookingPayment findFirstOrThrow
   */
  export type BookingPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingPayment
     */
    select?: BookingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingPayment
     */
    omit?: BookingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingPaymentInclude<ExtArgs> | null
    /**
     * Filter, which BookingPayment to fetch.
     */
    where?: BookingPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingPayments to fetch.
     */
    orderBy?: BookingPaymentOrderByWithRelationInput | BookingPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingPayments.
     */
    cursor?: BookingPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingPayments.
     */
    distinct?: BookingPaymentScalarFieldEnum | BookingPaymentScalarFieldEnum[]
  }

  /**
   * BookingPayment findMany
   */
  export type BookingPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingPayment
     */
    select?: BookingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingPayment
     */
    omit?: BookingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingPaymentInclude<ExtArgs> | null
    /**
     * Filter, which BookingPayments to fetch.
     */
    where?: BookingPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingPayments to fetch.
     */
    orderBy?: BookingPaymentOrderByWithRelationInput | BookingPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookingPayments.
     */
    cursor?: BookingPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingPayments.
     */
    skip?: number
    distinct?: BookingPaymentScalarFieldEnum | BookingPaymentScalarFieldEnum[]
  }

  /**
   * BookingPayment create
   */
  export type BookingPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingPayment
     */
    select?: BookingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingPayment
     */
    omit?: BookingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a BookingPayment.
     */
    data: XOR<BookingPaymentCreateInput, BookingPaymentUncheckedCreateInput>
  }

  /**
   * BookingPayment createMany
   */
  export type BookingPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookingPayments.
     */
    data: BookingPaymentCreateManyInput | BookingPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookingPayment createManyAndReturn
   */
  export type BookingPaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingPayment
     */
    select?: BookingPaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingPayment
     */
    omit?: BookingPaymentOmit<ExtArgs> | null
    /**
     * The data used to create many BookingPayments.
     */
    data: BookingPaymentCreateManyInput | BookingPaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingPaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingPayment update
   */
  export type BookingPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingPayment
     */
    select?: BookingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingPayment
     */
    omit?: BookingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a BookingPayment.
     */
    data: XOR<BookingPaymentUpdateInput, BookingPaymentUncheckedUpdateInput>
    /**
     * Choose, which BookingPayment to update.
     */
    where: BookingPaymentWhereUniqueInput
  }

  /**
   * BookingPayment updateMany
   */
  export type BookingPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookingPayments.
     */
    data: XOR<BookingPaymentUpdateManyMutationInput, BookingPaymentUncheckedUpdateManyInput>
    /**
     * Filter which BookingPayments to update
     */
    where?: BookingPaymentWhereInput
    /**
     * Limit how many BookingPayments to update.
     */
    limit?: number
  }

  /**
   * BookingPayment updateManyAndReturn
   */
  export type BookingPaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingPayment
     */
    select?: BookingPaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingPayment
     */
    omit?: BookingPaymentOmit<ExtArgs> | null
    /**
     * The data used to update BookingPayments.
     */
    data: XOR<BookingPaymentUpdateManyMutationInput, BookingPaymentUncheckedUpdateManyInput>
    /**
     * Filter which BookingPayments to update
     */
    where?: BookingPaymentWhereInput
    /**
     * Limit how many BookingPayments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingPaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingPayment upsert
   */
  export type BookingPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingPayment
     */
    select?: BookingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingPayment
     */
    omit?: BookingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the BookingPayment to update in case it exists.
     */
    where: BookingPaymentWhereUniqueInput
    /**
     * In case the BookingPayment found by the `where` argument doesn't exist, create a new BookingPayment with this data.
     */
    create: XOR<BookingPaymentCreateInput, BookingPaymentUncheckedCreateInput>
    /**
     * In case the BookingPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingPaymentUpdateInput, BookingPaymentUncheckedUpdateInput>
  }

  /**
   * BookingPayment delete
   */
  export type BookingPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingPayment
     */
    select?: BookingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingPayment
     */
    omit?: BookingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingPaymentInclude<ExtArgs> | null
    /**
     * Filter which BookingPayment to delete.
     */
    where: BookingPaymentWhereUniqueInput
  }

  /**
   * BookingPayment deleteMany
   */
  export type BookingPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingPayments to delete
     */
    where?: BookingPaymentWhereInput
    /**
     * Limit how many BookingPayments to delete.
     */
    limit?: number
  }

  /**
   * BookingPayment.paymentTransactions
   */
  export type BookingPayment$paymentTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    where?: PaymentTransactionWhereInput
    orderBy?: PaymentTransactionOrderByWithRelationInput | PaymentTransactionOrderByWithRelationInput[]
    cursor?: PaymentTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentTransactionScalarFieldEnum | PaymentTransactionScalarFieldEnum[]
  }

  /**
   * BookingPayment.refundTransactions
   */
  export type BookingPayment$refundTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundTransaction
     */
    select?: RefundTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundTransaction
     */
    omit?: RefundTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundTransactionInclude<ExtArgs> | null
    where?: RefundTransactionWhereInput
    orderBy?: RefundTransactionOrderByWithRelationInput | RefundTransactionOrderByWithRelationInput[]
    cursor?: RefundTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefundTransactionScalarFieldEnum | RefundTransactionScalarFieldEnum[]
  }

  /**
   * BookingPayment without action
   */
  export type BookingPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingPayment
     */
    select?: BookingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingPayment
     */
    omit?: BookingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingPaymentInclude<ExtArgs> | null
  }


  /**
   * Model PaymentTransaction
   */

  export type AggregatePaymentTransaction = {
    _count: PaymentTransactionCountAggregateOutputType | null
    _avg: PaymentTransactionAvgAggregateOutputType | null
    _sum: PaymentTransactionSumAggregateOutputType | null
    _min: PaymentTransactionMinAggregateOutputType | null
    _max: PaymentTransactionMaxAggregateOutputType | null
  }

  export type PaymentTransactionAvgAggregateOutputType = {
    id: number | null
    paymentId: number | null
    paymentMethodId: number | null
    amount: Decimal | null
  }

  export type PaymentTransactionSumAggregateOutputType = {
    id: number | null
    paymentId: number | null
    paymentMethodId: number | null
    amount: Decimal | null
  }

  export type PaymentTransactionMinAggregateOutputType = {
    id: number | null
    paymentId: number | null
    paymentMethodId: number | null
    transactionReference: string | null
    transactionType: string | null
    amount: Decimal | null
    currency: string | null
    transactionStatus: string | null
    gatewayResponse: string | null
    transactionData: string | null
    transactionTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentTransactionMaxAggregateOutputType = {
    id: number | null
    paymentId: number | null
    paymentMethodId: number | null
    transactionReference: string | null
    transactionType: string | null
    amount: Decimal | null
    currency: string | null
    transactionStatus: string | null
    gatewayResponse: string | null
    transactionData: string | null
    transactionTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentTransactionCountAggregateOutputType = {
    id: number
    paymentId: number
    paymentMethodId: number
    transactionReference: number
    transactionType: number
    amount: number
    currency: number
    transactionStatus: number
    gatewayResponse: number
    transactionData: number
    transactionTime: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentTransactionAvgAggregateInputType = {
    id?: true
    paymentId?: true
    paymentMethodId?: true
    amount?: true
  }

  export type PaymentTransactionSumAggregateInputType = {
    id?: true
    paymentId?: true
    paymentMethodId?: true
    amount?: true
  }

  export type PaymentTransactionMinAggregateInputType = {
    id?: true
    paymentId?: true
    paymentMethodId?: true
    transactionReference?: true
    transactionType?: true
    amount?: true
    currency?: true
    transactionStatus?: true
    gatewayResponse?: true
    transactionData?: true
    transactionTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentTransactionMaxAggregateInputType = {
    id?: true
    paymentId?: true
    paymentMethodId?: true
    transactionReference?: true
    transactionType?: true
    amount?: true
    currency?: true
    transactionStatus?: true
    gatewayResponse?: true
    transactionData?: true
    transactionTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentTransactionCountAggregateInputType = {
    id?: true
    paymentId?: true
    paymentMethodId?: true
    transactionReference?: true
    transactionType?: true
    amount?: true
    currency?: true
    transactionStatus?: true
    gatewayResponse?: true
    transactionData?: true
    transactionTime?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentTransaction to aggregate.
     */
    where?: PaymentTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentTransactions to fetch.
     */
    orderBy?: PaymentTransactionOrderByWithRelationInput | PaymentTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentTransactions
    **/
    _count?: true | PaymentTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentTransactionMaxAggregateInputType
  }

  export type GetPaymentTransactionAggregateType<T extends PaymentTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentTransaction[P]>
      : GetScalarType<T[P], AggregatePaymentTransaction[P]>
  }




  export type PaymentTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentTransactionWhereInput
    orderBy?: PaymentTransactionOrderByWithAggregationInput | PaymentTransactionOrderByWithAggregationInput[]
    by: PaymentTransactionScalarFieldEnum[] | PaymentTransactionScalarFieldEnum
    having?: PaymentTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentTransactionCountAggregateInputType | true
    _avg?: PaymentTransactionAvgAggregateInputType
    _sum?: PaymentTransactionSumAggregateInputType
    _min?: PaymentTransactionMinAggregateInputType
    _max?: PaymentTransactionMaxAggregateInputType
  }

  export type PaymentTransactionGroupByOutputType = {
    id: number
    paymentId: number
    paymentMethodId: number
    transactionReference: string | null
    transactionType: string
    amount: Decimal
    currency: string
    transactionStatus: string
    gatewayResponse: string | null
    transactionData: string | null
    transactionTime: Date | null
    createdAt: Date
    updatedAt: Date | null
    _count: PaymentTransactionCountAggregateOutputType | null
    _avg: PaymentTransactionAvgAggregateOutputType | null
    _sum: PaymentTransactionSumAggregateOutputType | null
    _min: PaymentTransactionMinAggregateOutputType | null
    _max: PaymentTransactionMaxAggregateOutputType | null
  }

  type GetPaymentTransactionGroupByPayload<T extends PaymentTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentTransactionGroupByOutputType[P]>
        }
      >
    >


  export type PaymentTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentId?: boolean
    paymentMethodId?: boolean
    transactionReference?: boolean
    transactionType?: boolean
    amount?: boolean
    currency?: boolean
    transactionStatus?: boolean
    gatewayResponse?: boolean
    transactionData?: boolean
    transactionTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookingPayment?: boolean | BookingPaymentDefaultArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentTransaction"]>

  export type PaymentTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentId?: boolean
    paymentMethodId?: boolean
    transactionReference?: boolean
    transactionType?: boolean
    amount?: boolean
    currency?: boolean
    transactionStatus?: boolean
    gatewayResponse?: boolean
    transactionData?: boolean
    transactionTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookingPayment?: boolean | BookingPaymentDefaultArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentTransaction"]>

  export type PaymentTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentId?: boolean
    paymentMethodId?: boolean
    transactionReference?: boolean
    transactionType?: boolean
    amount?: boolean
    currency?: boolean
    transactionStatus?: boolean
    gatewayResponse?: boolean
    transactionData?: boolean
    transactionTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookingPayment?: boolean | BookingPaymentDefaultArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentTransaction"]>

  export type PaymentTransactionSelectScalar = {
    id?: boolean
    paymentId?: boolean
    paymentMethodId?: boolean
    transactionReference?: boolean
    transactionType?: boolean
    amount?: boolean
    currency?: boolean
    transactionStatus?: boolean
    gatewayResponse?: boolean
    transactionData?: boolean
    transactionTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "paymentId" | "paymentMethodId" | "transactionReference" | "transactionType" | "amount" | "currency" | "transactionStatus" | "gatewayResponse" | "transactionData" | "transactionTime" | "createdAt" | "updatedAt", ExtArgs["result"]["paymentTransaction"]>
  export type PaymentTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingPayment?: boolean | BookingPaymentDefaultArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
  }
  export type PaymentTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingPayment?: boolean | BookingPaymentDefaultArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
  }
  export type PaymentTransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingPayment?: boolean | BookingPaymentDefaultArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
  }

  export type $PaymentTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentTransaction"
    objects: {
      bookingPayment: Prisma.$BookingPaymentPayload<ExtArgs>
      paymentMethod: Prisma.$PaymentMethodPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      paymentId: number
      paymentMethodId: number
      transactionReference: string | null
      transactionType: string
      amount: Prisma.Decimal
      currency: string
      transactionStatus: string
      gatewayResponse: string | null
      transactionData: string | null
      transactionTime: Date | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["paymentTransaction"]>
    composites: {}
  }

  type PaymentTransactionGetPayload<S extends boolean | null | undefined | PaymentTransactionDefaultArgs> = $Result.GetResult<Prisma.$PaymentTransactionPayload, S>

  type PaymentTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentTransactionCountAggregateInputType | true
    }

  export interface PaymentTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentTransaction'], meta: { name: 'PaymentTransaction' } }
    /**
     * Find zero or one PaymentTransaction that matches the filter.
     * @param {PaymentTransactionFindUniqueArgs} args - Arguments to find a PaymentTransaction
     * @example
     * // Get one PaymentTransaction
     * const paymentTransaction = await prisma.paymentTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentTransactionFindUniqueArgs>(args: SelectSubset<T, PaymentTransactionFindUniqueArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentTransactionFindUniqueOrThrowArgs} args - Arguments to find a PaymentTransaction
     * @example
     * // Get one PaymentTransaction
     * const paymentTransaction = await prisma.paymentTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionFindFirstArgs} args - Arguments to find a PaymentTransaction
     * @example
     * // Get one PaymentTransaction
     * const paymentTransaction = await prisma.paymentTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentTransactionFindFirstArgs>(args?: SelectSubset<T, PaymentTransactionFindFirstArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionFindFirstOrThrowArgs} args - Arguments to find a PaymentTransaction
     * @example
     * // Get one PaymentTransaction
     * const paymentTransaction = await prisma.paymentTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentTransactions
     * const paymentTransactions = await prisma.paymentTransaction.findMany()
     * 
     * // Get first 10 PaymentTransactions
     * const paymentTransactions = await prisma.paymentTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentTransactionWithIdOnly = await prisma.paymentTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentTransactionFindManyArgs>(args?: SelectSubset<T, PaymentTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentTransaction.
     * @param {PaymentTransactionCreateArgs} args - Arguments to create a PaymentTransaction.
     * @example
     * // Create one PaymentTransaction
     * const PaymentTransaction = await prisma.paymentTransaction.create({
     *   data: {
     *     // ... data to create a PaymentTransaction
     *   }
     * })
     * 
     */
    create<T extends PaymentTransactionCreateArgs>(args: SelectSubset<T, PaymentTransactionCreateArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentTransactions.
     * @param {PaymentTransactionCreateManyArgs} args - Arguments to create many PaymentTransactions.
     * @example
     * // Create many PaymentTransactions
     * const paymentTransaction = await prisma.paymentTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentTransactionCreateManyArgs>(args?: SelectSubset<T, PaymentTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentTransactions and returns the data saved in the database.
     * @param {PaymentTransactionCreateManyAndReturnArgs} args - Arguments to create many PaymentTransactions.
     * @example
     * // Create many PaymentTransactions
     * const paymentTransaction = await prisma.paymentTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentTransactions and only return the `id`
     * const paymentTransactionWithIdOnly = await prisma.paymentTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentTransaction.
     * @param {PaymentTransactionDeleteArgs} args - Arguments to delete one PaymentTransaction.
     * @example
     * // Delete one PaymentTransaction
     * const PaymentTransaction = await prisma.paymentTransaction.delete({
     *   where: {
     *     // ... filter to delete one PaymentTransaction
     *   }
     * })
     * 
     */
    delete<T extends PaymentTransactionDeleteArgs>(args: SelectSubset<T, PaymentTransactionDeleteArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentTransaction.
     * @param {PaymentTransactionUpdateArgs} args - Arguments to update one PaymentTransaction.
     * @example
     * // Update one PaymentTransaction
     * const paymentTransaction = await prisma.paymentTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentTransactionUpdateArgs>(args: SelectSubset<T, PaymentTransactionUpdateArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentTransactions.
     * @param {PaymentTransactionDeleteManyArgs} args - Arguments to filter PaymentTransactions to delete.
     * @example
     * // Delete a few PaymentTransactions
     * const { count } = await prisma.paymentTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentTransactionDeleteManyArgs>(args?: SelectSubset<T, PaymentTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentTransactions
     * const paymentTransaction = await prisma.paymentTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentTransactionUpdateManyArgs>(args: SelectSubset<T, PaymentTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentTransactions and returns the data updated in the database.
     * @param {PaymentTransactionUpdateManyAndReturnArgs} args - Arguments to update many PaymentTransactions.
     * @example
     * // Update many PaymentTransactions
     * const paymentTransaction = await prisma.paymentTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentTransactions and only return the `id`
     * const paymentTransactionWithIdOnly = await prisma.paymentTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentTransaction.
     * @param {PaymentTransactionUpsertArgs} args - Arguments to update or create a PaymentTransaction.
     * @example
     * // Update or create a PaymentTransaction
     * const paymentTransaction = await prisma.paymentTransaction.upsert({
     *   create: {
     *     // ... data to create a PaymentTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentTransaction we want to update
     *   }
     * })
     */
    upsert<T extends PaymentTransactionUpsertArgs>(args: SelectSubset<T, PaymentTransactionUpsertArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionCountArgs} args - Arguments to filter PaymentTransactions to count.
     * @example
     * // Count the number of PaymentTransactions
     * const count = await prisma.paymentTransaction.count({
     *   where: {
     *     // ... the filter for the PaymentTransactions we want to count
     *   }
     * })
    **/
    count<T extends PaymentTransactionCountArgs>(
      args?: Subset<T, PaymentTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentTransactionAggregateArgs>(args: Subset<T, PaymentTransactionAggregateArgs>): Prisma.PrismaPromise<GetPaymentTransactionAggregateType<T>>

    /**
     * Group by PaymentTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentTransactionGroupByArgs['orderBy'] }
        : { orderBy?: PaymentTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentTransaction model
   */
  readonly fields: PaymentTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookingPayment<T extends BookingPaymentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingPaymentDefaultArgs<ExtArgs>>): Prisma__BookingPaymentClient<$Result.GetResult<Prisma.$BookingPaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    paymentMethod<T extends PaymentMethodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentMethodDefaultArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentTransaction model
   */
  interface PaymentTransactionFieldRefs {
    readonly id: FieldRef<"PaymentTransaction", 'Int'>
    readonly paymentId: FieldRef<"PaymentTransaction", 'Int'>
    readonly paymentMethodId: FieldRef<"PaymentTransaction", 'Int'>
    readonly transactionReference: FieldRef<"PaymentTransaction", 'String'>
    readonly transactionType: FieldRef<"PaymentTransaction", 'String'>
    readonly amount: FieldRef<"PaymentTransaction", 'Decimal'>
    readonly currency: FieldRef<"PaymentTransaction", 'String'>
    readonly transactionStatus: FieldRef<"PaymentTransaction", 'String'>
    readonly gatewayResponse: FieldRef<"PaymentTransaction", 'String'>
    readonly transactionData: FieldRef<"PaymentTransaction", 'String'>
    readonly transactionTime: FieldRef<"PaymentTransaction", 'DateTime'>
    readonly createdAt: FieldRef<"PaymentTransaction", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentTransaction findUnique
   */
  export type PaymentTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PaymentTransaction to fetch.
     */
    where: PaymentTransactionWhereUniqueInput
  }

  /**
   * PaymentTransaction findUniqueOrThrow
   */
  export type PaymentTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PaymentTransaction to fetch.
     */
    where: PaymentTransactionWhereUniqueInput
  }

  /**
   * PaymentTransaction findFirst
   */
  export type PaymentTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PaymentTransaction to fetch.
     */
    where?: PaymentTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentTransactions to fetch.
     */
    orderBy?: PaymentTransactionOrderByWithRelationInput | PaymentTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentTransactions.
     */
    cursor?: PaymentTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentTransactions.
     */
    distinct?: PaymentTransactionScalarFieldEnum | PaymentTransactionScalarFieldEnum[]
  }

  /**
   * PaymentTransaction findFirstOrThrow
   */
  export type PaymentTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PaymentTransaction to fetch.
     */
    where?: PaymentTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentTransactions to fetch.
     */
    orderBy?: PaymentTransactionOrderByWithRelationInput | PaymentTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentTransactions.
     */
    cursor?: PaymentTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentTransactions.
     */
    distinct?: PaymentTransactionScalarFieldEnum | PaymentTransactionScalarFieldEnum[]
  }

  /**
   * PaymentTransaction findMany
   */
  export type PaymentTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PaymentTransactions to fetch.
     */
    where?: PaymentTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentTransactions to fetch.
     */
    orderBy?: PaymentTransactionOrderByWithRelationInput | PaymentTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentTransactions.
     */
    cursor?: PaymentTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentTransactions.
     */
    skip?: number
    distinct?: PaymentTransactionScalarFieldEnum | PaymentTransactionScalarFieldEnum[]
  }

  /**
   * PaymentTransaction create
   */
  export type PaymentTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentTransaction.
     */
    data: XOR<PaymentTransactionCreateInput, PaymentTransactionUncheckedCreateInput>
  }

  /**
   * PaymentTransaction createMany
   */
  export type PaymentTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentTransactions.
     */
    data: PaymentTransactionCreateManyInput | PaymentTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentTransaction createManyAndReturn
   */
  export type PaymentTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentTransactions.
     */
    data: PaymentTransactionCreateManyInput | PaymentTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentTransaction update
   */
  export type PaymentTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentTransaction.
     */
    data: XOR<PaymentTransactionUpdateInput, PaymentTransactionUncheckedUpdateInput>
    /**
     * Choose, which PaymentTransaction to update.
     */
    where: PaymentTransactionWhereUniqueInput
  }

  /**
   * PaymentTransaction updateMany
   */
  export type PaymentTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentTransactions.
     */
    data: XOR<PaymentTransactionUpdateManyMutationInput, PaymentTransactionUncheckedUpdateManyInput>
    /**
     * Filter which PaymentTransactions to update
     */
    where?: PaymentTransactionWhereInput
    /**
     * Limit how many PaymentTransactions to update.
     */
    limit?: number
  }

  /**
   * PaymentTransaction updateManyAndReturn
   */
  export type PaymentTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * The data used to update PaymentTransactions.
     */
    data: XOR<PaymentTransactionUpdateManyMutationInput, PaymentTransactionUncheckedUpdateManyInput>
    /**
     * Filter which PaymentTransactions to update
     */
    where?: PaymentTransactionWhereInput
    /**
     * Limit how many PaymentTransactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentTransaction upsert
   */
  export type PaymentTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentTransaction to update in case it exists.
     */
    where: PaymentTransactionWhereUniqueInput
    /**
     * In case the PaymentTransaction found by the `where` argument doesn't exist, create a new PaymentTransaction with this data.
     */
    create: XOR<PaymentTransactionCreateInput, PaymentTransactionUncheckedCreateInput>
    /**
     * In case the PaymentTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentTransactionUpdateInput, PaymentTransactionUncheckedUpdateInput>
  }

  /**
   * PaymentTransaction delete
   */
  export type PaymentTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * Filter which PaymentTransaction to delete.
     */
    where: PaymentTransactionWhereUniqueInput
  }

  /**
   * PaymentTransaction deleteMany
   */
  export type PaymentTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentTransactions to delete
     */
    where?: PaymentTransactionWhereInput
    /**
     * Limit how many PaymentTransactions to delete.
     */
    limit?: number
  }

  /**
   * PaymentTransaction without action
   */
  export type PaymentTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
  }


  /**
   * Model RefundTransaction
   */

  export type AggregateRefundTransaction = {
    _count: RefundTransactionCountAggregateOutputType | null
    _avg: RefundTransactionAvgAggregateOutputType | null
    _sum: RefundTransactionSumAggregateOutputType | null
    _min: RefundTransactionMinAggregateOutputType | null
    _max: RefundTransactionMaxAggregateOutputType | null
  }

  export type RefundTransactionAvgAggregateOutputType = {
    id: number | null
    paymentId: number | null
    refundAmount: Decimal | null
  }

  export type RefundTransactionSumAggregateOutputType = {
    id: number | null
    paymentId: number | null
    refundAmount: Decimal | null
  }

  export type RefundTransactionMinAggregateOutputType = {
    id: number | null
    paymentId: number | null
    refundReference: string | null
    refundAmount: Decimal | null
    refundReason: string | null
    refundStatus: string | null
    processorResponse: string | null
    refundData: string | null
    refundTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RefundTransactionMaxAggregateOutputType = {
    id: number | null
    paymentId: number | null
    refundReference: string | null
    refundAmount: Decimal | null
    refundReason: string | null
    refundStatus: string | null
    processorResponse: string | null
    refundData: string | null
    refundTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RefundTransactionCountAggregateOutputType = {
    id: number
    paymentId: number
    refundReference: number
    refundAmount: number
    refundReason: number
    refundStatus: number
    processorResponse: number
    refundData: number
    refundTime: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RefundTransactionAvgAggregateInputType = {
    id?: true
    paymentId?: true
    refundAmount?: true
  }

  export type RefundTransactionSumAggregateInputType = {
    id?: true
    paymentId?: true
    refundAmount?: true
  }

  export type RefundTransactionMinAggregateInputType = {
    id?: true
    paymentId?: true
    refundReference?: true
    refundAmount?: true
    refundReason?: true
    refundStatus?: true
    processorResponse?: true
    refundData?: true
    refundTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RefundTransactionMaxAggregateInputType = {
    id?: true
    paymentId?: true
    refundReference?: true
    refundAmount?: true
    refundReason?: true
    refundStatus?: true
    processorResponse?: true
    refundData?: true
    refundTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RefundTransactionCountAggregateInputType = {
    id?: true
    paymentId?: true
    refundReference?: true
    refundAmount?: true
    refundReason?: true
    refundStatus?: true
    processorResponse?: true
    refundData?: true
    refundTime?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RefundTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefundTransaction to aggregate.
     */
    where?: RefundTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefundTransactions to fetch.
     */
    orderBy?: RefundTransactionOrderByWithRelationInput | RefundTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefundTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefundTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefundTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefundTransactions
    **/
    _count?: true | RefundTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RefundTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RefundTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefundTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefundTransactionMaxAggregateInputType
  }

  export type GetRefundTransactionAggregateType<T extends RefundTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateRefundTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefundTransaction[P]>
      : GetScalarType<T[P], AggregateRefundTransaction[P]>
  }




  export type RefundTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefundTransactionWhereInput
    orderBy?: RefundTransactionOrderByWithAggregationInput | RefundTransactionOrderByWithAggregationInput[]
    by: RefundTransactionScalarFieldEnum[] | RefundTransactionScalarFieldEnum
    having?: RefundTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefundTransactionCountAggregateInputType | true
    _avg?: RefundTransactionAvgAggregateInputType
    _sum?: RefundTransactionSumAggregateInputType
    _min?: RefundTransactionMinAggregateInputType
    _max?: RefundTransactionMaxAggregateInputType
  }

  export type RefundTransactionGroupByOutputType = {
    id: number
    paymentId: number
    refundReference: string | null
    refundAmount: Decimal
    refundReason: string | null
    refundStatus: string
    processorResponse: string | null
    refundData: string | null
    refundTime: Date | null
    createdAt: Date
    updatedAt: Date | null
    _count: RefundTransactionCountAggregateOutputType | null
    _avg: RefundTransactionAvgAggregateOutputType | null
    _sum: RefundTransactionSumAggregateOutputType | null
    _min: RefundTransactionMinAggregateOutputType | null
    _max: RefundTransactionMaxAggregateOutputType | null
  }

  type GetRefundTransactionGroupByPayload<T extends RefundTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefundTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefundTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefundTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], RefundTransactionGroupByOutputType[P]>
        }
      >
    >


  export type RefundTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentId?: boolean
    refundReference?: boolean
    refundAmount?: boolean
    refundReason?: boolean
    refundStatus?: boolean
    processorResponse?: boolean
    refundData?: boolean
    refundTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookingPayment?: boolean | BookingPaymentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refundTransaction"]>

  export type RefundTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentId?: boolean
    refundReference?: boolean
    refundAmount?: boolean
    refundReason?: boolean
    refundStatus?: boolean
    processorResponse?: boolean
    refundData?: boolean
    refundTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookingPayment?: boolean | BookingPaymentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refundTransaction"]>

  export type RefundTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentId?: boolean
    refundReference?: boolean
    refundAmount?: boolean
    refundReason?: boolean
    refundStatus?: boolean
    processorResponse?: boolean
    refundData?: boolean
    refundTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookingPayment?: boolean | BookingPaymentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refundTransaction"]>

  export type RefundTransactionSelectScalar = {
    id?: boolean
    paymentId?: boolean
    refundReference?: boolean
    refundAmount?: boolean
    refundReason?: boolean
    refundStatus?: boolean
    processorResponse?: boolean
    refundData?: boolean
    refundTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RefundTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "paymentId" | "refundReference" | "refundAmount" | "refundReason" | "refundStatus" | "processorResponse" | "refundData" | "refundTime" | "createdAt" | "updatedAt", ExtArgs["result"]["refundTransaction"]>
  export type RefundTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingPayment?: boolean | BookingPaymentDefaultArgs<ExtArgs>
  }
  export type RefundTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingPayment?: boolean | BookingPaymentDefaultArgs<ExtArgs>
  }
  export type RefundTransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingPayment?: boolean | BookingPaymentDefaultArgs<ExtArgs>
  }

  export type $RefundTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefundTransaction"
    objects: {
      bookingPayment: Prisma.$BookingPaymentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      paymentId: number
      refundReference: string | null
      refundAmount: Prisma.Decimal
      refundReason: string | null
      refundStatus: string
      processorResponse: string | null
      refundData: string | null
      refundTime: Date | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["refundTransaction"]>
    composites: {}
  }

  type RefundTransactionGetPayload<S extends boolean | null | undefined | RefundTransactionDefaultArgs> = $Result.GetResult<Prisma.$RefundTransactionPayload, S>

  type RefundTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefundTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefundTransactionCountAggregateInputType | true
    }

  export interface RefundTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefundTransaction'], meta: { name: 'RefundTransaction' } }
    /**
     * Find zero or one RefundTransaction that matches the filter.
     * @param {RefundTransactionFindUniqueArgs} args - Arguments to find a RefundTransaction
     * @example
     * // Get one RefundTransaction
     * const refundTransaction = await prisma.refundTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefundTransactionFindUniqueArgs>(args: SelectSubset<T, RefundTransactionFindUniqueArgs<ExtArgs>>): Prisma__RefundTransactionClient<$Result.GetResult<Prisma.$RefundTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RefundTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefundTransactionFindUniqueOrThrowArgs} args - Arguments to find a RefundTransaction
     * @example
     * // Get one RefundTransaction
     * const refundTransaction = await prisma.refundTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefundTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, RefundTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefundTransactionClient<$Result.GetResult<Prisma.$RefundTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefundTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundTransactionFindFirstArgs} args - Arguments to find a RefundTransaction
     * @example
     * // Get one RefundTransaction
     * const refundTransaction = await prisma.refundTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefundTransactionFindFirstArgs>(args?: SelectSubset<T, RefundTransactionFindFirstArgs<ExtArgs>>): Prisma__RefundTransactionClient<$Result.GetResult<Prisma.$RefundTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefundTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundTransactionFindFirstOrThrowArgs} args - Arguments to find a RefundTransaction
     * @example
     * // Get one RefundTransaction
     * const refundTransaction = await prisma.refundTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefundTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, RefundTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefundTransactionClient<$Result.GetResult<Prisma.$RefundTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RefundTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefundTransactions
     * const refundTransactions = await prisma.refundTransaction.findMany()
     * 
     * // Get first 10 RefundTransactions
     * const refundTransactions = await prisma.refundTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refundTransactionWithIdOnly = await prisma.refundTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefundTransactionFindManyArgs>(args?: SelectSubset<T, RefundTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RefundTransaction.
     * @param {RefundTransactionCreateArgs} args - Arguments to create a RefundTransaction.
     * @example
     * // Create one RefundTransaction
     * const RefundTransaction = await prisma.refundTransaction.create({
     *   data: {
     *     // ... data to create a RefundTransaction
     *   }
     * })
     * 
     */
    create<T extends RefundTransactionCreateArgs>(args: SelectSubset<T, RefundTransactionCreateArgs<ExtArgs>>): Prisma__RefundTransactionClient<$Result.GetResult<Prisma.$RefundTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RefundTransactions.
     * @param {RefundTransactionCreateManyArgs} args - Arguments to create many RefundTransactions.
     * @example
     * // Create many RefundTransactions
     * const refundTransaction = await prisma.refundTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefundTransactionCreateManyArgs>(args?: SelectSubset<T, RefundTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefundTransactions and returns the data saved in the database.
     * @param {RefundTransactionCreateManyAndReturnArgs} args - Arguments to create many RefundTransactions.
     * @example
     * // Create many RefundTransactions
     * const refundTransaction = await prisma.refundTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefundTransactions and only return the `id`
     * const refundTransactionWithIdOnly = await prisma.refundTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefundTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, RefundTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RefundTransaction.
     * @param {RefundTransactionDeleteArgs} args - Arguments to delete one RefundTransaction.
     * @example
     * // Delete one RefundTransaction
     * const RefundTransaction = await prisma.refundTransaction.delete({
     *   where: {
     *     // ... filter to delete one RefundTransaction
     *   }
     * })
     * 
     */
    delete<T extends RefundTransactionDeleteArgs>(args: SelectSubset<T, RefundTransactionDeleteArgs<ExtArgs>>): Prisma__RefundTransactionClient<$Result.GetResult<Prisma.$RefundTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RefundTransaction.
     * @param {RefundTransactionUpdateArgs} args - Arguments to update one RefundTransaction.
     * @example
     * // Update one RefundTransaction
     * const refundTransaction = await prisma.refundTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefundTransactionUpdateArgs>(args: SelectSubset<T, RefundTransactionUpdateArgs<ExtArgs>>): Prisma__RefundTransactionClient<$Result.GetResult<Prisma.$RefundTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RefundTransactions.
     * @param {RefundTransactionDeleteManyArgs} args - Arguments to filter RefundTransactions to delete.
     * @example
     * // Delete a few RefundTransactions
     * const { count } = await prisma.refundTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefundTransactionDeleteManyArgs>(args?: SelectSubset<T, RefundTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefundTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefundTransactions
     * const refundTransaction = await prisma.refundTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefundTransactionUpdateManyArgs>(args: SelectSubset<T, RefundTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefundTransactions and returns the data updated in the database.
     * @param {RefundTransactionUpdateManyAndReturnArgs} args - Arguments to update many RefundTransactions.
     * @example
     * // Update many RefundTransactions
     * const refundTransaction = await prisma.refundTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RefundTransactions and only return the `id`
     * const refundTransactionWithIdOnly = await prisma.refundTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RefundTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, RefundTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RefundTransaction.
     * @param {RefundTransactionUpsertArgs} args - Arguments to update or create a RefundTransaction.
     * @example
     * // Update or create a RefundTransaction
     * const refundTransaction = await prisma.refundTransaction.upsert({
     *   create: {
     *     // ... data to create a RefundTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefundTransaction we want to update
     *   }
     * })
     */
    upsert<T extends RefundTransactionUpsertArgs>(args: SelectSubset<T, RefundTransactionUpsertArgs<ExtArgs>>): Prisma__RefundTransactionClient<$Result.GetResult<Prisma.$RefundTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RefundTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundTransactionCountArgs} args - Arguments to filter RefundTransactions to count.
     * @example
     * // Count the number of RefundTransactions
     * const count = await prisma.refundTransaction.count({
     *   where: {
     *     // ... the filter for the RefundTransactions we want to count
     *   }
     * })
    **/
    count<T extends RefundTransactionCountArgs>(
      args?: Subset<T, RefundTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefundTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefundTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefundTransactionAggregateArgs>(args: Subset<T, RefundTransactionAggregateArgs>): Prisma.PrismaPromise<GetRefundTransactionAggregateType<T>>

    /**
     * Group by RefundTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefundTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefundTransactionGroupByArgs['orderBy'] }
        : { orderBy?: RefundTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefundTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefundTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefundTransaction model
   */
  readonly fields: RefundTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefundTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefundTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookingPayment<T extends BookingPaymentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingPaymentDefaultArgs<ExtArgs>>): Prisma__BookingPaymentClient<$Result.GetResult<Prisma.$BookingPaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefundTransaction model
   */
  interface RefundTransactionFieldRefs {
    readonly id: FieldRef<"RefundTransaction", 'Int'>
    readonly paymentId: FieldRef<"RefundTransaction", 'Int'>
    readonly refundReference: FieldRef<"RefundTransaction", 'String'>
    readonly refundAmount: FieldRef<"RefundTransaction", 'Decimal'>
    readonly refundReason: FieldRef<"RefundTransaction", 'String'>
    readonly refundStatus: FieldRef<"RefundTransaction", 'String'>
    readonly processorResponse: FieldRef<"RefundTransaction", 'String'>
    readonly refundData: FieldRef<"RefundTransaction", 'String'>
    readonly refundTime: FieldRef<"RefundTransaction", 'DateTime'>
    readonly createdAt: FieldRef<"RefundTransaction", 'DateTime'>
    readonly updatedAt: FieldRef<"RefundTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefundTransaction findUnique
   */
  export type RefundTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundTransaction
     */
    select?: RefundTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundTransaction
     */
    omit?: RefundTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundTransactionInclude<ExtArgs> | null
    /**
     * Filter, which RefundTransaction to fetch.
     */
    where: RefundTransactionWhereUniqueInput
  }

  /**
   * RefundTransaction findUniqueOrThrow
   */
  export type RefundTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundTransaction
     */
    select?: RefundTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundTransaction
     */
    omit?: RefundTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundTransactionInclude<ExtArgs> | null
    /**
     * Filter, which RefundTransaction to fetch.
     */
    where: RefundTransactionWhereUniqueInput
  }

  /**
   * RefundTransaction findFirst
   */
  export type RefundTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundTransaction
     */
    select?: RefundTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundTransaction
     */
    omit?: RefundTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundTransactionInclude<ExtArgs> | null
    /**
     * Filter, which RefundTransaction to fetch.
     */
    where?: RefundTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefundTransactions to fetch.
     */
    orderBy?: RefundTransactionOrderByWithRelationInput | RefundTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefundTransactions.
     */
    cursor?: RefundTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefundTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefundTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefundTransactions.
     */
    distinct?: RefundTransactionScalarFieldEnum | RefundTransactionScalarFieldEnum[]
  }

  /**
   * RefundTransaction findFirstOrThrow
   */
  export type RefundTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundTransaction
     */
    select?: RefundTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundTransaction
     */
    omit?: RefundTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundTransactionInclude<ExtArgs> | null
    /**
     * Filter, which RefundTransaction to fetch.
     */
    where?: RefundTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefundTransactions to fetch.
     */
    orderBy?: RefundTransactionOrderByWithRelationInput | RefundTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefundTransactions.
     */
    cursor?: RefundTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefundTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefundTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefundTransactions.
     */
    distinct?: RefundTransactionScalarFieldEnum | RefundTransactionScalarFieldEnum[]
  }

  /**
   * RefundTransaction findMany
   */
  export type RefundTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundTransaction
     */
    select?: RefundTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundTransaction
     */
    omit?: RefundTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundTransactionInclude<ExtArgs> | null
    /**
     * Filter, which RefundTransactions to fetch.
     */
    where?: RefundTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefundTransactions to fetch.
     */
    orderBy?: RefundTransactionOrderByWithRelationInput | RefundTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefundTransactions.
     */
    cursor?: RefundTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefundTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefundTransactions.
     */
    skip?: number
    distinct?: RefundTransactionScalarFieldEnum | RefundTransactionScalarFieldEnum[]
  }

  /**
   * RefundTransaction create
   */
  export type RefundTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundTransaction
     */
    select?: RefundTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundTransaction
     */
    omit?: RefundTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a RefundTransaction.
     */
    data: XOR<RefundTransactionCreateInput, RefundTransactionUncheckedCreateInput>
  }

  /**
   * RefundTransaction createMany
   */
  export type RefundTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefundTransactions.
     */
    data: RefundTransactionCreateManyInput | RefundTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefundTransaction createManyAndReturn
   */
  export type RefundTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundTransaction
     */
    select?: RefundTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefundTransaction
     */
    omit?: RefundTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many RefundTransactions.
     */
    data: RefundTransactionCreateManyInput | RefundTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefundTransaction update
   */
  export type RefundTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundTransaction
     */
    select?: RefundTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundTransaction
     */
    omit?: RefundTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a RefundTransaction.
     */
    data: XOR<RefundTransactionUpdateInput, RefundTransactionUncheckedUpdateInput>
    /**
     * Choose, which RefundTransaction to update.
     */
    where: RefundTransactionWhereUniqueInput
  }

  /**
   * RefundTransaction updateMany
   */
  export type RefundTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefundTransactions.
     */
    data: XOR<RefundTransactionUpdateManyMutationInput, RefundTransactionUncheckedUpdateManyInput>
    /**
     * Filter which RefundTransactions to update
     */
    where?: RefundTransactionWhereInput
    /**
     * Limit how many RefundTransactions to update.
     */
    limit?: number
  }

  /**
   * RefundTransaction updateManyAndReturn
   */
  export type RefundTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundTransaction
     */
    select?: RefundTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefundTransaction
     */
    omit?: RefundTransactionOmit<ExtArgs> | null
    /**
     * The data used to update RefundTransactions.
     */
    data: XOR<RefundTransactionUpdateManyMutationInput, RefundTransactionUncheckedUpdateManyInput>
    /**
     * Filter which RefundTransactions to update
     */
    where?: RefundTransactionWhereInput
    /**
     * Limit how many RefundTransactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundTransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefundTransaction upsert
   */
  export type RefundTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundTransaction
     */
    select?: RefundTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundTransaction
     */
    omit?: RefundTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the RefundTransaction to update in case it exists.
     */
    where: RefundTransactionWhereUniqueInput
    /**
     * In case the RefundTransaction found by the `where` argument doesn't exist, create a new RefundTransaction with this data.
     */
    create: XOR<RefundTransactionCreateInput, RefundTransactionUncheckedCreateInput>
    /**
     * In case the RefundTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefundTransactionUpdateInput, RefundTransactionUncheckedUpdateInput>
  }

  /**
   * RefundTransaction delete
   */
  export type RefundTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundTransaction
     */
    select?: RefundTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundTransaction
     */
    omit?: RefundTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundTransactionInclude<ExtArgs> | null
    /**
     * Filter which RefundTransaction to delete.
     */
    where: RefundTransactionWhereUniqueInput
  }

  /**
   * RefundTransaction deleteMany
   */
  export type RefundTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefundTransactions to delete
     */
    where?: RefundTransactionWhereInput
    /**
     * Limit how many RefundTransactions to delete.
     */
    limit?: number
  }

  /**
   * RefundTransaction without action
   */
  export type RefundTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundTransaction
     */
    select?: RefundTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundTransaction
     */
    omit?: RefundTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundTransactionInclude<ExtArgs> | null
  }


  /**
   * Model PaymentMethod
   */

  export type AggregatePaymentMethod = {
    _count: PaymentMethodCountAggregateOutputType | null
    _avg: PaymentMethodAvgAggregateOutputType | null
    _sum: PaymentMethodSumAggregateOutputType | null
    _min: PaymentMethodMinAggregateOutputType | null
    _max: PaymentMethodMaxAggregateOutputType | null
  }

  export type PaymentMethodAvgAggregateOutputType = {
    id: number | null
    processingFeePercent: Decimal | null
    fixedFee: Decimal | null
  }

  export type PaymentMethodSumAggregateOutputType = {
    id: number | null
    processingFeePercent: Decimal | null
    fixedFee: Decimal | null
  }

  export type PaymentMethodMinAggregateOutputType = {
    id: number | null
    methodName: string | null
    provider: string | null
    methodType: string | null
    description: string | null
    processingFeePercent: Decimal | null
    fixedFee: Decimal | null
    supportsRefunds: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMethodMaxAggregateOutputType = {
    id: number | null
    methodName: string | null
    provider: string | null
    methodType: string | null
    description: string | null
    processingFeePercent: Decimal | null
    fixedFee: Decimal | null
    supportsRefunds: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMethodCountAggregateOutputType = {
    id: number
    methodName: number
    provider: number
    methodType: number
    description: number
    processingFeePercent: number
    fixedFee: number
    supportsRefunds: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentMethodAvgAggregateInputType = {
    id?: true
    processingFeePercent?: true
    fixedFee?: true
  }

  export type PaymentMethodSumAggregateInputType = {
    id?: true
    processingFeePercent?: true
    fixedFee?: true
  }

  export type PaymentMethodMinAggregateInputType = {
    id?: true
    methodName?: true
    provider?: true
    methodType?: true
    description?: true
    processingFeePercent?: true
    fixedFee?: true
    supportsRefunds?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMethodMaxAggregateInputType = {
    id?: true
    methodName?: true
    provider?: true
    methodType?: true
    description?: true
    processingFeePercent?: true
    fixedFee?: true
    supportsRefunds?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMethodCountAggregateInputType = {
    id?: true
    methodName?: true
    provider?: true
    methodType?: true
    description?: true
    processingFeePercent?: true
    fixedFee?: true
    supportsRefunds?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentMethodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethod to aggregate.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentMethods
    **/
    _count?: true | PaymentMethodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentMethodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentMethodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMethodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMethodMaxAggregateInputType
  }

  export type GetPaymentMethodAggregateType<T extends PaymentMethodAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentMethod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentMethod[P]>
      : GetScalarType<T[P], AggregatePaymentMethod[P]>
  }




  export type PaymentMethodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentMethodWhereInput
    orderBy?: PaymentMethodOrderByWithAggregationInput | PaymentMethodOrderByWithAggregationInput[]
    by: PaymentMethodScalarFieldEnum[] | PaymentMethodScalarFieldEnum
    having?: PaymentMethodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentMethodCountAggregateInputType | true
    _avg?: PaymentMethodAvgAggregateInputType
    _sum?: PaymentMethodSumAggregateInputType
    _min?: PaymentMethodMinAggregateInputType
    _max?: PaymentMethodMaxAggregateInputType
  }

  export type PaymentMethodGroupByOutputType = {
    id: number
    methodName: string
    provider: string
    methodType: string
    description: string | null
    processingFeePercent: Decimal
    fixedFee: Decimal
    supportsRefunds: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date | null
    _count: PaymentMethodCountAggregateOutputType | null
    _avg: PaymentMethodAvgAggregateOutputType | null
    _sum: PaymentMethodSumAggregateOutputType | null
    _min: PaymentMethodMinAggregateOutputType | null
    _max: PaymentMethodMaxAggregateOutputType | null
  }

  type GetPaymentMethodGroupByPayload<T extends PaymentMethodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentMethodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentMethodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentMethodGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentMethodGroupByOutputType[P]>
        }
      >
    >


  export type PaymentMethodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    methodName?: boolean
    provider?: boolean
    methodType?: boolean
    description?: boolean
    processingFeePercent?: boolean
    fixedFee?: boolean
    supportsRefunds?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paymentTransactions?: boolean | PaymentMethod$paymentTransactionsArgs<ExtArgs>
    userPaymentMethods?: boolean | PaymentMethod$userPaymentMethodsArgs<ExtArgs>
    parkingPassPayments?: boolean | PaymentMethod$parkingPassPaymentsArgs<ExtArgs>
    _count?: boolean | PaymentMethodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    methodName?: boolean
    provider?: boolean
    methodType?: boolean
    description?: boolean
    processingFeePercent?: boolean
    fixedFee?: boolean
    supportsRefunds?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    methodName?: boolean
    provider?: boolean
    methodType?: boolean
    description?: boolean
    processingFeePercent?: boolean
    fixedFee?: boolean
    supportsRefunds?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectScalar = {
    id?: boolean
    methodName?: boolean
    provider?: boolean
    methodType?: boolean
    description?: boolean
    processingFeePercent?: boolean
    fixedFee?: boolean
    supportsRefunds?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentMethodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "methodName" | "provider" | "methodType" | "description" | "processingFeePercent" | "fixedFee" | "supportsRefunds" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["paymentMethod"]>
  export type PaymentMethodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paymentTransactions?: boolean | PaymentMethod$paymentTransactionsArgs<ExtArgs>
    userPaymentMethods?: boolean | PaymentMethod$userPaymentMethodsArgs<ExtArgs>
    parkingPassPayments?: boolean | PaymentMethod$parkingPassPaymentsArgs<ExtArgs>
    _count?: boolean | PaymentMethodCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PaymentMethodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PaymentMethodIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PaymentMethodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentMethod"
    objects: {
      paymentTransactions: Prisma.$PaymentTransactionPayload<ExtArgs>[]
      userPaymentMethods: Prisma.$UserPaymentMethodPayload<ExtArgs>[]
      parkingPassPayments: Prisma.$ParkingPassPaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      methodName: string
      provider: string
      methodType: string
      description: string | null
      processingFeePercent: Prisma.Decimal
      fixedFee: Prisma.Decimal
      supportsRefunds: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["paymentMethod"]>
    composites: {}
  }

  type PaymentMethodGetPayload<S extends boolean | null | undefined | PaymentMethodDefaultArgs> = $Result.GetResult<Prisma.$PaymentMethodPayload, S>

  type PaymentMethodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentMethodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentMethodCountAggregateInputType | true
    }

  export interface PaymentMethodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentMethod'], meta: { name: 'PaymentMethod' } }
    /**
     * Find zero or one PaymentMethod that matches the filter.
     * @param {PaymentMethodFindUniqueArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentMethodFindUniqueArgs>(args: SelectSubset<T, PaymentMethodFindUniqueArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentMethod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentMethodFindUniqueOrThrowArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentMethodFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentMethodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentMethod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindFirstArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentMethodFindFirstArgs>(args?: SelectSubset<T, PaymentMethodFindFirstArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentMethod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindFirstOrThrowArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentMethodFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentMethodFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentMethods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentMethods
     * const paymentMethods = await prisma.paymentMethod.findMany()
     * 
     * // Get first 10 PaymentMethods
     * const paymentMethods = await prisma.paymentMethod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentMethodFindManyArgs>(args?: SelectSubset<T, PaymentMethodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentMethod.
     * @param {PaymentMethodCreateArgs} args - Arguments to create a PaymentMethod.
     * @example
     * // Create one PaymentMethod
     * const PaymentMethod = await prisma.paymentMethod.create({
     *   data: {
     *     // ... data to create a PaymentMethod
     *   }
     * })
     * 
     */
    create<T extends PaymentMethodCreateArgs>(args: SelectSubset<T, PaymentMethodCreateArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentMethods.
     * @param {PaymentMethodCreateManyArgs} args - Arguments to create many PaymentMethods.
     * @example
     * // Create many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentMethodCreateManyArgs>(args?: SelectSubset<T, PaymentMethodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentMethods and returns the data saved in the database.
     * @param {PaymentMethodCreateManyAndReturnArgs} args - Arguments to create many PaymentMethods.
     * @example
     * // Create many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentMethods and only return the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentMethodCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentMethodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentMethod.
     * @param {PaymentMethodDeleteArgs} args - Arguments to delete one PaymentMethod.
     * @example
     * // Delete one PaymentMethod
     * const PaymentMethod = await prisma.paymentMethod.delete({
     *   where: {
     *     // ... filter to delete one PaymentMethod
     *   }
     * })
     * 
     */
    delete<T extends PaymentMethodDeleteArgs>(args: SelectSubset<T, PaymentMethodDeleteArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentMethod.
     * @param {PaymentMethodUpdateArgs} args - Arguments to update one PaymentMethod.
     * @example
     * // Update one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentMethodUpdateArgs>(args: SelectSubset<T, PaymentMethodUpdateArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentMethods.
     * @param {PaymentMethodDeleteManyArgs} args - Arguments to filter PaymentMethods to delete.
     * @example
     * // Delete a few PaymentMethods
     * const { count } = await prisma.paymentMethod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentMethodDeleteManyArgs>(args?: SelectSubset<T, PaymentMethodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentMethodUpdateManyArgs>(args: SelectSubset<T, PaymentMethodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentMethods and returns the data updated in the database.
     * @param {PaymentMethodUpdateManyAndReturnArgs} args - Arguments to update many PaymentMethods.
     * @example
     * // Update many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentMethods and only return the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentMethodUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentMethodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentMethod.
     * @param {PaymentMethodUpsertArgs} args - Arguments to update or create a PaymentMethod.
     * @example
     * // Update or create a PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.upsert({
     *   create: {
     *     // ... data to create a PaymentMethod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentMethod we want to update
     *   }
     * })
     */
    upsert<T extends PaymentMethodUpsertArgs>(args: SelectSubset<T, PaymentMethodUpsertArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodCountArgs} args - Arguments to filter PaymentMethods to count.
     * @example
     * // Count the number of PaymentMethods
     * const count = await prisma.paymentMethod.count({
     *   where: {
     *     // ... the filter for the PaymentMethods we want to count
     *   }
     * })
    **/
    count<T extends PaymentMethodCountArgs>(
      args?: Subset<T, PaymentMethodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentMethodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentMethodAggregateArgs>(args: Subset<T, PaymentMethodAggregateArgs>): Prisma.PrismaPromise<GetPaymentMethodAggregateType<T>>

    /**
     * Group by PaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentMethodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentMethodGroupByArgs['orderBy'] }
        : { orderBy?: PaymentMethodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentMethodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentMethodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentMethod model
   */
  readonly fields: PaymentMethodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentMethod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentMethodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    paymentTransactions<T extends PaymentMethod$paymentTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, PaymentMethod$paymentTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userPaymentMethods<T extends PaymentMethod$userPaymentMethodsArgs<ExtArgs> = {}>(args?: Subset<T, PaymentMethod$userPaymentMethodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPaymentMethodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parkingPassPayments<T extends PaymentMethod$parkingPassPaymentsArgs<ExtArgs> = {}>(args?: Subset<T, PaymentMethod$parkingPassPaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParkingPassPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentMethod model
   */
  interface PaymentMethodFieldRefs {
    readonly id: FieldRef<"PaymentMethod", 'Int'>
    readonly methodName: FieldRef<"PaymentMethod", 'String'>
    readonly provider: FieldRef<"PaymentMethod", 'String'>
    readonly methodType: FieldRef<"PaymentMethod", 'String'>
    readonly description: FieldRef<"PaymentMethod", 'String'>
    readonly processingFeePercent: FieldRef<"PaymentMethod", 'Decimal'>
    readonly fixedFee: FieldRef<"PaymentMethod", 'Decimal'>
    readonly supportsRefunds: FieldRef<"PaymentMethod", 'Boolean'>
    readonly isActive: FieldRef<"PaymentMethod", 'Boolean'>
    readonly createdAt: FieldRef<"PaymentMethod", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentMethod", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentMethod findUnique
   */
  export type PaymentMethodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod findUniqueOrThrow
   */
  export type PaymentMethodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod findFirst
   */
  export type PaymentMethodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethods.
     */
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod findFirstOrThrow
   */
  export type PaymentMethodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethods.
     */
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod findMany
   */
  export type PaymentMethodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethods to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod create
   */
  export type PaymentMethodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentMethod.
     */
    data: XOR<PaymentMethodCreateInput, PaymentMethodUncheckedCreateInput>
  }

  /**
   * PaymentMethod createMany
   */
  export type PaymentMethodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentMethods.
     */
    data: PaymentMethodCreateManyInput | PaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentMethod createManyAndReturn
   */
  export type PaymentMethodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentMethods.
     */
    data: PaymentMethodCreateManyInput | PaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentMethod update
   */
  export type PaymentMethodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentMethod.
     */
    data: XOR<PaymentMethodUpdateInput, PaymentMethodUncheckedUpdateInput>
    /**
     * Choose, which PaymentMethod to update.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod updateMany
   */
  export type PaymentMethodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentMethods.
     */
    data: XOR<PaymentMethodUpdateManyMutationInput, PaymentMethodUncheckedUpdateManyInput>
    /**
     * Filter which PaymentMethods to update
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to update.
     */
    limit?: number
  }

  /**
   * PaymentMethod updateManyAndReturn
   */
  export type PaymentMethodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * The data used to update PaymentMethods.
     */
    data: XOR<PaymentMethodUpdateManyMutationInput, PaymentMethodUncheckedUpdateManyInput>
    /**
     * Filter which PaymentMethods to update
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to update.
     */
    limit?: number
  }

  /**
   * PaymentMethod upsert
   */
  export type PaymentMethodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentMethod to update in case it exists.
     */
    where: PaymentMethodWhereUniqueInput
    /**
     * In case the PaymentMethod found by the `where` argument doesn't exist, create a new PaymentMethod with this data.
     */
    create: XOR<PaymentMethodCreateInput, PaymentMethodUncheckedCreateInput>
    /**
     * In case the PaymentMethod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentMethodUpdateInput, PaymentMethodUncheckedUpdateInput>
  }

  /**
   * PaymentMethod delete
   */
  export type PaymentMethodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter which PaymentMethod to delete.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod deleteMany
   */
  export type PaymentMethodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethods to delete
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to delete.
     */
    limit?: number
  }

  /**
   * PaymentMethod.paymentTransactions
   */
  export type PaymentMethod$paymentTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    where?: PaymentTransactionWhereInput
    orderBy?: PaymentTransactionOrderByWithRelationInput | PaymentTransactionOrderByWithRelationInput[]
    cursor?: PaymentTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentTransactionScalarFieldEnum | PaymentTransactionScalarFieldEnum[]
  }

  /**
   * PaymentMethod.userPaymentMethods
   */
  export type PaymentMethod$userPaymentMethodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPaymentMethod
     */
    select?: UserPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPaymentMethod
     */
    omit?: UserPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPaymentMethodInclude<ExtArgs> | null
    where?: UserPaymentMethodWhereInput
    orderBy?: UserPaymentMethodOrderByWithRelationInput | UserPaymentMethodOrderByWithRelationInput[]
    cursor?: UserPaymentMethodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPaymentMethodScalarFieldEnum | UserPaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod.parkingPassPayments
   */
  export type PaymentMethod$parkingPassPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingPassPayment
     */
    select?: ParkingPassPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingPassPayment
     */
    omit?: ParkingPassPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingPassPaymentInclude<ExtArgs> | null
    where?: ParkingPassPaymentWhereInput
    orderBy?: ParkingPassPaymentOrderByWithRelationInput | ParkingPassPaymentOrderByWithRelationInput[]
    cursor?: ParkingPassPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParkingPassPaymentScalarFieldEnum | ParkingPassPaymentScalarFieldEnum[]
  }

  /**
   * PaymentMethod without action
   */
  export type PaymentMethodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
  }


  /**
   * Model UserPaymentMethod
   */

  export type AggregateUserPaymentMethod = {
    _count: UserPaymentMethodCountAggregateOutputType | null
    _avg: UserPaymentMethodAvgAggregateOutputType | null
    _sum: UserPaymentMethodSumAggregateOutputType | null
    _min: UserPaymentMethodMinAggregateOutputType | null
    _max: UserPaymentMethodMaxAggregateOutputType | null
  }

  export type UserPaymentMethodAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    paymentMethodId: number | null
  }

  export type UserPaymentMethodSumAggregateOutputType = {
    id: number | null
    userId: number | null
    paymentMethodId: number | null
  }

  export type UserPaymentMethodMinAggregateOutputType = {
    id: number | null
    userId: number | null
    paymentMethodId: number | null
    tokenReference: string | null
    maskedInfo: string | null
    expiryInfo: string | null
    isDefault: boolean | null
    isVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPaymentMethodMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    paymentMethodId: number | null
    tokenReference: string | null
    maskedInfo: string | null
    expiryInfo: string | null
    isDefault: boolean | null
    isVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPaymentMethodCountAggregateOutputType = {
    id: number
    userId: number
    paymentMethodId: number
    tokenReference: number
    maskedInfo: number
    expiryInfo: number
    isDefault: number
    isVerified: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserPaymentMethodAvgAggregateInputType = {
    id?: true
    userId?: true
    paymentMethodId?: true
  }

  export type UserPaymentMethodSumAggregateInputType = {
    id?: true
    userId?: true
    paymentMethodId?: true
  }

  export type UserPaymentMethodMinAggregateInputType = {
    id?: true
    userId?: true
    paymentMethodId?: true
    tokenReference?: true
    maskedInfo?: true
    expiryInfo?: true
    isDefault?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPaymentMethodMaxAggregateInputType = {
    id?: true
    userId?: true
    paymentMethodId?: true
    tokenReference?: true
    maskedInfo?: true
    expiryInfo?: true
    isDefault?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPaymentMethodCountAggregateInputType = {
    id?: true
    userId?: true
    paymentMethodId?: true
    tokenReference?: true
    maskedInfo?: true
    expiryInfo?: true
    isDefault?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserPaymentMethodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPaymentMethod to aggregate.
     */
    where?: UserPaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPaymentMethods to fetch.
     */
    orderBy?: UserPaymentMethodOrderByWithRelationInput | UserPaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPaymentMethods
    **/
    _count?: true | UserPaymentMethodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserPaymentMethodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserPaymentMethodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPaymentMethodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPaymentMethodMaxAggregateInputType
  }

  export type GetUserPaymentMethodAggregateType<T extends UserPaymentMethodAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPaymentMethod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPaymentMethod[P]>
      : GetScalarType<T[P], AggregateUserPaymentMethod[P]>
  }




  export type UserPaymentMethodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPaymentMethodWhereInput
    orderBy?: UserPaymentMethodOrderByWithAggregationInput | UserPaymentMethodOrderByWithAggregationInput[]
    by: UserPaymentMethodScalarFieldEnum[] | UserPaymentMethodScalarFieldEnum
    having?: UserPaymentMethodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPaymentMethodCountAggregateInputType | true
    _avg?: UserPaymentMethodAvgAggregateInputType
    _sum?: UserPaymentMethodSumAggregateInputType
    _min?: UserPaymentMethodMinAggregateInputType
    _max?: UserPaymentMethodMaxAggregateInputType
  }

  export type UserPaymentMethodGroupByOutputType = {
    id: number
    userId: number
    paymentMethodId: number
    tokenReference: string
    maskedInfo: string | null
    expiryInfo: string | null
    isDefault: boolean
    isVerified: boolean
    createdAt: Date
    updatedAt: Date | null
    _count: UserPaymentMethodCountAggregateOutputType | null
    _avg: UserPaymentMethodAvgAggregateOutputType | null
    _sum: UserPaymentMethodSumAggregateOutputType | null
    _min: UserPaymentMethodMinAggregateOutputType | null
    _max: UserPaymentMethodMaxAggregateOutputType | null
  }

  type GetUserPaymentMethodGroupByPayload<T extends UserPaymentMethodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPaymentMethodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPaymentMethodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPaymentMethodGroupByOutputType[P]>
            : GetScalarType<T[P], UserPaymentMethodGroupByOutputType[P]>
        }
      >
    >


  export type UserPaymentMethodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    paymentMethodId?: boolean
    tokenReference?: boolean
    maskedInfo?: boolean
    expiryInfo?: boolean
    isDefault?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPaymentMethod"]>

  export type UserPaymentMethodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    paymentMethodId?: boolean
    tokenReference?: boolean
    maskedInfo?: boolean
    expiryInfo?: boolean
    isDefault?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPaymentMethod"]>

  export type UserPaymentMethodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    paymentMethodId?: boolean
    tokenReference?: boolean
    maskedInfo?: boolean
    expiryInfo?: boolean
    isDefault?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPaymentMethod"]>

  export type UserPaymentMethodSelectScalar = {
    id?: boolean
    userId?: boolean
    paymentMethodId?: boolean
    tokenReference?: boolean
    maskedInfo?: boolean
    expiryInfo?: boolean
    isDefault?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserPaymentMethodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "paymentMethodId" | "tokenReference" | "maskedInfo" | "expiryInfo" | "isDefault" | "isVerified" | "createdAt" | "updatedAt", ExtArgs["result"]["userPaymentMethod"]>
  export type UserPaymentMethodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
  }
  export type UserPaymentMethodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
  }
  export type UserPaymentMethodIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
  }

  export type $UserPaymentMethodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPaymentMethod"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      paymentMethod: Prisma.$PaymentMethodPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      paymentMethodId: number
      tokenReference: string
      maskedInfo: string | null
      expiryInfo: string | null
      isDefault: boolean
      isVerified: boolean
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["userPaymentMethod"]>
    composites: {}
  }

  type UserPaymentMethodGetPayload<S extends boolean | null | undefined | UserPaymentMethodDefaultArgs> = $Result.GetResult<Prisma.$UserPaymentMethodPayload, S>

  type UserPaymentMethodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPaymentMethodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPaymentMethodCountAggregateInputType | true
    }

  export interface UserPaymentMethodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPaymentMethod'], meta: { name: 'UserPaymentMethod' } }
    /**
     * Find zero or one UserPaymentMethod that matches the filter.
     * @param {UserPaymentMethodFindUniqueArgs} args - Arguments to find a UserPaymentMethod
     * @example
     * // Get one UserPaymentMethod
     * const userPaymentMethod = await prisma.userPaymentMethod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPaymentMethodFindUniqueArgs>(args: SelectSubset<T, UserPaymentMethodFindUniqueArgs<ExtArgs>>): Prisma__UserPaymentMethodClient<$Result.GetResult<Prisma.$UserPaymentMethodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserPaymentMethod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPaymentMethodFindUniqueOrThrowArgs} args - Arguments to find a UserPaymentMethod
     * @example
     * // Get one UserPaymentMethod
     * const userPaymentMethod = await prisma.userPaymentMethod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPaymentMethodFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPaymentMethodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPaymentMethodClient<$Result.GetResult<Prisma.$UserPaymentMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPaymentMethod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPaymentMethodFindFirstArgs} args - Arguments to find a UserPaymentMethod
     * @example
     * // Get one UserPaymentMethod
     * const userPaymentMethod = await prisma.userPaymentMethod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPaymentMethodFindFirstArgs>(args?: SelectSubset<T, UserPaymentMethodFindFirstArgs<ExtArgs>>): Prisma__UserPaymentMethodClient<$Result.GetResult<Prisma.$UserPaymentMethodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPaymentMethod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPaymentMethodFindFirstOrThrowArgs} args - Arguments to find a UserPaymentMethod
     * @example
     * // Get one UserPaymentMethod
     * const userPaymentMethod = await prisma.userPaymentMethod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPaymentMethodFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPaymentMethodFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPaymentMethodClient<$Result.GetResult<Prisma.$UserPaymentMethodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPaymentMethods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPaymentMethodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPaymentMethods
     * const userPaymentMethods = await prisma.userPaymentMethod.findMany()
     * 
     * // Get first 10 UserPaymentMethods
     * const userPaymentMethods = await prisma.userPaymentMethod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPaymentMethodWithIdOnly = await prisma.userPaymentMethod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPaymentMethodFindManyArgs>(args?: SelectSubset<T, UserPaymentMethodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPaymentMethodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserPaymentMethod.
     * @param {UserPaymentMethodCreateArgs} args - Arguments to create a UserPaymentMethod.
     * @example
     * // Create one UserPaymentMethod
     * const UserPaymentMethod = await prisma.userPaymentMethod.create({
     *   data: {
     *     // ... data to create a UserPaymentMethod
     *   }
     * })
     * 
     */
    create<T extends UserPaymentMethodCreateArgs>(args: SelectSubset<T, UserPaymentMethodCreateArgs<ExtArgs>>): Prisma__UserPaymentMethodClient<$Result.GetResult<Prisma.$UserPaymentMethodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserPaymentMethods.
     * @param {UserPaymentMethodCreateManyArgs} args - Arguments to create many UserPaymentMethods.
     * @example
     * // Create many UserPaymentMethods
     * const userPaymentMethod = await prisma.userPaymentMethod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPaymentMethodCreateManyArgs>(args?: SelectSubset<T, UserPaymentMethodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserPaymentMethods and returns the data saved in the database.
     * @param {UserPaymentMethodCreateManyAndReturnArgs} args - Arguments to create many UserPaymentMethods.
     * @example
     * // Create many UserPaymentMethods
     * const userPaymentMethod = await prisma.userPaymentMethod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserPaymentMethods and only return the `id`
     * const userPaymentMethodWithIdOnly = await prisma.userPaymentMethod.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserPaymentMethodCreateManyAndReturnArgs>(args?: SelectSubset<T, UserPaymentMethodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPaymentMethodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserPaymentMethod.
     * @param {UserPaymentMethodDeleteArgs} args - Arguments to delete one UserPaymentMethod.
     * @example
     * // Delete one UserPaymentMethod
     * const UserPaymentMethod = await prisma.userPaymentMethod.delete({
     *   where: {
     *     // ... filter to delete one UserPaymentMethod
     *   }
     * })
     * 
     */
    delete<T extends UserPaymentMethodDeleteArgs>(args: SelectSubset<T, UserPaymentMethodDeleteArgs<ExtArgs>>): Prisma__UserPaymentMethodClient<$Result.GetResult<Prisma.$UserPaymentMethodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserPaymentMethod.
     * @param {UserPaymentMethodUpdateArgs} args - Arguments to update one UserPaymentMethod.
     * @example
     * // Update one UserPaymentMethod
     * const userPaymentMethod = await prisma.userPaymentMethod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPaymentMethodUpdateArgs>(args: SelectSubset<T, UserPaymentMethodUpdateArgs<ExtArgs>>): Prisma__UserPaymentMethodClient<$Result.GetResult<Prisma.$UserPaymentMethodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserPaymentMethods.
     * @param {UserPaymentMethodDeleteManyArgs} args - Arguments to filter UserPaymentMethods to delete.
     * @example
     * // Delete a few UserPaymentMethods
     * const { count } = await prisma.userPaymentMethod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPaymentMethodDeleteManyArgs>(args?: SelectSubset<T, UserPaymentMethodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPaymentMethodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPaymentMethods
     * const userPaymentMethod = await prisma.userPaymentMethod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPaymentMethodUpdateManyArgs>(args: SelectSubset<T, UserPaymentMethodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPaymentMethods and returns the data updated in the database.
     * @param {UserPaymentMethodUpdateManyAndReturnArgs} args - Arguments to update many UserPaymentMethods.
     * @example
     * // Update many UserPaymentMethods
     * const userPaymentMethod = await prisma.userPaymentMethod.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserPaymentMethods and only return the `id`
     * const userPaymentMethodWithIdOnly = await prisma.userPaymentMethod.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserPaymentMethodUpdateManyAndReturnArgs>(args: SelectSubset<T, UserPaymentMethodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPaymentMethodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserPaymentMethod.
     * @param {UserPaymentMethodUpsertArgs} args - Arguments to update or create a UserPaymentMethod.
     * @example
     * // Update or create a UserPaymentMethod
     * const userPaymentMethod = await prisma.userPaymentMethod.upsert({
     *   create: {
     *     // ... data to create a UserPaymentMethod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPaymentMethod we want to update
     *   }
     * })
     */
    upsert<T extends UserPaymentMethodUpsertArgs>(args: SelectSubset<T, UserPaymentMethodUpsertArgs<ExtArgs>>): Prisma__UserPaymentMethodClient<$Result.GetResult<Prisma.$UserPaymentMethodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserPaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPaymentMethodCountArgs} args - Arguments to filter UserPaymentMethods to count.
     * @example
     * // Count the number of UserPaymentMethods
     * const count = await prisma.userPaymentMethod.count({
     *   where: {
     *     // ... the filter for the UserPaymentMethods we want to count
     *   }
     * })
    **/
    count<T extends UserPaymentMethodCountArgs>(
      args?: Subset<T, UserPaymentMethodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPaymentMethodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPaymentMethodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPaymentMethodAggregateArgs>(args: Subset<T, UserPaymentMethodAggregateArgs>): Prisma.PrismaPromise<GetUserPaymentMethodAggregateType<T>>

    /**
     * Group by UserPaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPaymentMethodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPaymentMethodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPaymentMethodGroupByArgs['orderBy'] }
        : { orderBy?: UserPaymentMethodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPaymentMethodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPaymentMethodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPaymentMethod model
   */
  readonly fields: UserPaymentMethodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPaymentMethod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPaymentMethodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    paymentMethod<T extends PaymentMethodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentMethodDefaultArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPaymentMethod model
   */
  interface UserPaymentMethodFieldRefs {
    readonly id: FieldRef<"UserPaymentMethod", 'Int'>
    readonly userId: FieldRef<"UserPaymentMethod", 'Int'>
    readonly paymentMethodId: FieldRef<"UserPaymentMethod", 'Int'>
    readonly tokenReference: FieldRef<"UserPaymentMethod", 'String'>
    readonly maskedInfo: FieldRef<"UserPaymentMethod", 'String'>
    readonly expiryInfo: FieldRef<"UserPaymentMethod", 'String'>
    readonly isDefault: FieldRef<"UserPaymentMethod", 'Boolean'>
    readonly isVerified: FieldRef<"UserPaymentMethod", 'Boolean'>
    readonly createdAt: FieldRef<"UserPaymentMethod", 'DateTime'>
    readonly updatedAt: FieldRef<"UserPaymentMethod", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserPaymentMethod findUnique
   */
  export type UserPaymentMethodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPaymentMethod
     */
    select?: UserPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPaymentMethod
     */
    omit?: UserPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which UserPaymentMethod to fetch.
     */
    where: UserPaymentMethodWhereUniqueInput
  }

  /**
   * UserPaymentMethod findUniqueOrThrow
   */
  export type UserPaymentMethodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPaymentMethod
     */
    select?: UserPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPaymentMethod
     */
    omit?: UserPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which UserPaymentMethod to fetch.
     */
    where: UserPaymentMethodWhereUniqueInput
  }

  /**
   * UserPaymentMethod findFirst
   */
  export type UserPaymentMethodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPaymentMethod
     */
    select?: UserPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPaymentMethod
     */
    omit?: UserPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which UserPaymentMethod to fetch.
     */
    where?: UserPaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPaymentMethods to fetch.
     */
    orderBy?: UserPaymentMethodOrderByWithRelationInput | UserPaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPaymentMethods.
     */
    cursor?: UserPaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPaymentMethods.
     */
    distinct?: UserPaymentMethodScalarFieldEnum | UserPaymentMethodScalarFieldEnum[]
  }

  /**
   * UserPaymentMethod findFirstOrThrow
   */
  export type UserPaymentMethodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPaymentMethod
     */
    select?: UserPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPaymentMethod
     */
    omit?: UserPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which UserPaymentMethod to fetch.
     */
    where?: UserPaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPaymentMethods to fetch.
     */
    orderBy?: UserPaymentMethodOrderByWithRelationInput | UserPaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPaymentMethods.
     */
    cursor?: UserPaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPaymentMethods.
     */
    distinct?: UserPaymentMethodScalarFieldEnum | UserPaymentMethodScalarFieldEnum[]
  }

  /**
   * UserPaymentMethod findMany
   */
  export type UserPaymentMethodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPaymentMethod
     */
    select?: UserPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPaymentMethod
     */
    omit?: UserPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which UserPaymentMethods to fetch.
     */
    where?: UserPaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPaymentMethods to fetch.
     */
    orderBy?: UserPaymentMethodOrderByWithRelationInput | UserPaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPaymentMethods.
     */
    cursor?: UserPaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPaymentMethods.
     */
    skip?: number
    distinct?: UserPaymentMethodScalarFieldEnum | UserPaymentMethodScalarFieldEnum[]
  }

  /**
   * UserPaymentMethod create
   */
  export type UserPaymentMethodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPaymentMethod
     */
    select?: UserPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPaymentMethod
     */
    omit?: UserPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPaymentMethodInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPaymentMethod.
     */
    data: XOR<UserPaymentMethodCreateInput, UserPaymentMethodUncheckedCreateInput>
  }

  /**
   * UserPaymentMethod createMany
   */
  export type UserPaymentMethodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPaymentMethods.
     */
    data: UserPaymentMethodCreateManyInput | UserPaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPaymentMethod createManyAndReturn
   */
  export type UserPaymentMethodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPaymentMethod
     */
    select?: UserPaymentMethodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPaymentMethod
     */
    omit?: UserPaymentMethodOmit<ExtArgs> | null
    /**
     * The data used to create many UserPaymentMethods.
     */
    data: UserPaymentMethodCreateManyInput | UserPaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPaymentMethodIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPaymentMethod update
   */
  export type UserPaymentMethodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPaymentMethod
     */
    select?: UserPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPaymentMethod
     */
    omit?: UserPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPaymentMethodInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPaymentMethod.
     */
    data: XOR<UserPaymentMethodUpdateInput, UserPaymentMethodUncheckedUpdateInput>
    /**
     * Choose, which UserPaymentMethod to update.
     */
    where: UserPaymentMethodWhereUniqueInput
  }

  /**
   * UserPaymentMethod updateMany
   */
  export type UserPaymentMethodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPaymentMethods.
     */
    data: XOR<UserPaymentMethodUpdateManyMutationInput, UserPaymentMethodUncheckedUpdateManyInput>
    /**
     * Filter which UserPaymentMethods to update
     */
    where?: UserPaymentMethodWhereInput
    /**
     * Limit how many UserPaymentMethods to update.
     */
    limit?: number
  }

  /**
   * UserPaymentMethod updateManyAndReturn
   */
  export type UserPaymentMethodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPaymentMethod
     */
    select?: UserPaymentMethodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPaymentMethod
     */
    omit?: UserPaymentMethodOmit<ExtArgs> | null
    /**
     * The data used to update UserPaymentMethods.
     */
    data: XOR<UserPaymentMethodUpdateManyMutationInput, UserPaymentMethodUncheckedUpdateManyInput>
    /**
     * Filter which UserPaymentMethods to update
     */
    where?: UserPaymentMethodWhereInput
    /**
     * Limit how many UserPaymentMethods to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPaymentMethodIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPaymentMethod upsert
   */
  export type UserPaymentMethodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPaymentMethod
     */
    select?: UserPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPaymentMethod
     */
    omit?: UserPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPaymentMethodInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPaymentMethod to update in case it exists.
     */
    where: UserPaymentMethodWhereUniqueInput
    /**
     * In case the UserPaymentMethod found by the `where` argument doesn't exist, create a new UserPaymentMethod with this data.
     */
    create: XOR<UserPaymentMethodCreateInput, UserPaymentMethodUncheckedCreateInput>
    /**
     * In case the UserPaymentMethod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPaymentMethodUpdateInput, UserPaymentMethodUncheckedUpdateInput>
  }

  /**
   * UserPaymentMethod delete
   */
  export type UserPaymentMethodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPaymentMethod
     */
    select?: UserPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPaymentMethod
     */
    omit?: UserPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPaymentMethodInclude<ExtArgs> | null
    /**
     * Filter which UserPaymentMethod to delete.
     */
    where: UserPaymentMethodWhereUniqueInput
  }

  /**
   * UserPaymentMethod deleteMany
   */
  export type UserPaymentMethodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPaymentMethods to delete
     */
    where?: UserPaymentMethodWhereInput
    /**
     * Limit how many UserPaymentMethods to delete.
     */
    limit?: number
  }

  /**
   * UserPaymentMethod without action
   */
  export type UserPaymentMethodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPaymentMethod
     */
    select?: UserPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPaymentMethod
     */
    omit?: UserPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPaymentMethodInclude<ExtArgs> | null
  }


  /**
   * Model PromoCode
   */

  export type AggregatePromoCode = {
    _count: PromoCodeCountAggregateOutputType | null
    _avg: PromoCodeAvgAggregateOutputType | null
    _sum: PromoCodeSumAggregateOutputType | null
    _min: PromoCodeMinAggregateOutputType | null
    _max: PromoCodeMaxAggregateOutputType | null
  }

  export type PromoCodeAvgAggregateOutputType = {
    id: number | null
    discountValue: Decimal | null
    minimumSpend: Decimal | null
    usageLimit: number | null
    usageCount: number | null
  }

  export type PromoCodeSumAggregateOutputType = {
    id: number | null
    discountValue: Decimal | null
    minimumSpend: Decimal | null
    usageLimit: number | null
    usageCount: number | null
  }

  export type PromoCodeMinAggregateOutputType = {
    id: number | null
    code: string | null
    description: string | null
    discountType: string | null
    discountValue: Decimal | null
    minimumSpend: Decimal | null
    validFrom: Date | null
    validUntil: Date | null
    usageLimit: number | null
    usageCount: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromoCodeMaxAggregateOutputType = {
    id: number | null
    code: string | null
    description: string | null
    discountType: string | null
    discountValue: Decimal | null
    minimumSpend: Decimal | null
    validFrom: Date | null
    validUntil: Date | null
    usageLimit: number | null
    usageCount: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromoCodeCountAggregateOutputType = {
    id: number
    code: number
    description: number
    discountType: number
    discountValue: number
    minimumSpend: number
    validFrom: number
    validUntil: number
    usageLimit: number
    usageCount: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PromoCodeAvgAggregateInputType = {
    id?: true
    discountValue?: true
    minimumSpend?: true
    usageLimit?: true
    usageCount?: true
  }

  export type PromoCodeSumAggregateInputType = {
    id?: true
    discountValue?: true
    minimumSpend?: true
    usageLimit?: true
    usageCount?: true
  }

  export type PromoCodeMinAggregateInputType = {
    id?: true
    code?: true
    description?: true
    discountType?: true
    discountValue?: true
    minimumSpend?: true
    validFrom?: true
    validUntil?: true
    usageLimit?: true
    usageCount?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromoCodeMaxAggregateInputType = {
    id?: true
    code?: true
    description?: true
    discountType?: true
    discountValue?: true
    minimumSpend?: true
    validFrom?: true
    validUntil?: true
    usageLimit?: true
    usageCount?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromoCodeCountAggregateInputType = {
    id?: true
    code?: true
    description?: true
    discountType?: true
    discountValue?: true
    minimumSpend?: true
    validFrom?: true
    validUntil?: true
    usageLimit?: true
    usageCount?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PromoCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromoCode to aggregate.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PromoCodes
    **/
    _count?: true | PromoCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PromoCodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PromoCodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromoCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromoCodeMaxAggregateInputType
  }

  export type GetPromoCodeAggregateType<T extends PromoCodeAggregateArgs> = {
        [P in keyof T & keyof AggregatePromoCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromoCode[P]>
      : GetScalarType<T[P], AggregatePromoCode[P]>
  }




  export type PromoCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromoCodeWhereInput
    orderBy?: PromoCodeOrderByWithAggregationInput | PromoCodeOrderByWithAggregationInput[]
    by: PromoCodeScalarFieldEnum[] | PromoCodeScalarFieldEnum
    having?: PromoCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromoCodeCountAggregateInputType | true
    _avg?: PromoCodeAvgAggregateInputType
    _sum?: PromoCodeSumAggregateInputType
    _min?: PromoCodeMinAggregateInputType
    _max?: PromoCodeMaxAggregateInputType
  }

  export type PromoCodeGroupByOutputType = {
    id: number
    code: string
    description: string | null
    discountType: string
    discountValue: Decimal
    minimumSpend: Decimal
    validFrom: Date
    validUntil: Date | null
    usageLimit: number | null
    usageCount: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date | null
    _count: PromoCodeCountAggregateOutputType | null
    _avg: PromoCodeAvgAggregateOutputType | null
    _sum: PromoCodeSumAggregateOutputType | null
    _min: PromoCodeMinAggregateOutputType | null
    _max: PromoCodeMaxAggregateOutputType | null
  }

  type GetPromoCodeGroupByPayload<T extends PromoCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromoCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromoCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromoCodeGroupByOutputType[P]>
            : GetScalarType<T[P], PromoCodeGroupByOutputType[P]>
        }
      >
    >


  export type PromoCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    discountType?: boolean
    discountValue?: boolean
    minimumSpend?: boolean
    validFrom?: boolean
    validUntil?: boolean
    usageLimit?: boolean
    usageCount?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookings?: boolean | PromoCode$bookingsArgs<ExtArgs>
    _count?: boolean | PromoCodeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promoCode"]>

  export type PromoCodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    discountType?: boolean
    discountValue?: boolean
    minimumSpend?: boolean
    validFrom?: boolean
    validUntil?: boolean
    usageLimit?: boolean
    usageCount?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["promoCode"]>

  export type PromoCodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    discountType?: boolean
    discountValue?: boolean
    minimumSpend?: boolean
    validFrom?: boolean
    validUntil?: boolean
    usageLimit?: boolean
    usageCount?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["promoCode"]>

  export type PromoCodeSelectScalar = {
    id?: boolean
    code?: boolean
    description?: boolean
    discountType?: boolean
    discountValue?: boolean
    minimumSpend?: boolean
    validFrom?: boolean
    validUntil?: boolean
    usageLimit?: boolean
    usageCount?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PromoCodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "description" | "discountType" | "discountValue" | "minimumSpend" | "validFrom" | "validUntil" | "usageLimit" | "usageCount" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["promoCode"]>
  export type PromoCodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | PromoCode$bookingsArgs<ExtArgs>
    _count?: boolean | PromoCodeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PromoCodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PromoCodeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PromoCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PromoCode"
    objects: {
      bookings: Prisma.$BookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      description: string | null
      discountType: string
      discountValue: Prisma.Decimal
      minimumSpend: Prisma.Decimal
      validFrom: Date
      validUntil: Date | null
      usageLimit: number | null
      usageCount: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["promoCode"]>
    composites: {}
  }

  type PromoCodeGetPayload<S extends boolean | null | undefined | PromoCodeDefaultArgs> = $Result.GetResult<Prisma.$PromoCodePayload, S>

  type PromoCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PromoCodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PromoCodeCountAggregateInputType | true
    }

  export interface PromoCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PromoCode'], meta: { name: 'PromoCode' } }
    /**
     * Find zero or one PromoCode that matches the filter.
     * @param {PromoCodeFindUniqueArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromoCodeFindUniqueArgs>(args: SelectSubset<T, PromoCodeFindUniqueArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PromoCode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PromoCodeFindUniqueOrThrowArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromoCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, PromoCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PromoCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeFindFirstArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromoCodeFindFirstArgs>(args?: SelectSubset<T, PromoCodeFindFirstArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PromoCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeFindFirstOrThrowArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromoCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, PromoCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PromoCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PromoCodes
     * const promoCodes = await prisma.promoCode.findMany()
     * 
     * // Get first 10 PromoCodes
     * const promoCodes = await prisma.promoCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promoCodeWithIdOnly = await prisma.promoCode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromoCodeFindManyArgs>(args?: SelectSubset<T, PromoCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PromoCode.
     * @param {PromoCodeCreateArgs} args - Arguments to create a PromoCode.
     * @example
     * // Create one PromoCode
     * const PromoCode = await prisma.promoCode.create({
     *   data: {
     *     // ... data to create a PromoCode
     *   }
     * })
     * 
     */
    create<T extends PromoCodeCreateArgs>(args: SelectSubset<T, PromoCodeCreateArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PromoCodes.
     * @param {PromoCodeCreateManyArgs} args - Arguments to create many PromoCodes.
     * @example
     * // Create many PromoCodes
     * const promoCode = await prisma.promoCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromoCodeCreateManyArgs>(args?: SelectSubset<T, PromoCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PromoCodes and returns the data saved in the database.
     * @param {PromoCodeCreateManyAndReturnArgs} args - Arguments to create many PromoCodes.
     * @example
     * // Create many PromoCodes
     * const promoCode = await prisma.promoCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PromoCodes and only return the `id`
     * const promoCodeWithIdOnly = await prisma.promoCode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PromoCodeCreateManyAndReturnArgs>(args?: SelectSubset<T, PromoCodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PromoCode.
     * @param {PromoCodeDeleteArgs} args - Arguments to delete one PromoCode.
     * @example
     * // Delete one PromoCode
     * const PromoCode = await prisma.promoCode.delete({
     *   where: {
     *     // ... filter to delete one PromoCode
     *   }
     * })
     * 
     */
    delete<T extends PromoCodeDeleteArgs>(args: SelectSubset<T, PromoCodeDeleteArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PromoCode.
     * @param {PromoCodeUpdateArgs} args - Arguments to update one PromoCode.
     * @example
     * // Update one PromoCode
     * const promoCode = await prisma.promoCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromoCodeUpdateArgs>(args: SelectSubset<T, PromoCodeUpdateArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PromoCodes.
     * @param {PromoCodeDeleteManyArgs} args - Arguments to filter PromoCodes to delete.
     * @example
     * // Delete a few PromoCodes
     * const { count } = await prisma.promoCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromoCodeDeleteManyArgs>(args?: SelectSubset<T, PromoCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromoCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PromoCodes
     * const promoCode = await prisma.promoCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromoCodeUpdateManyArgs>(args: SelectSubset<T, PromoCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromoCodes and returns the data updated in the database.
     * @param {PromoCodeUpdateManyAndReturnArgs} args - Arguments to update many PromoCodes.
     * @example
     * // Update many PromoCodes
     * const promoCode = await prisma.promoCode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PromoCodes and only return the `id`
     * const promoCodeWithIdOnly = await prisma.promoCode.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PromoCodeUpdateManyAndReturnArgs>(args: SelectSubset<T, PromoCodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PromoCode.
     * @param {PromoCodeUpsertArgs} args - Arguments to update or create a PromoCode.
     * @example
     * // Update or create a PromoCode
     * const promoCode = await prisma.promoCode.upsert({
     *   create: {
     *     // ... data to create a PromoCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PromoCode we want to update
     *   }
     * })
     */
    upsert<T extends PromoCodeUpsertArgs>(args: SelectSubset<T, PromoCodeUpsertArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PromoCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeCountArgs} args - Arguments to filter PromoCodes to count.
     * @example
     * // Count the number of PromoCodes
     * const count = await prisma.promoCode.count({
     *   where: {
     *     // ... the filter for the PromoCodes we want to count
     *   }
     * })
    **/
    count<T extends PromoCodeCountArgs>(
      args?: Subset<T, PromoCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromoCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PromoCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromoCodeAggregateArgs>(args: Subset<T, PromoCodeAggregateArgs>): Prisma.PrismaPromise<GetPromoCodeAggregateType<T>>

    /**
     * Group by PromoCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromoCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromoCodeGroupByArgs['orderBy'] }
        : { orderBy?: PromoCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromoCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromoCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PromoCode model
   */
  readonly fields: PromoCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PromoCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromoCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookings<T extends PromoCode$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, PromoCode$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PromoCode model
   */
  interface PromoCodeFieldRefs {
    readonly id: FieldRef<"PromoCode", 'Int'>
    readonly code: FieldRef<"PromoCode", 'String'>
    readonly description: FieldRef<"PromoCode", 'String'>
    readonly discountType: FieldRef<"PromoCode", 'String'>
    readonly discountValue: FieldRef<"PromoCode", 'Decimal'>
    readonly minimumSpend: FieldRef<"PromoCode", 'Decimal'>
    readonly validFrom: FieldRef<"PromoCode", 'DateTime'>
    readonly validUntil: FieldRef<"PromoCode", 'DateTime'>
    readonly usageLimit: FieldRef<"PromoCode", 'Int'>
    readonly usageCount: FieldRef<"PromoCode", 'Int'>
    readonly isActive: FieldRef<"PromoCode", 'Boolean'>
    readonly createdAt: FieldRef<"PromoCode", 'DateTime'>
    readonly updatedAt: FieldRef<"PromoCode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PromoCode findUnique
   */
  export type PromoCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where: PromoCodeWhereUniqueInput
  }

  /**
   * PromoCode findUniqueOrThrow
   */
  export type PromoCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where: PromoCodeWhereUniqueInput
  }

  /**
   * PromoCode findFirst
   */
  export type PromoCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromoCodes.
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromoCodes.
     */
    distinct?: PromoCodeScalarFieldEnum | PromoCodeScalarFieldEnum[]
  }

  /**
   * PromoCode findFirstOrThrow
   */
  export type PromoCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromoCodes.
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromoCodes.
     */
    distinct?: PromoCodeScalarFieldEnum | PromoCodeScalarFieldEnum[]
  }

  /**
   * PromoCode findMany
   */
  export type PromoCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCodes to fetch.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PromoCodes.
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    distinct?: PromoCodeScalarFieldEnum | PromoCodeScalarFieldEnum[]
  }

  /**
   * PromoCode create
   */
  export type PromoCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * The data needed to create a PromoCode.
     */
    data: XOR<PromoCodeCreateInput, PromoCodeUncheckedCreateInput>
  }

  /**
   * PromoCode createMany
   */
  export type PromoCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PromoCodes.
     */
    data: PromoCodeCreateManyInput | PromoCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PromoCode createManyAndReturn
   */
  export type PromoCodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * The data used to create many PromoCodes.
     */
    data: PromoCodeCreateManyInput | PromoCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PromoCode update
   */
  export type PromoCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * The data needed to update a PromoCode.
     */
    data: XOR<PromoCodeUpdateInput, PromoCodeUncheckedUpdateInput>
    /**
     * Choose, which PromoCode to update.
     */
    where: PromoCodeWhereUniqueInput
  }

  /**
   * PromoCode updateMany
   */
  export type PromoCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PromoCodes.
     */
    data: XOR<PromoCodeUpdateManyMutationInput, PromoCodeUncheckedUpdateManyInput>
    /**
     * Filter which PromoCodes to update
     */
    where?: PromoCodeWhereInput
    /**
     * Limit how many PromoCodes to update.
     */
    limit?: number
  }

  /**
   * PromoCode updateManyAndReturn
   */
  export type PromoCodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * The data used to update PromoCodes.
     */
    data: XOR<PromoCodeUpdateManyMutationInput, PromoCodeUncheckedUpdateManyInput>
    /**
     * Filter which PromoCodes to update
     */
    where?: PromoCodeWhereInput
    /**
     * Limit how many PromoCodes to update.
     */
    limit?: number
  }

  /**
   * PromoCode upsert
   */
  export type PromoCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * The filter to search for the PromoCode to update in case it exists.
     */
    where: PromoCodeWhereUniqueInput
    /**
     * In case the PromoCode found by the `where` argument doesn't exist, create a new PromoCode with this data.
     */
    create: XOR<PromoCodeCreateInput, PromoCodeUncheckedCreateInput>
    /**
     * In case the PromoCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromoCodeUpdateInput, PromoCodeUncheckedUpdateInput>
  }

  /**
   * PromoCode delete
   */
  export type PromoCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter which PromoCode to delete.
     */
    where: PromoCodeWhereUniqueInput
  }

  /**
   * PromoCode deleteMany
   */
  export type PromoCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromoCodes to delete
     */
    where?: PromoCodeWhereInput
    /**
     * Limit how many PromoCodes to delete.
     */
    limit?: number
  }

  /**
   * PromoCode.bookings
   */
  export type PromoCode$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * PromoCode without action
   */
  export type PromoCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
  }


  /**
   * Model ParkingPass
   */

  export type AggregateParkingPass = {
    _count: ParkingPassCountAggregateOutputType | null
    _avg: ParkingPassAvgAggregateOutputType | null
    _sum: ParkingPassSumAggregateOutputType | null
    _min: ParkingPassMinAggregateOutputType | null
    _max: ParkingPassMaxAggregateOutputType | null
  }

  export type ParkingPassAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    placeId: number | null
    price: Decimal | null
  }

  export type ParkingPassSumAggregateOutputType = {
    id: number | null
    userId: number | null
    placeId: number | null
    price: Decimal | null
  }

  export type ParkingPassMinAggregateOutputType = {
    id: number | null
    userId: number | null
    placeId: number | null
    passType: string | null
    passReference: string | null
    startDate: Date | null
    endDate: Date | null
    price: Decimal | null
    status: string | null
    autoRenew: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParkingPassMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    placeId: number | null
    passType: string | null
    passReference: string | null
    startDate: Date | null
    endDate: Date | null
    price: Decimal | null
    status: string | null
    autoRenew: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParkingPassCountAggregateOutputType = {
    id: number
    userId: number
    placeId: number
    passType: number
    passReference: number
    startDate: number
    endDate: number
    price: number
    status: number
    autoRenew: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ParkingPassAvgAggregateInputType = {
    id?: true
    userId?: true
    placeId?: true
    price?: true
  }

  export type ParkingPassSumAggregateInputType = {
    id?: true
    userId?: true
    placeId?: true
    price?: true
  }

  export type ParkingPassMinAggregateInputType = {
    id?: true
    userId?: true
    placeId?: true
    passType?: true
    passReference?: true
    startDate?: true
    endDate?: true
    price?: true
    status?: true
    autoRenew?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParkingPassMaxAggregateInputType = {
    id?: true
    userId?: true
    placeId?: true
    passType?: true
    passReference?: true
    startDate?: true
    endDate?: true
    price?: true
    status?: true
    autoRenew?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParkingPassCountAggregateInputType = {
    id?: true
    userId?: true
    placeId?: true
    passType?: true
    passReference?: true
    startDate?: true
    endDate?: true
    price?: true
    status?: true
    autoRenew?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ParkingPassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParkingPass to aggregate.
     */
    where?: ParkingPassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParkingPasses to fetch.
     */
    orderBy?: ParkingPassOrderByWithRelationInput | ParkingPassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParkingPassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParkingPasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParkingPasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ParkingPasses
    **/
    _count?: true | ParkingPassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParkingPassAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParkingPassSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParkingPassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParkingPassMaxAggregateInputType
  }

  export type GetParkingPassAggregateType<T extends ParkingPassAggregateArgs> = {
        [P in keyof T & keyof AggregateParkingPass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParkingPass[P]>
      : GetScalarType<T[P], AggregateParkingPass[P]>
  }




  export type ParkingPassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParkingPassWhereInput
    orderBy?: ParkingPassOrderByWithAggregationInput | ParkingPassOrderByWithAggregationInput[]
    by: ParkingPassScalarFieldEnum[] | ParkingPassScalarFieldEnum
    having?: ParkingPassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParkingPassCountAggregateInputType | true
    _avg?: ParkingPassAvgAggregateInputType
    _sum?: ParkingPassSumAggregateInputType
    _min?: ParkingPassMinAggregateInputType
    _max?: ParkingPassMaxAggregateInputType
  }

  export type ParkingPassGroupByOutputType = {
    id: number
    userId: number
    placeId: number
    passType: string
    passReference: string | null
    startDate: Date
    endDate: Date
    price: Decimal
    status: string
    autoRenew: boolean
    createdAt: Date
    updatedAt: Date | null
    _count: ParkingPassCountAggregateOutputType | null
    _avg: ParkingPassAvgAggregateOutputType | null
    _sum: ParkingPassSumAggregateOutputType | null
    _min: ParkingPassMinAggregateOutputType | null
    _max: ParkingPassMaxAggregateOutputType | null
  }

  type GetParkingPassGroupByPayload<T extends ParkingPassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParkingPassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParkingPassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParkingPassGroupByOutputType[P]>
            : GetScalarType<T[P], ParkingPassGroupByOutputType[P]>
        }
      >
    >


  export type ParkingPassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    placeId?: boolean
    passType?: boolean
    passReference?: boolean
    startDate?: boolean
    endDate?: boolean
    price?: boolean
    status?: boolean
    autoRenew?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    place?: boolean | PlaceDefaultArgs<ExtArgs>
    parkingPassPayments?: boolean | ParkingPass$parkingPassPaymentsArgs<ExtArgs>
    _count?: boolean | ParkingPassCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parkingPass"]>

  export type ParkingPassSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    placeId?: boolean
    passType?: boolean
    passReference?: boolean
    startDate?: boolean
    endDate?: boolean
    price?: boolean
    status?: boolean
    autoRenew?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parkingPass"]>

  export type ParkingPassSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    placeId?: boolean
    passType?: boolean
    passReference?: boolean
    startDate?: boolean
    endDate?: boolean
    price?: boolean
    status?: boolean
    autoRenew?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parkingPass"]>

  export type ParkingPassSelectScalar = {
    id?: boolean
    userId?: boolean
    placeId?: boolean
    passType?: boolean
    passReference?: boolean
    startDate?: boolean
    endDate?: boolean
    price?: boolean
    status?: boolean
    autoRenew?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ParkingPassOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "placeId" | "passType" | "passReference" | "startDate" | "endDate" | "price" | "status" | "autoRenew" | "createdAt" | "updatedAt", ExtArgs["result"]["parkingPass"]>
  export type ParkingPassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    place?: boolean | PlaceDefaultArgs<ExtArgs>
    parkingPassPayments?: boolean | ParkingPass$parkingPassPaymentsArgs<ExtArgs>
    _count?: boolean | ParkingPassCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ParkingPassIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }
  export type ParkingPassIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }

  export type $ParkingPassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ParkingPass"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      place: Prisma.$PlacePayload<ExtArgs>
      parkingPassPayments: Prisma.$ParkingPassPaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      placeId: number
      passType: string
      passReference: string | null
      startDate: Date
      endDate: Date
      price: Prisma.Decimal
      status: string
      autoRenew: boolean
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["parkingPass"]>
    composites: {}
  }

  type ParkingPassGetPayload<S extends boolean | null | undefined | ParkingPassDefaultArgs> = $Result.GetResult<Prisma.$ParkingPassPayload, S>

  type ParkingPassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ParkingPassFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParkingPassCountAggregateInputType | true
    }

  export interface ParkingPassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ParkingPass'], meta: { name: 'ParkingPass' } }
    /**
     * Find zero or one ParkingPass that matches the filter.
     * @param {ParkingPassFindUniqueArgs} args - Arguments to find a ParkingPass
     * @example
     * // Get one ParkingPass
     * const parkingPass = await prisma.parkingPass.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParkingPassFindUniqueArgs>(args: SelectSubset<T, ParkingPassFindUniqueArgs<ExtArgs>>): Prisma__ParkingPassClient<$Result.GetResult<Prisma.$ParkingPassPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ParkingPass that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ParkingPassFindUniqueOrThrowArgs} args - Arguments to find a ParkingPass
     * @example
     * // Get one ParkingPass
     * const parkingPass = await prisma.parkingPass.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParkingPassFindUniqueOrThrowArgs>(args: SelectSubset<T, ParkingPassFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParkingPassClient<$Result.GetResult<Prisma.$ParkingPassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParkingPass that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingPassFindFirstArgs} args - Arguments to find a ParkingPass
     * @example
     * // Get one ParkingPass
     * const parkingPass = await prisma.parkingPass.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParkingPassFindFirstArgs>(args?: SelectSubset<T, ParkingPassFindFirstArgs<ExtArgs>>): Prisma__ParkingPassClient<$Result.GetResult<Prisma.$ParkingPassPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParkingPass that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingPassFindFirstOrThrowArgs} args - Arguments to find a ParkingPass
     * @example
     * // Get one ParkingPass
     * const parkingPass = await prisma.parkingPass.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParkingPassFindFirstOrThrowArgs>(args?: SelectSubset<T, ParkingPassFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParkingPassClient<$Result.GetResult<Prisma.$ParkingPassPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ParkingPasses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingPassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ParkingPasses
     * const parkingPasses = await prisma.parkingPass.findMany()
     * 
     * // Get first 10 ParkingPasses
     * const parkingPasses = await prisma.parkingPass.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parkingPassWithIdOnly = await prisma.parkingPass.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParkingPassFindManyArgs>(args?: SelectSubset<T, ParkingPassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParkingPassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ParkingPass.
     * @param {ParkingPassCreateArgs} args - Arguments to create a ParkingPass.
     * @example
     * // Create one ParkingPass
     * const ParkingPass = await prisma.parkingPass.create({
     *   data: {
     *     // ... data to create a ParkingPass
     *   }
     * })
     * 
     */
    create<T extends ParkingPassCreateArgs>(args: SelectSubset<T, ParkingPassCreateArgs<ExtArgs>>): Prisma__ParkingPassClient<$Result.GetResult<Prisma.$ParkingPassPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ParkingPasses.
     * @param {ParkingPassCreateManyArgs} args - Arguments to create many ParkingPasses.
     * @example
     * // Create many ParkingPasses
     * const parkingPass = await prisma.parkingPass.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParkingPassCreateManyArgs>(args?: SelectSubset<T, ParkingPassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ParkingPasses and returns the data saved in the database.
     * @param {ParkingPassCreateManyAndReturnArgs} args - Arguments to create many ParkingPasses.
     * @example
     * // Create many ParkingPasses
     * const parkingPass = await prisma.parkingPass.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ParkingPasses and only return the `id`
     * const parkingPassWithIdOnly = await prisma.parkingPass.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParkingPassCreateManyAndReturnArgs>(args?: SelectSubset<T, ParkingPassCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParkingPassPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ParkingPass.
     * @param {ParkingPassDeleteArgs} args - Arguments to delete one ParkingPass.
     * @example
     * // Delete one ParkingPass
     * const ParkingPass = await prisma.parkingPass.delete({
     *   where: {
     *     // ... filter to delete one ParkingPass
     *   }
     * })
     * 
     */
    delete<T extends ParkingPassDeleteArgs>(args: SelectSubset<T, ParkingPassDeleteArgs<ExtArgs>>): Prisma__ParkingPassClient<$Result.GetResult<Prisma.$ParkingPassPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ParkingPass.
     * @param {ParkingPassUpdateArgs} args - Arguments to update one ParkingPass.
     * @example
     * // Update one ParkingPass
     * const parkingPass = await prisma.parkingPass.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParkingPassUpdateArgs>(args: SelectSubset<T, ParkingPassUpdateArgs<ExtArgs>>): Prisma__ParkingPassClient<$Result.GetResult<Prisma.$ParkingPassPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ParkingPasses.
     * @param {ParkingPassDeleteManyArgs} args - Arguments to filter ParkingPasses to delete.
     * @example
     * // Delete a few ParkingPasses
     * const { count } = await prisma.parkingPass.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParkingPassDeleteManyArgs>(args?: SelectSubset<T, ParkingPassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParkingPasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingPassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ParkingPasses
     * const parkingPass = await prisma.parkingPass.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParkingPassUpdateManyArgs>(args: SelectSubset<T, ParkingPassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParkingPasses and returns the data updated in the database.
     * @param {ParkingPassUpdateManyAndReturnArgs} args - Arguments to update many ParkingPasses.
     * @example
     * // Update many ParkingPasses
     * const parkingPass = await prisma.parkingPass.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ParkingPasses and only return the `id`
     * const parkingPassWithIdOnly = await prisma.parkingPass.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ParkingPassUpdateManyAndReturnArgs>(args: SelectSubset<T, ParkingPassUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParkingPassPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ParkingPass.
     * @param {ParkingPassUpsertArgs} args - Arguments to update or create a ParkingPass.
     * @example
     * // Update or create a ParkingPass
     * const parkingPass = await prisma.parkingPass.upsert({
     *   create: {
     *     // ... data to create a ParkingPass
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ParkingPass we want to update
     *   }
     * })
     */
    upsert<T extends ParkingPassUpsertArgs>(args: SelectSubset<T, ParkingPassUpsertArgs<ExtArgs>>): Prisma__ParkingPassClient<$Result.GetResult<Prisma.$ParkingPassPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ParkingPasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingPassCountArgs} args - Arguments to filter ParkingPasses to count.
     * @example
     * // Count the number of ParkingPasses
     * const count = await prisma.parkingPass.count({
     *   where: {
     *     // ... the filter for the ParkingPasses we want to count
     *   }
     * })
    **/
    count<T extends ParkingPassCountArgs>(
      args?: Subset<T, ParkingPassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParkingPassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ParkingPass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingPassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParkingPassAggregateArgs>(args: Subset<T, ParkingPassAggregateArgs>): Prisma.PrismaPromise<GetParkingPassAggregateType<T>>

    /**
     * Group by ParkingPass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingPassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParkingPassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParkingPassGroupByArgs['orderBy'] }
        : { orderBy?: ParkingPassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParkingPassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParkingPassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ParkingPass model
   */
  readonly fields: ParkingPassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ParkingPass.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParkingPassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    place<T extends PlaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlaceDefaultArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parkingPassPayments<T extends ParkingPass$parkingPassPaymentsArgs<ExtArgs> = {}>(args?: Subset<T, ParkingPass$parkingPassPaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParkingPassPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ParkingPass model
   */
  interface ParkingPassFieldRefs {
    readonly id: FieldRef<"ParkingPass", 'Int'>
    readonly userId: FieldRef<"ParkingPass", 'Int'>
    readonly placeId: FieldRef<"ParkingPass", 'Int'>
    readonly passType: FieldRef<"ParkingPass", 'String'>
    readonly passReference: FieldRef<"ParkingPass", 'String'>
    readonly startDate: FieldRef<"ParkingPass", 'DateTime'>
    readonly endDate: FieldRef<"ParkingPass", 'DateTime'>
    readonly price: FieldRef<"ParkingPass", 'Decimal'>
    readonly status: FieldRef<"ParkingPass", 'String'>
    readonly autoRenew: FieldRef<"ParkingPass", 'Boolean'>
    readonly createdAt: FieldRef<"ParkingPass", 'DateTime'>
    readonly updatedAt: FieldRef<"ParkingPass", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ParkingPass findUnique
   */
  export type ParkingPassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingPass
     */
    select?: ParkingPassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingPass
     */
    omit?: ParkingPassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingPassInclude<ExtArgs> | null
    /**
     * Filter, which ParkingPass to fetch.
     */
    where: ParkingPassWhereUniqueInput
  }

  /**
   * ParkingPass findUniqueOrThrow
   */
  export type ParkingPassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingPass
     */
    select?: ParkingPassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingPass
     */
    omit?: ParkingPassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingPassInclude<ExtArgs> | null
    /**
     * Filter, which ParkingPass to fetch.
     */
    where: ParkingPassWhereUniqueInput
  }

  /**
   * ParkingPass findFirst
   */
  export type ParkingPassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingPass
     */
    select?: ParkingPassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingPass
     */
    omit?: ParkingPassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingPassInclude<ExtArgs> | null
    /**
     * Filter, which ParkingPass to fetch.
     */
    where?: ParkingPassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParkingPasses to fetch.
     */
    orderBy?: ParkingPassOrderByWithRelationInput | ParkingPassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParkingPasses.
     */
    cursor?: ParkingPassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParkingPasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParkingPasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParkingPasses.
     */
    distinct?: ParkingPassScalarFieldEnum | ParkingPassScalarFieldEnum[]
  }

  /**
   * ParkingPass findFirstOrThrow
   */
  export type ParkingPassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingPass
     */
    select?: ParkingPassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingPass
     */
    omit?: ParkingPassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingPassInclude<ExtArgs> | null
    /**
     * Filter, which ParkingPass to fetch.
     */
    where?: ParkingPassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParkingPasses to fetch.
     */
    orderBy?: ParkingPassOrderByWithRelationInput | ParkingPassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParkingPasses.
     */
    cursor?: ParkingPassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParkingPasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParkingPasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParkingPasses.
     */
    distinct?: ParkingPassScalarFieldEnum | ParkingPassScalarFieldEnum[]
  }

  /**
   * ParkingPass findMany
   */
  export type ParkingPassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingPass
     */
    select?: ParkingPassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingPass
     */
    omit?: ParkingPassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingPassInclude<ExtArgs> | null
    /**
     * Filter, which ParkingPasses to fetch.
     */
    where?: ParkingPassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParkingPasses to fetch.
     */
    orderBy?: ParkingPassOrderByWithRelationInput | ParkingPassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ParkingPasses.
     */
    cursor?: ParkingPassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParkingPasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParkingPasses.
     */
    skip?: number
    distinct?: ParkingPassScalarFieldEnum | ParkingPassScalarFieldEnum[]
  }

  /**
   * ParkingPass create
   */
  export type ParkingPassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingPass
     */
    select?: ParkingPassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingPass
     */
    omit?: ParkingPassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingPassInclude<ExtArgs> | null
    /**
     * The data needed to create a ParkingPass.
     */
    data: XOR<ParkingPassCreateInput, ParkingPassUncheckedCreateInput>
  }

  /**
   * ParkingPass createMany
   */
  export type ParkingPassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ParkingPasses.
     */
    data: ParkingPassCreateManyInput | ParkingPassCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ParkingPass createManyAndReturn
   */
  export type ParkingPassCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingPass
     */
    select?: ParkingPassSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingPass
     */
    omit?: ParkingPassOmit<ExtArgs> | null
    /**
     * The data used to create many ParkingPasses.
     */
    data: ParkingPassCreateManyInput | ParkingPassCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingPassIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ParkingPass update
   */
  export type ParkingPassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingPass
     */
    select?: ParkingPassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingPass
     */
    omit?: ParkingPassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingPassInclude<ExtArgs> | null
    /**
     * The data needed to update a ParkingPass.
     */
    data: XOR<ParkingPassUpdateInput, ParkingPassUncheckedUpdateInput>
    /**
     * Choose, which ParkingPass to update.
     */
    where: ParkingPassWhereUniqueInput
  }

  /**
   * ParkingPass updateMany
   */
  export type ParkingPassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ParkingPasses.
     */
    data: XOR<ParkingPassUpdateManyMutationInput, ParkingPassUncheckedUpdateManyInput>
    /**
     * Filter which ParkingPasses to update
     */
    where?: ParkingPassWhereInput
    /**
     * Limit how many ParkingPasses to update.
     */
    limit?: number
  }

  /**
   * ParkingPass updateManyAndReturn
   */
  export type ParkingPassUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingPass
     */
    select?: ParkingPassSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingPass
     */
    omit?: ParkingPassOmit<ExtArgs> | null
    /**
     * The data used to update ParkingPasses.
     */
    data: XOR<ParkingPassUpdateManyMutationInput, ParkingPassUncheckedUpdateManyInput>
    /**
     * Filter which ParkingPasses to update
     */
    where?: ParkingPassWhereInput
    /**
     * Limit how many ParkingPasses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingPassIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ParkingPass upsert
   */
  export type ParkingPassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingPass
     */
    select?: ParkingPassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingPass
     */
    omit?: ParkingPassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingPassInclude<ExtArgs> | null
    /**
     * The filter to search for the ParkingPass to update in case it exists.
     */
    where: ParkingPassWhereUniqueInput
    /**
     * In case the ParkingPass found by the `where` argument doesn't exist, create a new ParkingPass with this data.
     */
    create: XOR<ParkingPassCreateInput, ParkingPassUncheckedCreateInput>
    /**
     * In case the ParkingPass was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParkingPassUpdateInput, ParkingPassUncheckedUpdateInput>
  }

  /**
   * ParkingPass delete
   */
  export type ParkingPassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingPass
     */
    select?: ParkingPassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingPass
     */
    omit?: ParkingPassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingPassInclude<ExtArgs> | null
    /**
     * Filter which ParkingPass to delete.
     */
    where: ParkingPassWhereUniqueInput
  }

  /**
   * ParkingPass deleteMany
   */
  export type ParkingPassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParkingPasses to delete
     */
    where?: ParkingPassWhereInput
    /**
     * Limit how many ParkingPasses to delete.
     */
    limit?: number
  }

  /**
   * ParkingPass.parkingPassPayments
   */
  export type ParkingPass$parkingPassPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingPassPayment
     */
    select?: ParkingPassPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingPassPayment
     */
    omit?: ParkingPassPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingPassPaymentInclude<ExtArgs> | null
    where?: ParkingPassPaymentWhereInput
    orderBy?: ParkingPassPaymentOrderByWithRelationInput | ParkingPassPaymentOrderByWithRelationInput[]
    cursor?: ParkingPassPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParkingPassPaymentScalarFieldEnum | ParkingPassPaymentScalarFieldEnum[]
  }

  /**
   * ParkingPass without action
   */
  export type ParkingPassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingPass
     */
    select?: ParkingPassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingPass
     */
    omit?: ParkingPassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingPassInclude<ExtArgs> | null
  }


  /**
   * Model ParkingPassPayment
   */

  export type AggregateParkingPassPayment = {
    _count: ParkingPassPaymentCountAggregateOutputType | null
    _avg: ParkingPassPaymentAvgAggregateOutputType | null
    _sum: ParkingPassPaymentSumAggregateOutputType | null
    _min: ParkingPassPaymentMinAggregateOutputType | null
    _max: ParkingPassPaymentMaxAggregateOutputType | null
  }

  export type ParkingPassPaymentAvgAggregateOutputType = {
    id: number | null
    passId: number | null
    paymentMethodId: number | null
    amount: Decimal | null
  }

  export type ParkingPassPaymentSumAggregateOutputType = {
    id: number | null
    passId: number | null
    paymentMethodId: number | null
    amount: Decimal | null
  }

  export type ParkingPassPaymentMinAggregateOutputType = {
    id: number | null
    passId: number | null
    paymentMethodId: number | null
    amount: Decimal | null
    paymentStatus: string | null
    transactionReference: string | null
    paymentDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParkingPassPaymentMaxAggregateOutputType = {
    id: number | null
    passId: number | null
    paymentMethodId: number | null
    amount: Decimal | null
    paymentStatus: string | null
    transactionReference: string | null
    paymentDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParkingPassPaymentCountAggregateOutputType = {
    id: number
    passId: number
    paymentMethodId: number
    amount: number
    paymentStatus: number
    transactionReference: number
    paymentDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ParkingPassPaymentAvgAggregateInputType = {
    id?: true
    passId?: true
    paymentMethodId?: true
    amount?: true
  }

  export type ParkingPassPaymentSumAggregateInputType = {
    id?: true
    passId?: true
    paymentMethodId?: true
    amount?: true
  }

  export type ParkingPassPaymentMinAggregateInputType = {
    id?: true
    passId?: true
    paymentMethodId?: true
    amount?: true
    paymentStatus?: true
    transactionReference?: true
    paymentDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParkingPassPaymentMaxAggregateInputType = {
    id?: true
    passId?: true
    paymentMethodId?: true
    amount?: true
    paymentStatus?: true
    transactionReference?: true
    paymentDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParkingPassPaymentCountAggregateInputType = {
    id?: true
    passId?: true
    paymentMethodId?: true
    amount?: true
    paymentStatus?: true
    transactionReference?: true
    paymentDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ParkingPassPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParkingPassPayment to aggregate.
     */
    where?: ParkingPassPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParkingPassPayments to fetch.
     */
    orderBy?: ParkingPassPaymentOrderByWithRelationInput | ParkingPassPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParkingPassPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParkingPassPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParkingPassPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ParkingPassPayments
    **/
    _count?: true | ParkingPassPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParkingPassPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParkingPassPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParkingPassPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParkingPassPaymentMaxAggregateInputType
  }

  export type GetParkingPassPaymentAggregateType<T extends ParkingPassPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateParkingPassPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParkingPassPayment[P]>
      : GetScalarType<T[P], AggregateParkingPassPayment[P]>
  }




  export type ParkingPassPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParkingPassPaymentWhereInput
    orderBy?: ParkingPassPaymentOrderByWithAggregationInput | ParkingPassPaymentOrderByWithAggregationInput[]
    by: ParkingPassPaymentScalarFieldEnum[] | ParkingPassPaymentScalarFieldEnum
    having?: ParkingPassPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParkingPassPaymentCountAggregateInputType | true
    _avg?: ParkingPassPaymentAvgAggregateInputType
    _sum?: ParkingPassPaymentSumAggregateInputType
    _min?: ParkingPassPaymentMinAggregateInputType
    _max?: ParkingPassPaymentMaxAggregateInputType
  }

  export type ParkingPassPaymentGroupByOutputType = {
    id: number
    passId: number
    paymentMethodId: number
    amount: Decimal
    paymentStatus: string
    transactionReference: string | null
    paymentDate: Date | null
    createdAt: Date
    updatedAt: Date | null
    _count: ParkingPassPaymentCountAggregateOutputType | null
    _avg: ParkingPassPaymentAvgAggregateOutputType | null
    _sum: ParkingPassPaymentSumAggregateOutputType | null
    _min: ParkingPassPaymentMinAggregateOutputType | null
    _max: ParkingPassPaymentMaxAggregateOutputType | null
  }

  type GetParkingPassPaymentGroupByPayload<T extends ParkingPassPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParkingPassPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParkingPassPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParkingPassPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], ParkingPassPaymentGroupByOutputType[P]>
        }
      >
    >


  export type ParkingPassPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passId?: boolean
    paymentMethodId?: boolean
    amount?: boolean
    paymentStatus?: boolean
    transactionReference?: boolean
    paymentDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parkingPass?: boolean | ParkingPassDefaultArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parkingPassPayment"]>

  export type ParkingPassPaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passId?: boolean
    paymentMethodId?: boolean
    amount?: boolean
    paymentStatus?: boolean
    transactionReference?: boolean
    paymentDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parkingPass?: boolean | ParkingPassDefaultArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parkingPassPayment"]>

  export type ParkingPassPaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passId?: boolean
    paymentMethodId?: boolean
    amount?: boolean
    paymentStatus?: boolean
    transactionReference?: boolean
    paymentDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parkingPass?: boolean | ParkingPassDefaultArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parkingPassPayment"]>

  export type ParkingPassPaymentSelectScalar = {
    id?: boolean
    passId?: boolean
    paymentMethodId?: boolean
    amount?: boolean
    paymentStatus?: boolean
    transactionReference?: boolean
    paymentDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ParkingPassPaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "passId" | "paymentMethodId" | "amount" | "paymentStatus" | "transactionReference" | "paymentDate" | "createdAt" | "updatedAt", ExtArgs["result"]["parkingPassPayment"]>
  export type ParkingPassPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parkingPass?: boolean | ParkingPassDefaultArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
  }
  export type ParkingPassPaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parkingPass?: boolean | ParkingPassDefaultArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
  }
  export type ParkingPassPaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parkingPass?: boolean | ParkingPassDefaultArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
  }

  export type $ParkingPassPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ParkingPassPayment"
    objects: {
      parkingPass: Prisma.$ParkingPassPayload<ExtArgs>
      paymentMethod: Prisma.$PaymentMethodPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      passId: number
      paymentMethodId: number
      amount: Prisma.Decimal
      paymentStatus: string
      transactionReference: string | null
      paymentDate: Date | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["parkingPassPayment"]>
    composites: {}
  }

  type ParkingPassPaymentGetPayload<S extends boolean | null | undefined | ParkingPassPaymentDefaultArgs> = $Result.GetResult<Prisma.$ParkingPassPaymentPayload, S>

  type ParkingPassPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ParkingPassPaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParkingPassPaymentCountAggregateInputType | true
    }

  export interface ParkingPassPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ParkingPassPayment'], meta: { name: 'ParkingPassPayment' } }
    /**
     * Find zero or one ParkingPassPayment that matches the filter.
     * @param {ParkingPassPaymentFindUniqueArgs} args - Arguments to find a ParkingPassPayment
     * @example
     * // Get one ParkingPassPayment
     * const parkingPassPayment = await prisma.parkingPassPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParkingPassPaymentFindUniqueArgs>(args: SelectSubset<T, ParkingPassPaymentFindUniqueArgs<ExtArgs>>): Prisma__ParkingPassPaymentClient<$Result.GetResult<Prisma.$ParkingPassPaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ParkingPassPayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ParkingPassPaymentFindUniqueOrThrowArgs} args - Arguments to find a ParkingPassPayment
     * @example
     * // Get one ParkingPassPayment
     * const parkingPassPayment = await prisma.parkingPassPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParkingPassPaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, ParkingPassPaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParkingPassPaymentClient<$Result.GetResult<Prisma.$ParkingPassPaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParkingPassPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingPassPaymentFindFirstArgs} args - Arguments to find a ParkingPassPayment
     * @example
     * // Get one ParkingPassPayment
     * const parkingPassPayment = await prisma.parkingPassPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParkingPassPaymentFindFirstArgs>(args?: SelectSubset<T, ParkingPassPaymentFindFirstArgs<ExtArgs>>): Prisma__ParkingPassPaymentClient<$Result.GetResult<Prisma.$ParkingPassPaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParkingPassPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingPassPaymentFindFirstOrThrowArgs} args - Arguments to find a ParkingPassPayment
     * @example
     * // Get one ParkingPassPayment
     * const parkingPassPayment = await prisma.parkingPassPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParkingPassPaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, ParkingPassPaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParkingPassPaymentClient<$Result.GetResult<Prisma.$ParkingPassPaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ParkingPassPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingPassPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ParkingPassPayments
     * const parkingPassPayments = await prisma.parkingPassPayment.findMany()
     * 
     * // Get first 10 ParkingPassPayments
     * const parkingPassPayments = await prisma.parkingPassPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parkingPassPaymentWithIdOnly = await prisma.parkingPassPayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParkingPassPaymentFindManyArgs>(args?: SelectSubset<T, ParkingPassPaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParkingPassPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ParkingPassPayment.
     * @param {ParkingPassPaymentCreateArgs} args - Arguments to create a ParkingPassPayment.
     * @example
     * // Create one ParkingPassPayment
     * const ParkingPassPayment = await prisma.parkingPassPayment.create({
     *   data: {
     *     // ... data to create a ParkingPassPayment
     *   }
     * })
     * 
     */
    create<T extends ParkingPassPaymentCreateArgs>(args: SelectSubset<T, ParkingPassPaymentCreateArgs<ExtArgs>>): Prisma__ParkingPassPaymentClient<$Result.GetResult<Prisma.$ParkingPassPaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ParkingPassPayments.
     * @param {ParkingPassPaymentCreateManyArgs} args - Arguments to create many ParkingPassPayments.
     * @example
     * // Create many ParkingPassPayments
     * const parkingPassPayment = await prisma.parkingPassPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParkingPassPaymentCreateManyArgs>(args?: SelectSubset<T, ParkingPassPaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ParkingPassPayments and returns the data saved in the database.
     * @param {ParkingPassPaymentCreateManyAndReturnArgs} args - Arguments to create many ParkingPassPayments.
     * @example
     * // Create many ParkingPassPayments
     * const parkingPassPayment = await prisma.parkingPassPayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ParkingPassPayments and only return the `id`
     * const parkingPassPaymentWithIdOnly = await prisma.parkingPassPayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParkingPassPaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, ParkingPassPaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParkingPassPaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ParkingPassPayment.
     * @param {ParkingPassPaymentDeleteArgs} args - Arguments to delete one ParkingPassPayment.
     * @example
     * // Delete one ParkingPassPayment
     * const ParkingPassPayment = await prisma.parkingPassPayment.delete({
     *   where: {
     *     // ... filter to delete one ParkingPassPayment
     *   }
     * })
     * 
     */
    delete<T extends ParkingPassPaymentDeleteArgs>(args: SelectSubset<T, ParkingPassPaymentDeleteArgs<ExtArgs>>): Prisma__ParkingPassPaymentClient<$Result.GetResult<Prisma.$ParkingPassPaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ParkingPassPayment.
     * @param {ParkingPassPaymentUpdateArgs} args - Arguments to update one ParkingPassPayment.
     * @example
     * // Update one ParkingPassPayment
     * const parkingPassPayment = await prisma.parkingPassPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParkingPassPaymentUpdateArgs>(args: SelectSubset<T, ParkingPassPaymentUpdateArgs<ExtArgs>>): Prisma__ParkingPassPaymentClient<$Result.GetResult<Prisma.$ParkingPassPaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ParkingPassPayments.
     * @param {ParkingPassPaymentDeleteManyArgs} args - Arguments to filter ParkingPassPayments to delete.
     * @example
     * // Delete a few ParkingPassPayments
     * const { count } = await prisma.parkingPassPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParkingPassPaymentDeleteManyArgs>(args?: SelectSubset<T, ParkingPassPaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParkingPassPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingPassPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ParkingPassPayments
     * const parkingPassPayment = await prisma.parkingPassPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParkingPassPaymentUpdateManyArgs>(args: SelectSubset<T, ParkingPassPaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParkingPassPayments and returns the data updated in the database.
     * @param {ParkingPassPaymentUpdateManyAndReturnArgs} args - Arguments to update many ParkingPassPayments.
     * @example
     * // Update many ParkingPassPayments
     * const parkingPassPayment = await prisma.parkingPassPayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ParkingPassPayments and only return the `id`
     * const parkingPassPaymentWithIdOnly = await prisma.parkingPassPayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ParkingPassPaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, ParkingPassPaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParkingPassPaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ParkingPassPayment.
     * @param {ParkingPassPaymentUpsertArgs} args - Arguments to update or create a ParkingPassPayment.
     * @example
     * // Update or create a ParkingPassPayment
     * const parkingPassPayment = await prisma.parkingPassPayment.upsert({
     *   create: {
     *     // ... data to create a ParkingPassPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ParkingPassPayment we want to update
     *   }
     * })
     */
    upsert<T extends ParkingPassPaymentUpsertArgs>(args: SelectSubset<T, ParkingPassPaymentUpsertArgs<ExtArgs>>): Prisma__ParkingPassPaymentClient<$Result.GetResult<Prisma.$ParkingPassPaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ParkingPassPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingPassPaymentCountArgs} args - Arguments to filter ParkingPassPayments to count.
     * @example
     * // Count the number of ParkingPassPayments
     * const count = await prisma.parkingPassPayment.count({
     *   where: {
     *     // ... the filter for the ParkingPassPayments we want to count
     *   }
     * })
    **/
    count<T extends ParkingPassPaymentCountArgs>(
      args?: Subset<T, ParkingPassPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParkingPassPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ParkingPassPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingPassPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParkingPassPaymentAggregateArgs>(args: Subset<T, ParkingPassPaymentAggregateArgs>): Prisma.PrismaPromise<GetParkingPassPaymentAggregateType<T>>

    /**
     * Group by ParkingPassPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingPassPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParkingPassPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParkingPassPaymentGroupByArgs['orderBy'] }
        : { orderBy?: ParkingPassPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParkingPassPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParkingPassPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ParkingPassPayment model
   */
  readonly fields: ParkingPassPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ParkingPassPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParkingPassPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parkingPass<T extends ParkingPassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParkingPassDefaultArgs<ExtArgs>>): Prisma__ParkingPassClient<$Result.GetResult<Prisma.$ParkingPassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    paymentMethod<T extends PaymentMethodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentMethodDefaultArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ParkingPassPayment model
   */
  interface ParkingPassPaymentFieldRefs {
    readonly id: FieldRef<"ParkingPassPayment", 'Int'>
    readonly passId: FieldRef<"ParkingPassPayment", 'Int'>
    readonly paymentMethodId: FieldRef<"ParkingPassPayment", 'Int'>
    readonly amount: FieldRef<"ParkingPassPayment", 'Decimal'>
    readonly paymentStatus: FieldRef<"ParkingPassPayment", 'String'>
    readonly transactionReference: FieldRef<"ParkingPassPayment", 'String'>
    readonly paymentDate: FieldRef<"ParkingPassPayment", 'DateTime'>
    readonly createdAt: FieldRef<"ParkingPassPayment", 'DateTime'>
    readonly updatedAt: FieldRef<"ParkingPassPayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ParkingPassPayment findUnique
   */
  export type ParkingPassPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingPassPayment
     */
    select?: ParkingPassPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingPassPayment
     */
    omit?: ParkingPassPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingPassPaymentInclude<ExtArgs> | null
    /**
     * Filter, which ParkingPassPayment to fetch.
     */
    where: ParkingPassPaymentWhereUniqueInput
  }

  /**
   * ParkingPassPayment findUniqueOrThrow
   */
  export type ParkingPassPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingPassPayment
     */
    select?: ParkingPassPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingPassPayment
     */
    omit?: ParkingPassPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingPassPaymentInclude<ExtArgs> | null
    /**
     * Filter, which ParkingPassPayment to fetch.
     */
    where: ParkingPassPaymentWhereUniqueInput
  }

  /**
   * ParkingPassPayment findFirst
   */
  export type ParkingPassPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingPassPayment
     */
    select?: ParkingPassPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingPassPayment
     */
    omit?: ParkingPassPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingPassPaymentInclude<ExtArgs> | null
    /**
     * Filter, which ParkingPassPayment to fetch.
     */
    where?: ParkingPassPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParkingPassPayments to fetch.
     */
    orderBy?: ParkingPassPaymentOrderByWithRelationInput | ParkingPassPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParkingPassPayments.
     */
    cursor?: ParkingPassPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParkingPassPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParkingPassPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParkingPassPayments.
     */
    distinct?: ParkingPassPaymentScalarFieldEnum | ParkingPassPaymentScalarFieldEnum[]
  }

  /**
   * ParkingPassPayment findFirstOrThrow
   */
  export type ParkingPassPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingPassPayment
     */
    select?: ParkingPassPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingPassPayment
     */
    omit?: ParkingPassPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingPassPaymentInclude<ExtArgs> | null
    /**
     * Filter, which ParkingPassPayment to fetch.
     */
    where?: ParkingPassPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParkingPassPayments to fetch.
     */
    orderBy?: ParkingPassPaymentOrderByWithRelationInput | ParkingPassPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParkingPassPayments.
     */
    cursor?: ParkingPassPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParkingPassPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParkingPassPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParkingPassPayments.
     */
    distinct?: ParkingPassPaymentScalarFieldEnum | ParkingPassPaymentScalarFieldEnum[]
  }

  /**
   * ParkingPassPayment findMany
   */
  export type ParkingPassPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingPassPayment
     */
    select?: ParkingPassPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingPassPayment
     */
    omit?: ParkingPassPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingPassPaymentInclude<ExtArgs> | null
    /**
     * Filter, which ParkingPassPayments to fetch.
     */
    where?: ParkingPassPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParkingPassPayments to fetch.
     */
    orderBy?: ParkingPassPaymentOrderByWithRelationInput | ParkingPassPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ParkingPassPayments.
     */
    cursor?: ParkingPassPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParkingPassPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParkingPassPayments.
     */
    skip?: number
    distinct?: ParkingPassPaymentScalarFieldEnum | ParkingPassPaymentScalarFieldEnum[]
  }

  /**
   * ParkingPassPayment create
   */
  export type ParkingPassPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingPassPayment
     */
    select?: ParkingPassPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingPassPayment
     */
    omit?: ParkingPassPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingPassPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a ParkingPassPayment.
     */
    data: XOR<ParkingPassPaymentCreateInput, ParkingPassPaymentUncheckedCreateInput>
  }

  /**
   * ParkingPassPayment createMany
   */
  export type ParkingPassPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ParkingPassPayments.
     */
    data: ParkingPassPaymentCreateManyInput | ParkingPassPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ParkingPassPayment createManyAndReturn
   */
  export type ParkingPassPaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingPassPayment
     */
    select?: ParkingPassPaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingPassPayment
     */
    omit?: ParkingPassPaymentOmit<ExtArgs> | null
    /**
     * The data used to create many ParkingPassPayments.
     */
    data: ParkingPassPaymentCreateManyInput | ParkingPassPaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingPassPaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ParkingPassPayment update
   */
  export type ParkingPassPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingPassPayment
     */
    select?: ParkingPassPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingPassPayment
     */
    omit?: ParkingPassPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingPassPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a ParkingPassPayment.
     */
    data: XOR<ParkingPassPaymentUpdateInput, ParkingPassPaymentUncheckedUpdateInput>
    /**
     * Choose, which ParkingPassPayment to update.
     */
    where: ParkingPassPaymentWhereUniqueInput
  }

  /**
   * ParkingPassPayment updateMany
   */
  export type ParkingPassPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ParkingPassPayments.
     */
    data: XOR<ParkingPassPaymentUpdateManyMutationInput, ParkingPassPaymentUncheckedUpdateManyInput>
    /**
     * Filter which ParkingPassPayments to update
     */
    where?: ParkingPassPaymentWhereInput
    /**
     * Limit how many ParkingPassPayments to update.
     */
    limit?: number
  }

  /**
   * ParkingPassPayment updateManyAndReturn
   */
  export type ParkingPassPaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingPassPayment
     */
    select?: ParkingPassPaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingPassPayment
     */
    omit?: ParkingPassPaymentOmit<ExtArgs> | null
    /**
     * The data used to update ParkingPassPayments.
     */
    data: XOR<ParkingPassPaymentUpdateManyMutationInput, ParkingPassPaymentUncheckedUpdateManyInput>
    /**
     * Filter which ParkingPassPayments to update
     */
    where?: ParkingPassPaymentWhereInput
    /**
     * Limit how many ParkingPassPayments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingPassPaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ParkingPassPayment upsert
   */
  export type ParkingPassPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingPassPayment
     */
    select?: ParkingPassPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingPassPayment
     */
    omit?: ParkingPassPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingPassPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the ParkingPassPayment to update in case it exists.
     */
    where: ParkingPassPaymentWhereUniqueInput
    /**
     * In case the ParkingPassPayment found by the `where` argument doesn't exist, create a new ParkingPassPayment with this data.
     */
    create: XOR<ParkingPassPaymentCreateInput, ParkingPassPaymentUncheckedCreateInput>
    /**
     * In case the ParkingPassPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParkingPassPaymentUpdateInput, ParkingPassPaymentUncheckedUpdateInput>
  }

  /**
   * ParkingPassPayment delete
   */
  export type ParkingPassPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingPassPayment
     */
    select?: ParkingPassPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingPassPayment
     */
    omit?: ParkingPassPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingPassPaymentInclude<ExtArgs> | null
    /**
     * Filter which ParkingPassPayment to delete.
     */
    where: ParkingPassPaymentWhereUniqueInput
  }

  /**
   * ParkingPassPayment deleteMany
   */
  export type ParkingPassPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParkingPassPayments to delete
     */
    where?: ParkingPassPaymentWhereInput
    /**
     * Limit how many ParkingPassPayments to delete.
     */
    limit?: number
  }

  /**
   * ParkingPassPayment without action
   */
  export type ParkingPassPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingPassPayment
     */
    select?: ParkingPassPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkingPassPayment
     */
    omit?: ParkingPassPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingPassPaymentInclude<ExtArgs> | null
  }


  /**
   * Model AccessLog
   */

  export type AggregateAccessLog = {
    _count: AccessLogCountAggregateOutputType | null
    _avg: AccessLogAvgAggregateOutputType | null
    _sum: AccessLogSumAggregateOutputType | null
    _min: AccessLogMinAggregateOutputType | null
    _max: AccessLogMaxAggregateOutputType | null
  }

  export type AccessLogAvgAggregateOutputType = {
    id: number | null
    bookingId: number | null
  }

  export type AccessLogSumAggregateOutputType = {
    id: number | null
    bookingId: number | null
  }

  export type AccessLogMinAggregateOutputType = {
    id: number | null
    bookingId: number | null
    logType: string | null
    logTime: Date | null
    verificationMethod: string | null
    verifiedBy: string | null
    location: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type AccessLogMaxAggregateOutputType = {
    id: number | null
    bookingId: number | null
    logType: string | null
    logTime: Date | null
    verificationMethod: string | null
    verifiedBy: string | null
    location: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type AccessLogCountAggregateOutputType = {
    id: number
    bookingId: number
    logType: number
    logTime: number
    verificationMethod: number
    verifiedBy: number
    location: number
    notes: number
    createdAt: number
    _all: number
  }


  export type AccessLogAvgAggregateInputType = {
    id?: true
    bookingId?: true
  }

  export type AccessLogSumAggregateInputType = {
    id?: true
    bookingId?: true
  }

  export type AccessLogMinAggregateInputType = {
    id?: true
    bookingId?: true
    logType?: true
    logTime?: true
    verificationMethod?: true
    verifiedBy?: true
    location?: true
    notes?: true
    createdAt?: true
  }

  export type AccessLogMaxAggregateInputType = {
    id?: true
    bookingId?: true
    logType?: true
    logTime?: true
    verificationMethod?: true
    verifiedBy?: true
    location?: true
    notes?: true
    createdAt?: true
  }

  export type AccessLogCountAggregateInputType = {
    id?: true
    bookingId?: true
    logType?: true
    logTime?: true
    verificationMethod?: true
    verifiedBy?: true
    location?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type AccessLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccessLog to aggregate.
     */
    where?: AccessLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessLogs to fetch.
     */
    orderBy?: AccessLogOrderByWithRelationInput | AccessLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccessLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccessLogs
    **/
    _count?: true | AccessLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccessLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccessLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccessLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccessLogMaxAggregateInputType
  }

  export type GetAccessLogAggregateType<T extends AccessLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAccessLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccessLog[P]>
      : GetScalarType<T[P], AggregateAccessLog[P]>
  }




  export type AccessLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccessLogWhereInput
    orderBy?: AccessLogOrderByWithAggregationInput | AccessLogOrderByWithAggregationInput[]
    by: AccessLogScalarFieldEnum[] | AccessLogScalarFieldEnum
    having?: AccessLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccessLogCountAggregateInputType | true
    _avg?: AccessLogAvgAggregateInputType
    _sum?: AccessLogSumAggregateInputType
    _min?: AccessLogMinAggregateInputType
    _max?: AccessLogMaxAggregateInputType
  }

  export type AccessLogGroupByOutputType = {
    id: number
    bookingId: number
    logType: string
    logTime: Date
    verificationMethod: string | null
    verifiedBy: string | null
    location: string | null
    notes: string | null
    createdAt: Date
    _count: AccessLogCountAggregateOutputType | null
    _avg: AccessLogAvgAggregateOutputType | null
    _sum: AccessLogSumAggregateOutputType | null
    _min: AccessLogMinAggregateOutputType | null
    _max: AccessLogMaxAggregateOutputType | null
  }

  type GetAccessLogGroupByPayload<T extends AccessLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccessLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccessLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccessLogGroupByOutputType[P]>
            : GetScalarType<T[P], AccessLogGroupByOutputType[P]>
        }
      >
    >


  export type AccessLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    logType?: boolean
    logTime?: boolean
    verificationMethod?: boolean
    verifiedBy?: boolean
    location?: boolean
    notes?: boolean
    createdAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accessLog"]>

  export type AccessLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    logType?: boolean
    logTime?: boolean
    verificationMethod?: boolean
    verifiedBy?: boolean
    location?: boolean
    notes?: boolean
    createdAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accessLog"]>

  export type AccessLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    logType?: boolean
    logTime?: boolean
    verificationMethod?: boolean
    verifiedBy?: boolean
    location?: boolean
    notes?: boolean
    createdAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accessLog"]>

  export type AccessLogSelectScalar = {
    id?: boolean
    bookingId?: boolean
    logType?: boolean
    logTime?: boolean
    verificationMethod?: boolean
    verifiedBy?: boolean
    location?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type AccessLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "logType" | "logTime" | "verificationMethod" | "verifiedBy" | "location" | "notes" | "createdAt", ExtArgs["result"]["accessLog"]>
  export type AccessLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }
  export type AccessLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }
  export type AccessLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }

  export type $AccessLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccessLog"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bookingId: number
      logType: string
      logTime: Date
      verificationMethod: string | null
      verifiedBy: string | null
      location: string | null
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["accessLog"]>
    composites: {}
  }

  type AccessLogGetPayload<S extends boolean | null | undefined | AccessLogDefaultArgs> = $Result.GetResult<Prisma.$AccessLogPayload, S>

  type AccessLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccessLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccessLogCountAggregateInputType | true
    }

  export interface AccessLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccessLog'], meta: { name: 'AccessLog' } }
    /**
     * Find zero or one AccessLog that matches the filter.
     * @param {AccessLogFindUniqueArgs} args - Arguments to find a AccessLog
     * @example
     * // Get one AccessLog
     * const accessLog = await prisma.accessLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccessLogFindUniqueArgs>(args: SelectSubset<T, AccessLogFindUniqueArgs<ExtArgs>>): Prisma__AccessLogClient<$Result.GetResult<Prisma.$AccessLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AccessLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccessLogFindUniqueOrThrowArgs} args - Arguments to find a AccessLog
     * @example
     * // Get one AccessLog
     * const accessLog = await prisma.accessLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccessLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AccessLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccessLogClient<$Result.GetResult<Prisma.$AccessLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccessLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessLogFindFirstArgs} args - Arguments to find a AccessLog
     * @example
     * // Get one AccessLog
     * const accessLog = await prisma.accessLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccessLogFindFirstArgs>(args?: SelectSubset<T, AccessLogFindFirstArgs<ExtArgs>>): Prisma__AccessLogClient<$Result.GetResult<Prisma.$AccessLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccessLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessLogFindFirstOrThrowArgs} args - Arguments to find a AccessLog
     * @example
     * // Get one AccessLog
     * const accessLog = await prisma.accessLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccessLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AccessLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccessLogClient<$Result.GetResult<Prisma.$AccessLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AccessLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccessLogs
     * const accessLogs = await prisma.accessLog.findMany()
     * 
     * // Get first 10 AccessLogs
     * const accessLogs = await prisma.accessLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accessLogWithIdOnly = await prisma.accessLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccessLogFindManyArgs>(args?: SelectSubset<T, AccessLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AccessLog.
     * @param {AccessLogCreateArgs} args - Arguments to create a AccessLog.
     * @example
     * // Create one AccessLog
     * const AccessLog = await prisma.accessLog.create({
     *   data: {
     *     // ... data to create a AccessLog
     *   }
     * })
     * 
     */
    create<T extends AccessLogCreateArgs>(args: SelectSubset<T, AccessLogCreateArgs<ExtArgs>>): Prisma__AccessLogClient<$Result.GetResult<Prisma.$AccessLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AccessLogs.
     * @param {AccessLogCreateManyArgs} args - Arguments to create many AccessLogs.
     * @example
     * // Create many AccessLogs
     * const accessLog = await prisma.accessLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccessLogCreateManyArgs>(args?: SelectSubset<T, AccessLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AccessLogs and returns the data saved in the database.
     * @param {AccessLogCreateManyAndReturnArgs} args - Arguments to create many AccessLogs.
     * @example
     * // Create many AccessLogs
     * const accessLog = await prisma.accessLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AccessLogs and only return the `id`
     * const accessLogWithIdOnly = await prisma.accessLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccessLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AccessLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AccessLog.
     * @param {AccessLogDeleteArgs} args - Arguments to delete one AccessLog.
     * @example
     * // Delete one AccessLog
     * const AccessLog = await prisma.accessLog.delete({
     *   where: {
     *     // ... filter to delete one AccessLog
     *   }
     * })
     * 
     */
    delete<T extends AccessLogDeleteArgs>(args: SelectSubset<T, AccessLogDeleteArgs<ExtArgs>>): Prisma__AccessLogClient<$Result.GetResult<Prisma.$AccessLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AccessLog.
     * @param {AccessLogUpdateArgs} args - Arguments to update one AccessLog.
     * @example
     * // Update one AccessLog
     * const accessLog = await prisma.accessLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccessLogUpdateArgs>(args: SelectSubset<T, AccessLogUpdateArgs<ExtArgs>>): Prisma__AccessLogClient<$Result.GetResult<Prisma.$AccessLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AccessLogs.
     * @param {AccessLogDeleteManyArgs} args - Arguments to filter AccessLogs to delete.
     * @example
     * // Delete a few AccessLogs
     * const { count } = await prisma.accessLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccessLogDeleteManyArgs>(args?: SelectSubset<T, AccessLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccessLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccessLogs
     * const accessLog = await prisma.accessLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccessLogUpdateManyArgs>(args: SelectSubset<T, AccessLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccessLogs and returns the data updated in the database.
     * @param {AccessLogUpdateManyAndReturnArgs} args - Arguments to update many AccessLogs.
     * @example
     * // Update many AccessLogs
     * const accessLog = await prisma.accessLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AccessLogs and only return the `id`
     * const accessLogWithIdOnly = await prisma.accessLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccessLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AccessLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AccessLog.
     * @param {AccessLogUpsertArgs} args - Arguments to update or create a AccessLog.
     * @example
     * // Update or create a AccessLog
     * const accessLog = await prisma.accessLog.upsert({
     *   create: {
     *     // ... data to create a AccessLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccessLog we want to update
     *   }
     * })
     */
    upsert<T extends AccessLogUpsertArgs>(args: SelectSubset<T, AccessLogUpsertArgs<ExtArgs>>): Prisma__AccessLogClient<$Result.GetResult<Prisma.$AccessLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AccessLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessLogCountArgs} args - Arguments to filter AccessLogs to count.
     * @example
     * // Count the number of AccessLogs
     * const count = await prisma.accessLog.count({
     *   where: {
     *     // ... the filter for the AccessLogs we want to count
     *   }
     * })
    **/
    count<T extends AccessLogCountArgs>(
      args?: Subset<T, AccessLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccessLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccessLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccessLogAggregateArgs>(args: Subset<T, AccessLogAggregateArgs>): Prisma.PrismaPromise<GetAccessLogAggregateType<T>>

    /**
     * Group by AccessLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccessLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccessLogGroupByArgs['orderBy'] }
        : { orderBy?: AccessLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccessLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccessLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccessLog model
   */
  readonly fields: AccessLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccessLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccessLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccessLog model
   */
  interface AccessLogFieldRefs {
    readonly id: FieldRef<"AccessLog", 'Int'>
    readonly bookingId: FieldRef<"AccessLog", 'Int'>
    readonly logType: FieldRef<"AccessLog", 'String'>
    readonly logTime: FieldRef<"AccessLog", 'DateTime'>
    readonly verificationMethod: FieldRef<"AccessLog", 'String'>
    readonly verifiedBy: FieldRef<"AccessLog", 'String'>
    readonly location: FieldRef<"AccessLog", 'String'>
    readonly notes: FieldRef<"AccessLog", 'String'>
    readonly createdAt: FieldRef<"AccessLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AccessLog findUnique
   */
  export type AccessLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessLog
     */
    select?: AccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessLog
     */
    omit?: AccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessLogInclude<ExtArgs> | null
    /**
     * Filter, which AccessLog to fetch.
     */
    where: AccessLogWhereUniqueInput
  }

  /**
   * AccessLog findUniqueOrThrow
   */
  export type AccessLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessLog
     */
    select?: AccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessLog
     */
    omit?: AccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessLogInclude<ExtArgs> | null
    /**
     * Filter, which AccessLog to fetch.
     */
    where: AccessLogWhereUniqueInput
  }

  /**
   * AccessLog findFirst
   */
  export type AccessLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessLog
     */
    select?: AccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessLog
     */
    omit?: AccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessLogInclude<ExtArgs> | null
    /**
     * Filter, which AccessLog to fetch.
     */
    where?: AccessLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessLogs to fetch.
     */
    orderBy?: AccessLogOrderByWithRelationInput | AccessLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccessLogs.
     */
    cursor?: AccessLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccessLogs.
     */
    distinct?: AccessLogScalarFieldEnum | AccessLogScalarFieldEnum[]
  }

  /**
   * AccessLog findFirstOrThrow
   */
  export type AccessLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessLog
     */
    select?: AccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessLog
     */
    omit?: AccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessLogInclude<ExtArgs> | null
    /**
     * Filter, which AccessLog to fetch.
     */
    where?: AccessLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessLogs to fetch.
     */
    orderBy?: AccessLogOrderByWithRelationInput | AccessLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccessLogs.
     */
    cursor?: AccessLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccessLogs.
     */
    distinct?: AccessLogScalarFieldEnum | AccessLogScalarFieldEnum[]
  }

  /**
   * AccessLog findMany
   */
  export type AccessLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessLog
     */
    select?: AccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessLog
     */
    omit?: AccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessLogInclude<ExtArgs> | null
    /**
     * Filter, which AccessLogs to fetch.
     */
    where?: AccessLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessLogs to fetch.
     */
    orderBy?: AccessLogOrderByWithRelationInput | AccessLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccessLogs.
     */
    cursor?: AccessLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessLogs.
     */
    skip?: number
    distinct?: AccessLogScalarFieldEnum | AccessLogScalarFieldEnum[]
  }

  /**
   * AccessLog create
   */
  export type AccessLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessLog
     */
    select?: AccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessLog
     */
    omit?: AccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AccessLog.
     */
    data: XOR<AccessLogCreateInput, AccessLogUncheckedCreateInput>
  }

  /**
   * AccessLog createMany
   */
  export type AccessLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccessLogs.
     */
    data: AccessLogCreateManyInput | AccessLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccessLog createManyAndReturn
   */
  export type AccessLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessLog
     */
    select?: AccessLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AccessLog
     */
    omit?: AccessLogOmit<ExtArgs> | null
    /**
     * The data used to create many AccessLogs.
     */
    data: AccessLogCreateManyInput | AccessLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AccessLog update
   */
  export type AccessLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessLog
     */
    select?: AccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessLog
     */
    omit?: AccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AccessLog.
     */
    data: XOR<AccessLogUpdateInput, AccessLogUncheckedUpdateInput>
    /**
     * Choose, which AccessLog to update.
     */
    where: AccessLogWhereUniqueInput
  }

  /**
   * AccessLog updateMany
   */
  export type AccessLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccessLogs.
     */
    data: XOR<AccessLogUpdateManyMutationInput, AccessLogUncheckedUpdateManyInput>
    /**
     * Filter which AccessLogs to update
     */
    where?: AccessLogWhereInput
    /**
     * Limit how many AccessLogs to update.
     */
    limit?: number
  }

  /**
   * AccessLog updateManyAndReturn
   */
  export type AccessLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessLog
     */
    select?: AccessLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AccessLog
     */
    omit?: AccessLogOmit<ExtArgs> | null
    /**
     * The data used to update AccessLogs.
     */
    data: XOR<AccessLogUpdateManyMutationInput, AccessLogUncheckedUpdateManyInput>
    /**
     * Filter which AccessLogs to update
     */
    where?: AccessLogWhereInput
    /**
     * Limit how many AccessLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AccessLog upsert
   */
  export type AccessLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessLog
     */
    select?: AccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessLog
     */
    omit?: AccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AccessLog to update in case it exists.
     */
    where: AccessLogWhereUniqueInput
    /**
     * In case the AccessLog found by the `where` argument doesn't exist, create a new AccessLog with this data.
     */
    create: XOR<AccessLogCreateInput, AccessLogUncheckedCreateInput>
    /**
     * In case the AccessLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccessLogUpdateInput, AccessLogUncheckedUpdateInput>
  }

  /**
   * AccessLog delete
   */
  export type AccessLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessLog
     */
    select?: AccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessLog
     */
    omit?: AccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessLogInclude<ExtArgs> | null
    /**
     * Filter which AccessLog to delete.
     */
    where: AccessLogWhereUniqueInput
  }

  /**
   * AccessLog deleteMany
   */
  export type AccessLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccessLogs to delete
     */
    where?: AccessLogWhereInput
    /**
     * Limit how many AccessLogs to delete.
     */
    limit?: number
  }

  /**
   * AccessLog without action
   */
  export type AccessLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessLog
     */
    select?: AccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessLog
     */
    omit?: AccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessLogInclude<ExtArgs> | null
  }


  /**
   * Model BookingExtension
   */

  export type AggregateBookingExtension = {
    _count: BookingExtensionCountAggregateOutputType | null
    _avg: BookingExtensionAvgAggregateOutputType | null
    _sum: BookingExtensionSumAggregateOutputType | null
    _min: BookingExtensionMinAggregateOutputType | null
    _max: BookingExtensionMaxAggregateOutputType | null
  }

  export type BookingExtensionAvgAggregateOutputType = {
    id: number | null
    bookingId: number | null
    additionalCharge: Decimal | null
  }

  export type BookingExtensionSumAggregateOutputType = {
    id: number | null
    bookingId: number | null
    additionalCharge: Decimal | null
  }

  export type BookingExtensionMinAggregateOutputType = {
    id: number | null
    bookingId: number | null
    originalEndTime: Date | null
    newEndTime: Date | null
    additionalCharge: Decimal | null
    paymentStatus: string | null
    requestTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingExtensionMaxAggregateOutputType = {
    id: number | null
    bookingId: number | null
    originalEndTime: Date | null
    newEndTime: Date | null
    additionalCharge: Decimal | null
    paymentStatus: string | null
    requestTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingExtensionCountAggregateOutputType = {
    id: number
    bookingId: number
    originalEndTime: number
    newEndTime: number
    additionalCharge: number
    paymentStatus: number
    requestTime: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BookingExtensionAvgAggregateInputType = {
    id?: true
    bookingId?: true
    additionalCharge?: true
  }

  export type BookingExtensionSumAggregateInputType = {
    id?: true
    bookingId?: true
    additionalCharge?: true
  }

  export type BookingExtensionMinAggregateInputType = {
    id?: true
    bookingId?: true
    originalEndTime?: true
    newEndTime?: true
    additionalCharge?: true
    paymentStatus?: true
    requestTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingExtensionMaxAggregateInputType = {
    id?: true
    bookingId?: true
    originalEndTime?: true
    newEndTime?: true
    additionalCharge?: true
    paymentStatus?: true
    requestTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingExtensionCountAggregateInputType = {
    id?: true
    bookingId?: true
    originalEndTime?: true
    newEndTime?: true
    additionalCharge?: true
    paymentStatus?: true
    requestTime?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BookingExtensionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingExtension to aggregate.
     */
    where?: BookingExtensionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingExtensions to fetch.
     */
    orderBy?: BookingExtensionOrderByWithRelationInput | BookingExtensionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingExtensionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingExtensions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingExtensions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookingExtensions
    **/
    _count?: true | BookingExtensionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingExtensionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingExtensionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingExtensionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingExtensionMaxAggregateInputType
  }

  export type GetBookingExtensionAggregateType<T extends BookingExtensionAggregateArgs> = {
        [P in keyof T & keyof AggregateBookingExtension]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookingExtension[P]>
      : GetScalarType<T[P], AggregateBookingExtension[P]>
  }




  export type BookingExtensionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingExtensionWhereInput
    orderBy?: BookingExtensionOrderByWithAggregationInput | BookingExtensionOrderByWithAggregationInput[]
    by: BookingExtensionScalarFieldEnum[] | BookingExtensionScalarFieldEnum
    having?: BookingExtensionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingExtensionCountAggregateInputType | true
    _avg?: BookingExtensionAvgAggregateInputType
    _sum?: BookingExtensionSumAggregateInputType
    _min?: BookingExtensionMinAggregateInputType
    _max?: BookingExtensionMaxAggregateInputType
  }

  export type BookingExtensionGroupByOutputType = {
    id: number
    bookingId: number
    originalEndTime: Date
    newEndTime: Date
    additionalCharge: Decimal
    paymentStatus: string
    requestTime: Date
    createdAt: Date
    updatedAt: Date | null
    _count: BookingExtensionCountAggregateOutputType | null
    _avg: BookingExtensionAvgAggregateOutputType | null
    _sum: BookingExtensionSumAggregateOutputType | null
    _min: BookingExtensionMinAggregateOutputType | null
    _max: BookingExtensionMaxAggregateOutputType | null
  }

  type GetBookingExtensionGroupByPayload<T extends BookingExtensionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingExtensionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingExtensionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingExtensionGroupByOutputType[P]>
            : GetScalarType<T[P], BookingExtensionGroupByOutputType[P]>
        }
      >
    >


  export type BookingExtensionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    originalEndTime?: boolean
    newEndTime?: boolean
    additionalCharge?: boolean
    paymentStatus?: boolean
    requestTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingExtension"]>

  export type BookingExtensionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    originalEndTime?: boolean
    newEndTime?: boolean
    additionalCharge?: boolean
    paymentStatus?: boolean
    requestTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingExtension"]>

  export type BookingExtensionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    originalEndTime?: boolean
    newEndTime?: boolean
    additionalCharge?: boolean
    paymentStatus?: boolean
    requestTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingExtension"]>

  export type BookingExtensionSelectScalar = {
    id?: boolean
    bookingId?: boolean
    originalEndTime?: boolean
    newEndTime?: boolean
    additionalCharge?: boolean
    paymentStatus?: boolean
    requestTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BookingExtensionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "originalEndTime" | "newEndTime" | "additionalCharge" | "paymentStatus" | "requestTime" | "createdAt" | "updatedAt", ExtArgs["result"]["bookingExtension"]>
  export type BookingExtensionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }
  export type BookingExtensionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }
  export type BookingExtensionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }

  export type $BookingExtensionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookingExtension"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bookingId: number
      originalEndTime: Date
      newEndTime: Date
      additionalCharge: Prisma.Decimal
      paymentStatus: string
      requestTime: Date
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["bookingExtension"]>
    composites: {}
  }

  type BookingExtensionGetPayload<S extends boolean | null | undefined | BookingExtensionDefaultArgs> = $Result.GetResult<Prisma.$BookingExtensionPayload, S>

  type BookingExtensionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingExtensionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingExtensionCountAggregateInputType | true
    }

  export interface BookingExtensionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookingExtension'], meta: { name: 'BookingExtension' } }
    /**
     * Find zero or one BookingExtension that matches the filter.
     * @param {BookingExtensionFindUniqueArgs} args - Arguments to find a BookingExtension
     * @example
     * // Get one BookingExtension
     * const bookingExtension = await prisma.bookingExtension.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingExtensionFindUniqueArgs>(args: SelectSubset<T, BookingExtensionFindUniqueArgs<ExtArgs>>): Prisma__BookingExtensionClient<$Result.GetResult<Prisma.$BookingExtensionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BookingExtension that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingExtensionFindUniqueOrThrowArgs} args - Arguments to find a BookingExtension
     * @example
     * // Get one BookingExtension
     * const bookingExtension = await prisma.bookingExtension.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingExtensionFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingExtensionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingExtensionClient<$Result.GetResult<Prisma.$BookingExtensionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingExtension that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingExtensionFindFirstArgs} args - Arguments to find a BookingExtension
     * @example
     * // Get one BookingExtension
     * const bookingExtension = await prisma.bookingExtension.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingExtensionFindFirstArgs>(args?: SelectSubset<T, BookingExtensionFindFirstArgs<ExtArgs>>): Prisma__BookingExtensionClient<$Result.GetResult<Prisma.$BookingExtensionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingExtension that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingExtensionFindFirstOrThrowArgs} args - Arguments to find a BookingExtension
     * @example
     * // Get one BookingExtension
     * const bookingExtension = await prisma.bookingExtension.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingExtensionFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingExtensionFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingExtensionClient<$Result.GetResult<Prisma.$BookingExtensionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BookingExtensions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingExtensionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookingExtensions
     * const bookingExtensions = await prisma.bookingExtension.findMany()
     * 
     * // Get first 10 BookingExtensions
     * const bookingExtensions = await prisma.bookingExtension.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingExtensionWithIdOnly = await prisma.bookingExtension.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingExtensionFindManyArgs>(args?: SelectSubset<T, BookingExtensionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingExtensionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BookingExtension.
     * @param {BookingExtensionCreateArgs} args - Arguments to create a BookingExtension.
     * @example
     * // Create one BookingExtension
     * const BookingExtension = await prisma.bookingExtension.create({
     *   data: {
     *     // ... data to create a BookingExtension
     *   }
     * })
     * 
     */
    create<T extends BookingExtensionCreateArgs>(args: SelectSubset<T, BookingExtensionCreateArgs<ExtArgs>>): Prisma__BookingExtensionClient<$Result.GetResult<Prisma.$BookingExtensionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BookingExtensions.
     * @param {BookingExtensionCreateManyArgs} args - Arguments to create many BookingExtensions.
     * @example
     * // Create many BookingExtensions
     * const bookingExtension = await prisma.bookingExtension.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingExtensionCreateManyArgs>(args?: SelectSubset<T, BookingExtensionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BookingExtensions and returns the data saved in the database.
     * @param {BookingExtensionCreateManyAndReturnArgs} args - Arguments to create many BookingExtensions.
     * @example
     * // Create many BookingExtensions
     * const bookingExtension = await prisma.bookingExtension.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BookingExtensions and only return the `id`
     * const bookingExtensionWithIdOnly = await prisma.bookingExtension.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingExtensionCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingExtensionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingExtensionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BookingExtension.
     * @param {BookingExtensionDeleteArgs} args - Arguments to delete one BookingExtension.
     * @example
     * // Delete one BookingExtension
     * const BookingExtension = await prisma.bookingExtension.delete({
     *   where: {
     *     // ... filter to delete one BookingExtension
     *   }
     * })
     * 
     */
    delete<T extends BookingExtensionDeleteArgs>(args: SelectSubset<T, BookingExtensionDeleteArgs<ExtArgs>>): Prisma__BookingExtensionClient<$Result.GetResult<Prisma.$BookingExtensionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BookingExtension.
     * @param {BookingExtensionUpdateArgs} args - Arguments to update one BookingExtension.
     * @example
     * // Update one BookingExtension
     * const bookingExtension = await prisma.bookingExtension.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingExtensionUpdateArgs>(args: SelectSubset<T, BookingExtensionUpdateArgs<ExtArgs>>): Prisma__BookingExtensionClient<$Result.GetResult<Prisma.$BookingExtensionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BookingExtensions.
     * @param {BookingExtensionDeleteManyArgs} args - Arguments to filter BookingExtensions to delete.
     * @example
     * // Delete a few BookingExtensions
     * const { count } = await prisma.bookingExtension.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingExtensionDeleteManyArgs>(args?: SelectSubset<T, BookingExtensionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingExtensions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingExtensionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookingExtensions
     * const bookingExtension = await prisma.bookingExtension.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingExtensionUpdateManyArgs>(args: SelectSubset<T, BookingExtensionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingExtensions and returns the data updated in the database.
     * @param {BookingExtensionUpdateManyAndReturnArgs} args - Arguments to update many BookingExtensions.
     * @example
     * // Update many BookingExtensions
     * const bookingExtension = await prisma.bookingExtension.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BookingExtensions and only return the `id`
     * const bookingExtensionWithIdOnly = await prisma.bookingExtension.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingExtensionUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingExtensionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingExtensionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BookingExtension.
     * @param {BookingExtensionUpsertArgs} args - Arguments to update or create a BookingExtension.
     * @example
     * // Update or create a BookingExtension
     * const bookingExtension = await prisma.bookingExtension.upsert({
     *   create: {
     *     // ... data to create a BookingExtension
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookingExtension we want to update
     *   }
     * })
     */
    upsert<T extends BookingExtensionUpsertArgs>(args: SelectSubset<T, BookingExtensionUpsertArgs<ExtArgs>>): Prisma__BookingExtensionClient<$Result.GetResult<Prisma.$BookingExtensionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BookingExtensions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingExtensionCountArgs} args - Arguments to filter BookingExtensions to count.
     * @example
     * // Count the number of BookingExtensions
     * const count = await prisma.bookingExtension.count({
     *   where: {
     *     // ... the filter for the BookingExtensions we want to count
     *   }
     * })
    **/
    count<T extends BookingExtensionCountArgs>(
      args?: Subset<T, BookingExtensionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingExtensionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookingExtension.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingExtensionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingExtensionAggregateArgs>(args: Subset<T, BookingExtensionAggregateArgs>): Prisma.PrismaPromise<GetBookingExtensionAggregateType<T>>

    /**
     * Group by BookingExtension.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingExtensionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingExtensionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingExtensionGroupByArgs['orderBy'] }
        : { orderBy?: BookingExtensionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingExtensionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingExtensionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookingExtension model
   */
  readonly fields: BookingExtensionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookingExtension.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingExtensionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookingExtension model
   */
  interface BookingExtensionFieldRefs {
    readonly id: FieldRef<"BookingExtension", 'Int'>
    readonly bookingId: FieldRef<"BookingExtension", 'Int'>
    readonly originalEndTime: FieldRef<"BookingExtension", 'DateTime'>
    readonly newEndTime: FieldRef<"BookingExtension", 'DateTime'>
    readonly additionalCharge: FieldRef<"BookingExtension", 'Decimal'>
    readonly paymentStatus: FieldRef<"BookingExtension", 'String'>
    readonly requestTime: FieldRef<"BookingExtension", 'DateTime'>
    readonly createdAt: FieldRef<"BookingExtension", 'DateTime'>
    readonly updatedAt: FieldRef<"BookingExtension", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BookingExtension findUnique
   */
  export type BookingExtensionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingExtension
     */
    select?: BookingExtensionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingExtension
     */
    omit?: BookingExtensionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingExtensionInclude<ExtArgs> | null
    /**
     * Filter, which BookingExtension to fetch.
     */
    where: BookingExtensionWhereUniqueInput
  }

  /**
   * BookingExtension findUniqueOrThrow
   */
  export type BookingExtensionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingExtension
     */
    select?: BookingExtensionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingExtension
     */
    omit?: BookingExtensionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingExtensionInclude<ExtArgs> | null
    /**
     * Filter, which BookingExtension to fetch.
     */
    where: BookingExtensionWhereUniqueInput
  }

  /**
   * BookingExtension findFirst
   */
  export type BookingExtensionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingExtension
     */
    select?: BookingExtensionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingExtension
     */
    omit?: BookingExtensionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingExtensionInclude<ExtArgs> | null
    /**
     * Filter, which BookingExtension to fetch.
     */
    where?: BookingExtensionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingExtensions to fetch.
     */
    orderBy?: BookingExtensionOrderByWithRelationInput | BookingExtensionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingExtensions.
     */
    cursor?: BookingExtensionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingExtensions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingExtensions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingExtensions.
     */
    distinct?: BookingExtensionScalarFieldEnum | BookingExtensionScalarFieldEnum[]
  }

  /**
   * BookingExtension findFirstOrThrow
   */
  export type BookingExtensionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingExtension
     */
    select?: BookingExtensionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingExtension
     */
    omit?: BookingExtensionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingExtensionInclude<ExtArgs> | null
    /**
     * Filter, which BookingExtension to fetch.
     */
    where?: BookingExtensionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingExtensions to fetch.
     */
    orderBy?: BookingExtensionOrderByWithRelationInput | BookingExtensionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingExtensions.
     */
    cursor?: BookingExtensionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingExtensions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingExtensions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingExtensions.
     */
    distinct?: BookingExtensionScalarFieldEnum | BookingExtensionScalarFieldEnum[]
  }

  /**
   * BookingExtension findMany
   */
  export type BookingExtensionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingExtension
     */
    select?: BookingExtensionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingExtension
     */
    omit?: BookingExtensionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingExtensionInclude<ExtArgs> | null
    /**
     * Filter, which BookingExtensions to fetch.
     */
    where?: BookingExtensionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingExtensions to fetch.
     */
    orderBy?: BookingExtensionOrderByWithRelationInput | BookingExtensionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookingExtensions.
     */
    cursor?: BookingExtensionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingExtensions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingExtensions.
     */
    skip?: number
    distinct?: BookingExtensionScalarFieldEnum | BookingExtensionScalarFieldEnum[]
  }

  /**
   * BookingExtension create
   */
  export type BookingExtensionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingExtension
     */
    select?: BookingExtensionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingExtension
     */
    omit?: BookingExtensionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingExtensionInclude<ExtArgs> | null
    /**
     * The data needed to create a BookingExtension.
     */
    data: XOR<BookingExtensionCreateInput, BookingExtensionUncheckedCreateInput>
  }

  /**
   * BookingExtension createMany
   */
  export type BookingExtensionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookingExtensions.
     */
    data: BookingExtensionCreateManyInput | BookingExtensionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookingExtension createManyAndReturn
   */
  export type BookingExtensionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingExtension
     */
    select?: BookingExtensionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingExtension
     */
    omit?: BookingExtensionOmit<ExtArgs> | null
    /**
     * The data used to create many BookingExtensions.
     */
    data: BookingExtensionCreateManyInput | BookingExtensionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingExtensionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingExtension update
   */
  export type BookingExtensionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingExtension
     */
    select?: BookingExtensionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingExtension
     */
    omit?: BookingExtensionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingExtensionInclude<ExtArgs> | null
    /**
     * The data needed to update a BookingExtension.
     */
    data: XOR<BookingExtensionUpdateInput, BookingExtensionUncheckedUpdateInput>
    /**
     * Choose, which BookingExtension to update.
     */
    where: BookingExtensionWhereUniqueInput
  }

  /**
   * BookingExtension updateMany
   */
  export type BookingExtensionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookingExtensions.
     */
    data: XOR<BookingExtensionUpdateManyMutationInput, BookingExtensionUncheckedUpdateManyInput>
    /**
     * Filter which BookingExtensions to update
     */
    where?: BookingExtensionWhereInput
    /**
     * Limit how many BookingExtensions to update.
     */
    limit?: number
  }

  /**
   * BookingExtension updateManyAndReturn
   */
  export type BookingExtensionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingExtension
     */
    select?: BookingExtensionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingExtension
     */
    omit?: BookingExtensionOmit<ExtArgs> | null
    /**
     * The data used to update BookingExtensions.
     */
    data: XOR<BookingExtensionUpdateManyMutationInput, BookingExtensionUncheckedUpdateManyInput>
    /**
     * Filter which BookingExtensions to update
     */
    where?: BookingExtensionWhereInput
    /**
     * Limit how many BookingExtensions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingExtensionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingExtension upsert
   */
  export type BookingExtensionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingExtension
     */
    select?: BookingExtensionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingExtension
     */
    omit?: BookingExtensionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingExtensionInclude<ExtArgs> | null
    /**
     * The filter to search for the BookingExtension to update in case it exists.
     */
    where: BookingExtensionWhereUniqueInput
    /**
     * In case the BookingExtension found by the `where` argument doesn't exist, create a new BookingExtension with this data.
     */
    create: XOR<BookingExtensionCreateInput, BookingExtensionUncheckedCreateInput>
    /**
     * In case the BookingExtension was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingExtensionUpdateInput, BookingExtensionUncheckedUpdateInput>
  }

  /**
   * BookingExtension delete
   */
  export type BookingExtensionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingExtension
     */
    select?: BookingExtensionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingExtension
     */
    omit?: BookingExtensionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingExtensionInclude<ExtArgs> | null
    /**
     * Filter which BookingExtension to delete.
     */
    where: BookingExtensionWhereUniqueInput
  }

  /**
   * BookingExtension deleteMany
   */
  export type BookingExtensionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingExtensions to delete
     */
    where?: BookingExtensionWhereInput
    /**
     * Limit how many BookingExtensions to delete.
     */
    limit?: number
  }

  /**
   * BookingExtension without action
   */
  export type BookingExtensionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingExtension
     */
    select?: BookingExtensionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingExtension
     */
    omit?: BookingExtensionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingExtensionInclude<ExtArgs> | null
  }


  /**
   * Model NotificationSetting
   */

  export type AggregateNotificationSetting = {
    _count: NotificationSettingCountAggregateOutputType | null
    _avg: NotificationSettingAvgAggregateOutputType | null
    _sum: NotificationSettingSumAggregateOutputType | null
    _min: NotificationSettingMinAggregateOutputType | null
    _max: NotificationSettingMaxAggregateOutputType | null
  }

  export type NotificationSettingAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NotificationSettingSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NotificationSettingMinAggregateOutputType = {
    id: number | null
    userId: number | null
    emailEnabled: boolean | null
    smsEnabled: boolean | null
    pushEnabled: boolean | null
    bookingConfirmation: boolean | null
    paymentNotifications: boolean | null
    reminderNotifications: boolean | null
    marketingNotifications: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationSettingMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    emailEnabled: boolean | null
    smsEnabled: boolean | null
    pushEnabled: boolean | null
    bookingConfirmation: boolean | null
    paymentNotifications: boolean | null
    reminderNotifications: boolean | null
    marketingNotifications: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationSettingCountAggregateOutputType = {
    id: number
    userId: number
    emailEnabled: number
    smsEnabled: number
    pushEnabled: number
    bookingConfirmation: number
    paymentNotifications: number
    reminderNotifications: number
    marketingNotifications: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationSettingAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationSettingSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationSettingMinAggregateInputType = {
    id?: true
    userId?: true
    emailEnabled?: true
    smsEnabled?: true
    pushEnabled?: true
    bookingConfirmation?: true
    paymentNotifications?: true
    reminderNotifications?: true
    marketingNotifications?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationSettingMaxAggregateInputType = {
    id?: true
    userId?: true
    emailEnabled?: true
    smsEnabled?: true
    pushEnabled?: true
    bookingConfirmation?: true
    paymentNotifications?: true
    reminderNotifications?: true
    marketingNotifications?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationSettingCountAggregateInputType = {
    id?: true
    userId?: true
    emailEnabled?: true
    smsEnabled?: true
    pushEnabled?: true
    bookingConfirmation?: true
    paymentNotifications?: true
    reminderNotifications?: true
    marketingNotifications?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationSetting to aggregate.
     */
    where?: NotificationSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingOrderByWithRelationInput | NotificationSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationSettings
    **/
    _count?: true | NotificationSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationSettingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSettingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationSettingMaxAggregateInputType
  }

  export type GetNotificationSettingAggregateType<T extends NotificationSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationSetting[P]>
      : GetScalarType<T[P], AggregateNotificationSetting[P]>
  }




  export type NotificationSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationSettingWhereInput
    orderBy?: NotificationSettingOrderByWithAggregationInput | NotificationSettingOrderByWithAggregationInput[]
    by: NotificationSettingScalarFieldEnum[] | NotificationSettingScalarFieldEnum
    having?: NotificationSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationSettingCountAggregateInputType | true
    _avg?: NotificationSettingAvgAggregateInputType
    _sum?: NotificationSettingSumAggregateInputType
    _min?: NotificationSettingMinAggregateInputType
    _max?: NotificationSettingMaxAggregateInputType
  }

  export type NotificationSettingGroupByOutputType = {
    id: number
    userId: number
    emailEnabled: boolean
    smsEnabled: boolean
    pushEnabled: boolean
    bookingConfirmation: boolean
    paymentNotifications: boolean
    reminderNotifications: boolean
    marketingNotifications: boolean
    createdAt: Date
    updatedAt: Date | null
    _count: NotificationSettingCountAggregateOutputType | null
    _avg: NotificationSettingAvgAggregateOutputType | null
    _sum: NotificationSettingSumAggregateOutputType | null
    _min: NotificationSettingMinAggregateOutputType | null
    _max: NotificationSettingMaxAggregateOutputType | null
  }

  type GetNotificationSettingGroupByPayload<T extends NotificationSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationSettingGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationSettingGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    emailEnabled?: boolean
    smsEnabled?: boolean
    pushEnabled?: boolean
    bookingConfirmation?: boolean
    paymentNotifications?: boolean
    reminderNotifications?: boolean
    marketingNotifications?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationSetting"]>

  export type NotificationSettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    emailEnabled?: boolean
    smsEnabled?: boolean
    pushEnabled?: boolean
    bookingConfirmation?: boolean
    paymentNotifications?: boolean
    reminderNotifications?: boolean
    marketingNotifications?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationSetting"]>

  export type NotificationSettingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    emailEnabled?: boolean
    smsEnabled?: boolean
    pushEnabled?: boolean
    bookingConfirmation?: boolean
    paymentNotifications?: boolean
    reminderNotifications?: boolean
    marketingNotifications?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationSetting"]>

  export type NotificationSettingSelectScalar = {
    id?: boolean
    userId?: boolean
    emailEnabled?: boolean
    smsEnabled?: boolean
    pushEnabled?: boolean
    bookingConfirmation?: boolean
    paymentNotifications?: boolean
    reminderNotifications?: boolean
    marketingNotifications?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationSettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "emailEnabled" | "smsEnabled" | "pushEnabled" | "bookingConfirmation" | "paymentNotifications" | "reminderNotifications" | "marketingNotifications" | "createdAt" | "updatedAt", ExtArgs["result"]["notificationSetting"]>
  export type NotificationSettingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationSettingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationSettingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationSetting"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      emailEnabled: boolean
      smsEnabled: boolean
      pushEnabled: boolean
      bookingConfirmation: boolean
      paymentNotifications: boolean
      reminderNotifications: boolean
      marketingNotifications: boolean
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["notificationSetting"]>
    composites: {}
  }

  type NotificationSettingGetPayload<S extends boolean | null | undefined | NotificationSettingDefaultArgs> = $Result.GetResult<Prisma.$NotificationSettingPayload, S>

  type NotificationSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationSettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationSettingCountAggregateInputType | true
    }

  export interface NotificationSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationSetting'], meta: { name: 'NotificationSetting' } }
    /**
     * Find zero or one NotificationSetting that matches the filter.
     * @param {NotificationSettingFindUniqueArgs} args - Arguments to find a NotificationSetting
     * @example
     * // Get one NotificationSetting
     * const notificationSetting = await prisma.notificationSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationSettingFindUniqueArgs>(args: SelectSubset<T, NotificationSettingFindUniqueArgs<ExtArgs>>): Prisma__NotificationSettingClient<$Result.GetResult<Prisma.$NotificationSettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationSetting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationSettingFindUniqueOrThrowArgs} args - Arguments to find a NotificationSetting
     * @example
     * // Get one NotificationSetting
     * const notificationSetting = await prisma.notificationSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationSettingClient<$Result.GetResult<Prisma.$NotificationSettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingFindFirstArgs} args - Arguments to find a NotificationSetting
     * @example
     * // Get one NotificationSetting
     * const notificationSetting = await prisma.notificationSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationSettingFindFirstArgs>(args?: SelectSubset<T, NotificationSettingFindFirstArgs<ExtArgs>>): Prisma__NotificationSettingClient<$Result.GetResult<Prisma.$NotificationSettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingFindFirstOrThrowArgs} args - Arguments to find a NotificationSetting
     * @example
     * // Get one NotificationSetting
     * const notificationSetting = await prisma.notificationSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationSettingClient<$Result.GetResult<Prisma.$NotificationSettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationSettings
     * const notificationSettings = await prisma.notificationSetting.findMany()
     * 
     * // Get first 10 NotificationSettings
     * const notificationSettings = await prisma.notificationSetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationSettingWithIdOnly = await prisma.notificationSetting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationSettingFindManyArgs>(args?: SelectSubset<T, NotificationSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationSettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationSetting.
     * @param {NotificationSettingCreateArgs} args - Arguments to create a NotificationSetting.
     * @example
     * // Create one NotificationSetting
     * const NotificationSetting = await prisma.notificationSetting.create({
     *   data: {
     *     // ... data to create a NotificationSetting
     *   }
     * })
     * 
     */
    create<T extends NotificationSettingCreateArgs>(args: SelectSubset<T, NotificationSettingCreateArgs<ExtArgs>>): Prisma__NotificationSettingClient<$Result.GetResult<Prisma.$NotificationSettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationSettings.
     * @param {NotificationSettingCreateManyArgs} args - Arguments to create many NotificationSettings.
     * @example
     * // Create many NotificationSettings
     * const notificationSetting = await prisma.notificationSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationSettingCreateManyArgs>(args?: SelectSubset<T, NotificationSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationSettings and returns the data saved in the database.
     * @param {NotificationSettingCreateManyAndReturnArgs} args - Arguments to create many NotificationSettings.
     * @example
     * // Create many NotificationSettings
     * const notificationSetting = await prisma.notificationSetting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationSettings and only return the `id`
     * const notificationSettingWithIdOnly = await prisma.notificationSetting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationSettingCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationSettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationSettingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationSetting.
     * @param {NotificationSettingDeleteArgs} args - Arguments to delete one NotificationSetting.
     * @example
     * // Delete one NotificationSetting
     * const NotificationSetting = await prisma.notificationSetting.delete({
     *   where: {
     *     // ... filter to delete one NotificationSetting
     *   }
     * })
     * 
     */
    delete<T extends NotificationSettingDeleteArgs>(args: SelectSubset<T, NotificationSettingDeleteArgs<ExtArgs>>): Prisma__NotificationSettingClient<$Result.GetResult<Prisma.$NotificationSettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationSetting.
     * @param {NotificationSettingUpdateArgs} args - Arguments to update one NotificationSetting.
     * @example
     * // Update one NotificationSetting
     * const notificationSetting = await prisma.notificationSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationSettingUpdateArgs>(args: SelectSubset<T, NotificationSettingUpdateArgs<ExtArgs>>): Prisma__NotificationSettingClient<$Result.GetResult<Prisma.$NotificationSettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationSettings.
     * @param {NotificationSettingDeleteManyArgs} args - Arguments to filter NotificationSettings to delete.
     * @example
     * // Delete a few NotificationSettings
     * const { count } = await prisma.notificationSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationSettingDeleteManyArgs>(args?: SelectSubset<T, NotificationSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationSettings
     * const notificationSetting = await prisma.notificationSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationSettingUpdateManyArgs>(args: SelectSubset<T, NotificationSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationSettings and returns the data updated in the database.
     * @param {NotificationSettingUpdateManyAndReturnArgs} args - Arguments to update many NotificationSettings.
     * @example
     * // Update many NotificationSettings
     * const notificationSetting = await prisma.notificationSetting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationSettings and only return the `id`
     * const notificationSettingWithIdOnly = await prisma.notificationSetting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationSettingUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationSettingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationSettingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationSetting.
     * @param {NotificationSettingUpsertArgs} args - Arguments to update or create a NotificationSetting.
     * @example
     * // Update or create a NotificationSetting
     * const notificationSetting = await prisma.notificationSetting.upsert({
     *   create: {
     *     // ... data to create a NotificationSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationSetting we want to update
     *   }
     * })
     */
    upsert<T extends NotificationSettingUpsertArgs>(args: SelectSubset<T, NotificationSettingUpsertArgs<ExtArgs>>): Prisma__NotificationSettingClient<$Result.GetResult<Prisma.$NotificationSettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingCountArgs} args - Arguments to filter NotificationSettings to count.
     * @example
     * // Count the number of NotificationSettings
     * const count = await prisma.notificationSetting.count({
     *   where: {
     *     // ... the filter for the NotificationSettings we want to count
     *   }
     * })
    **/
    count<T extends NotificationSettingCountArgs>(
      args?: Subset<T, NotificationSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationSettingAggregateArgs>(args: Subset<T, NotificationSettingAggregateArgs>): Prisma.PrismaPromise<GetNotificationSettingAggregateType<T>>

    /**
     * Group by NotificationSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationSettingGroupByArgs['orderBy'] }
        : { orderBy?: NotificationSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationSetting model
   */
  readonly fields: NotificationSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationSetting model
   */
  interface NotificationSettingFieldRefs {
    readonly id: FieldRef<"NotificationSetting", 'Int'>
    readonly userId: FieldRef<"NotificationSetting", 'Int'>
    readonly emailEnabled: FieldRef<"NotificationSetting", 'Boolean'>
    readonly smsEnabled: FieldRef<"NotificationSetting", 'Boolean'>
    readonly pushEnabled: FieldRef<"NotificationSetting", 'Boolean'>
    readonly bookingConfirmation: FieldRef<"NotificationSetting", 'Boolean'>
    readonly paymentNotifications: FieldRef<"NotificationSetting", 'Boolean'>
    readonly reminderNotifications: FieldRef<"NotificationSetting", 'Boolean'>
    readonly marketingNotifications: FieldRef<"NotificationSetting", 'Boolean'>
    readonly createdAt: FieldRef<"NotificationSetting", 'DateTime'>
    readonly updatedAt: FieldRef<"NotificationSetting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationSetting findUnique
   */
  export type NotificationSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSetting
     */
    select?: NotificationSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSetting
     */
    omit?: NotificationSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSetting to fetch.
     */
    where: NotificationSettingWhereUniqueInput
  }

  /**
   * NotificationSetting findUniqueOrThrow
   */
  export type NotificationSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSetting
     */
    select?: NotificationSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSetting
     */
    omit?: NotificationSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSetting to fetch.
     */
    where: NotificationSettingWhereUniqueInput
  }

  /**
   * NotificationSetting findFirst
   */
  export type NotificationSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSetting
     */
    select?: NotificationSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSetting
     */
    omit?: NotificationSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSetting to fetch.
     */
    where?: NotificationSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingOrderByWithRelationInput | NotificationSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationSettings.
     */
    cursor?: NotificationSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationSettings.
     */
    distinct?: NotificationSettingScalarFieldEnum | NotificationSettingScalarFieldEnum[]
  }

  /**
   * NotificationSetting findFirstOrThrow
   */
  export type NotificationSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSetting
     */
    select?: NotificationSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSetting
     */
    omit?: NotificationSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSetting to fetch.
     */
    where?: NotificationSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingOrderByWithRelationInput | NotificationSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationSettings.
     */
    cursor?: NotificationSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationSettings.
     */
    distinct?: NotificationSettingScalarFieldEnum | NotificationSettingScalarFieldEnum[]
  }

  /**
   * NotificationSetting findMany
   */
  export type NotificationSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSetting
     */
    select?: NotificationSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSetting
     */
    omit?: NotificationSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where?: NotificationSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingOrderByWithRelationInput | NotificationSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationSettings.
     */
    cursor?: NotificationSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    distinct?: NotificationSettingScalarFieldEnum | NotificationSettingScalarFieldEnum[]
  }

  /**
   * NotificationSetting create
   */
  export type NotificationSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSetting
     */
    select?: NotificationSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSetting
     */
    omit?: NotificationSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationSetting.
     */
    data: XOR<NotificationSettingCreateInput, NotificationSettingUncheckedCreateInput>
  }

  /**
   * NotificationSetting createMany
   */
  export type NotificationSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationSettings.
     */
    data: NotificationSettingCreateManyInput | NotificationSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationSetting createManyAndReturn
   */
  export type NotificationSettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSetting
     */
    select?: NotificationSettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSetting
     */
    omit?: NotificationSettingOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationSettings.
     */
    data: NotificationSettingCreateManyInput | NotificationSettingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationSetting update
   */
  export type NotificationSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSetting
     */
    select?: NotificationSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSetting
     */
    omit?: NotificationSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationSetting.
     */
    data: XOR<NotificationSettingUpdateInput, NotificationSettingUncheckedUpdateInput>
    /**
     * Choose, which NotificationSetting to update.
     */
    where: NotificationSettingWhereUniqueInput
  }

  /**
   * NotificationSetting updateMany
   */
  export type NotificationSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationSettings.
     */
    data: XOR<NotificationSettingUpdateManyMutationInput, NotificationSettingUncheckedUpdateManyInput>
    /**
     * Filter which NotificationSettings to update
     */
    where?: NotificationSettingWhereInput
    /**
     * Limit how many NotificationSettings to update.
     */
    limit?: number
  }

  /**
   * NotificationSetting updateManyAndReturn
   */
  export type NotificationSettingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSetting
     */
    select?: NotificationSettingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSetting
     */
    omit?: NotificationSettingOmit<ExtArgs> | null
    /**
     * The data used to update NotificationSettings.
     */
    data: XOR<NotificationSettingUpdateManyMutationInput, NotificationSettingUncheckedUpdateManyInput>
    /**
     * Filter which NotificationSettings to update
     */
    where?: NotificationSettingWhereInput
    /**
     * Limit how many NotificationSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationSetting upsert
   */
  export type NotificationSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSetting
     */
    select?: NotificationSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSetting
     */
    omit?: NotificationSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationSetting to update in case it exists.
     */
    where: NotificationSettingWhereUniqueInput
    /**
     * In case the NotificationSetting found by the `where` argument doesn't exist, create a new NotificationSetting with this data.
     */
    create: XOR<NotificationSettingCreateInput, NotificationSettingUncheckedCreateInput>
    /**
     * In case the NotificationSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationSettingUpdateInput, NotificationSettingUncheckedUpdateInput>
  }

  /**
   * NotificationSetting delete
   */
  export type NotificationSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSetting
     */
    select?: NotificationSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSetting
     */
    omit?: NotificationSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingInclude<ExtArgs> | null
    /**
     * Filter which NotificationSetting to delete.
     */
    where: NotificationSettingWhereUniqueInput
  }

  /**
   * NotificationSetting deleteMany
   */
  export type NotificationSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationSettings to delete
     */
    where?: NotificationSettingWhereInput
    /**
     * Limit how many NotificationSettings to delete.
     */
    limit?: number
  }

  /**
   * NotificationSetting without action
   */
  export type NotificationSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSetting
     */
    select?: NotificationSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSetting
     */
    omit?: NotificationSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    bookingId: number | null
  }

  export type NotificationSumAggregateOutputType = {
    id: number | null
    userId: number | null
    bookingId: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: number | null
    userId: number | null
    bookingId: number | null
    notificationType: string | null
    channel: string | null
    content: string | null
    isRead: boolean | null
    sentTime: Date | null
    readTime: Date | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    bookingId: number | null
    notificationType: string | null
    channel: string | null
    content: string | null
    isRead: boolean | null
    sentTime: Date | null
    readTime: Date | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    bookingId: number
    notificationType: number
    channel: number
    content: number
    isRead: number
    sentTime: number
    readTime: number
    createdAt: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
    userId?: true
    bookingId?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
    userId?: true
    bookingId?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    bookingId?: true
    notificationType?: true
    channel?: true
    content?: true
    isRead?: true
    sentTime?: true
    readTime?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    bookingId?: true
    notificationType?: true
    channel?: true
    content?: true
    isRead?: true
    sentTime?: true
    readTime?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    bookingId?: true
    notificationType?: true
    channel?: true
    content?: true
    isRead?: true
    sentTime?: true
    readTime?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: number
    userId: number
    bookingId: number | null
    notificationType: string
    channel: string
    content: string
    isRead: boolean
    sentTime: Date
    readTime: Date | null
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bookingId?: boolean
    notificationType?: boolean
    channel?: boolean
    content?: boolean
    isRead?: boolean
    sentTime?: boolean
    readTime?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    booking?: boolean | Notification$bookingArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bookingId?: boolean
    notificationType?: boolean
    channel?: boolean
    content?: boolean
    isRead?: boolean
    sentTime?: boolean
    readTime?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    booking?: boolean | Notification$bookingArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bookingId?: boolean
    notificationType?: boolean
    channel?: boolean
    content?: boolean
    isRead?: boolean
    sentTime?: boolean
    readTime?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    booking?: boolean | Notification$bookingArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    bookingId?: boolean
    notificationType?: boolean
    channel?: boolean
    content?: boolean
    isRead?: boolean
    sentTime?: boolean
    readTime?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "bookingId" | "notificationType" | "channel" | "content" | "isRead" | "sentTime" | "readTime" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    booking?: boolean | Notification$bookingArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    booking?: boolean | Notification$bookingArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    booking?: boolean | Notification$bookingArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      booking: Prisma.$BookingPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      bookingId: number | null
      notificationType: string
      channel: string
      content: string
      isRead: boolean
      sentTime: Date
      readTime: Date | null
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    booking<T extends Notification$bookingArgs<ExtArgs> = {}>(args?: Subset<T, Notification$bookingArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'Int'>
    readonly userId: FieldRef<"Notification", 'Int'>
    readonly bookingId: FieldRef<"Notification", 'Int'>
    readonly notificationType: FieldRef<"Notification", 'String'>
    readonly channel: FieldRef<"Notification", 'String'>
    readonly content: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly sentTime: FieldRef<"Notification", 'DateTime'>
    readonly readTime: FieldRef<"Notification", 'DateTime'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification.booking
   */
  export type Notification$bookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model PlaceRating
   */

  export type AggregatePlaceRating = {
    _count: PlaceRatingCountAggregateOutputType | null
    _avg: PlaceRatingAvgAggregateOutputType | null
    _sum: PlaceRatingSumAggregateOutputType | null
    _min: PlaceRatingMinAggregateOutputType | null
    _max: PlaceRatingMaxAggregateOutputType | null
  }

  export type PlaceRatingAvgAggregateOutputType = {
    id: number | null
    placeId: number | null
    userId: number | null
    bookingId: number | null
    ratingScore: Decimal | null
  }

  export type PlaceRatingSumAggregateOutputType = {
    id: number | null
    placeId: number | null
    userId: number | null
    bookingId: number | null
    ratingScore: Decimal | null
  }

  export type PlaceRatingMinAggregateOutputType = {
    id: number | null
    placeId: number | null
    userId: number | null
    bookingId: number | null
    ratingScore: Decimal | null
    reviewComment: string | null
    ratingDate: Date | null
    isVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlaceRatingMaxAggregateOutputType = {
    id: number | null
    placeId: number | null
    userId: number | null
    bookingId: number | null
    ratingScore: Decimal | null
    reviewComment: string | null
    ratingDate: Date | null
    isVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlaceRatingCountAggregateOutputType = {
    id: number
    placeId: number
    userId: number
    bookingId: number
    ratingScore: number
    reviewComment: number
    ratingDate: number
    isVerified: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlaceRatingAvgAggregateInputType = {
    id?: true
    placeId?: true
    userId?: true
    bookingId?: true
    ratingScore?: true
  }

  export type PlaceRatingSumAggregateInputType = {
    id?: true
    placeId?: true
    userId?: true
    bookingId?: true
    ratingScore?: true
  }

  export type PlaceRatingMinAggregateInputType = {
    id?: true
    placeId?: true
    userId?: true
    bookingId?: true
    ratingScore?: true
    reviewComment?: true
    ratingDate?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlaceRatingMaxAggregateInputType = {
    id?: true
    placeId?: true
    userId?: true
    bookingId?: true
    ratingScore?: true
    reviewComment?: true
    ratingDate?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlaceRatingCountAggregateInputType = {
    id?: true
    placeId?: true
    userId?: true
    bookingId?: true
    ratingScore?: true
    reviewComment?: true
    ratingDate?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlaceRatingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlaceRating to aggregate.
     */
    where?: PlaceRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaceRatings to fetch.
     */
    orderBy?: PlaceRatingOrderByWithRelationInput | PlaceRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlaceRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaceRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaceRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlaceRatings
    **/
    _count?: true | PlaceRatingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlaceRatingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlaceRatingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlaceRatingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlaceRatingMaxAggregateInputType
  }

  export type GetPlaceRatingAggregateType<T extends PlaceRatingAggregateArgs> = {
        [P in keyof T & keyof AggregatePlaceRating]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlaceRating[P]>
      : GetScalarType<T[P], AggregatePlaceRating[P]>
  }




  export type PlaceRatingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaceRatingWhereInput
    orderBy?: PlaceRatingOrderByWithAggregationInput | PlaceRatingOrderByWithAggregationInput[]
    by: PlaceRatingScalarFieldEnum[] | PlaceRatingScalarFieldEnum
    having?: PlaceRatingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlaceRatingCountAggregateInputType | true
    _avg?: PlaceRatingAvgAggregateInputType
    _sum?: PlaceRatingSumAggregateInputType
    _min?: PlaceRatingMinAggregateInputType
    _max?: PlaceRatingMaxAggregateInputType
  }

  export type PlaceRatingGroupByOutputType = {
    id: number
    placeId: number
    userId: number
    bookingId: number
    ratingScore: Decimal
    reviewComment: string | null
    ratingDate: Date
    isVerified: boolean
    createdAt: Date
    updatedAt: Date | null
    _count: PlaceRatingCountAggregateOutputType | null
    _avg: PlaceRatingAvgAggregateOutputType | null
    _sum: PlaceRatingSumAggregateOutputType | null
    _min: PlaceRatingMinAggregateOutputType | null
    _max: PlaceRatingMaxAggregateOutputType | null
  }

  type GetPlaceRatingGroupByPayload<T extends PlaceRatingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlaceRatingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlaceRatingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlaceRatingGroupByOutputType[P]>
            : GetScalarType<T[P], PlaceRatingGroupByOutputType[P]>
        }
      >
    >


  export type PlaceRatingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    placeId?: boolean
    userId?: boolean
    bookingId?: boolean
    ratingScore?: boolean
    reviewComment?: boolean
    ratingDate?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    place?: boolean | PlaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["placeRating"]>

  export type PlaceRatingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    placeId?: boolean
    userId?: boolean
    bookingId?: boolean
    ratingScore?: boolean
    reviewComment?: boolean
    ratingDate?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    place?: boolean | PlaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["placeRating"]>

  export type PlaceRatingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    placeId?: boolean
    userId?: boolean
    bookingId?: boolean
    ratingScore?: boolean
    reviewComment?: boolean
    ratingDate?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    place?: boolean | PlaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["placeRating"]>

  export type PlaceRatingSelectScalar = {
    id?: boolean
    placeId?: boolean
    userId?: boolean
    bookingId?: boolean
    ratingScore?: boolean
    reviewComment?: boolean
    ratingDate?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlaceRatingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "placeId" | "userId" | "bookingId" | "ratingScore" | "reviewComment" | "ratingDate" | "isVerified" | "createdAt" | "updatedAt", ExtArgs["result"]["placeRating"]>
  export type PlaceRatingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    place?: boolean | PlaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }
  export type PlaceRatingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    place?: boolean | PlaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }
  export type PlaceRatingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    place?: boolean | PlaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }

  export type $PlaceRatingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlaceRating"
    objects: {
      place: Prisma.$PlacePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      booking: Prisma.$BookingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      placeId: number
      userId: number
      bookingId: number
      ratingScore: Prisma.Decimal
      reviewComment: string | null
      ratingDate: Date
      isVerified: boolean
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["placeRating"]>
    composites: {}
  }

  type PlaceRatingGetPayload<S extends boolean | null | undefined | PlaceRatingDefaultArgs> = $Result.GetResult<Prisma.$PlaceRatingPayload, S>

  type PlaceRatingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlaceRatingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlaceRatingCountAggregateInputType | true
    }

  export interface PlaceRatingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlaceRating'], meta: { name: 'PlaceRating' } }
    /**
     * Find zero or one PlaceRating that matches the filter.
     * @param {PlaceRatingFindUniqueArgs} args - Arguments to find a PlaceRating
     * @example
     * // Get one PlaceRating
     * const placeRating = await prisma.placeRating.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlaceRatingFindUniqueArgs>(args: SelectSubset<T, PlaceRatingFindUniqueArgs<ExtArgs>>): Prisma__PlaceRatingClient<$Result.GetResult<Prisma.$PlaceRatingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlaceRating that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlaceRatingFindUniqueOrThrowArgs} args - Arguments to find a PlaceRating
     * @example
     * // Get one PlaceRating
     * const placeRating = await prisma.placeRating.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlaceRatingFindUniqueOrThrowArgs>(args: SelectSubset<T, PlaceRatingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlaceRatingClient<$Result.GetResult<Prisma.$PlaceRatingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlaceRating that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceRatingFindFirstArgs} args - Arguments to find a PlaceRating
     * @example
     * // Get one PlaceRating
     * const placeRating = await prisma.placeRating.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlaceRatingFindFirstArgs>(args?: SelectSubset<T, PlaceRatingFindFirstArgs<ExtArgs>>): Prisma__PlaceRatingClient<$Result.GetResult<Prisma.$PlaceRatingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlaceRating that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceRatingFindFirstOrThrowArgs} args - Arguments to find a PlaceRating
     * @example
     * // Get one PlaceRating
     * const placeRating = await prisma.placeRating.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlaceRatingFindFirstOrThrowArgs>(args?: SelectSubset<T, PlaceRatingFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlaceRatingClient<$Result.GetResult<Prisma.$PlaceRatingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlaceRatings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceRatingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlaceRatings
     * const placeRatings = await prisma.placeRating.findMany()
     * 
     * // Get first 10 PlaceRatings
     * const placeRatings = await prisma.placeRating.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const placeRatingWithIdOnly = await prisma.placeRating.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlaceRatingFindManyArgs>(args?: SelectSubset<T, PlaceRatingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaceRatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlaceRating.
     * @param {PlaceRatingCreateArgs} args - Arguments to create a PlaceRating.
     * @example
     * // Create one PlaceRating
     * const PlaceRating = await prisma.placeRating.create({
     *   data: {
     *     // ... data to create a PlaceRating
     *   }
     * })
     * 
     */
    create<T extends PlaceRatingCreateArgs>(args: SelectSubset<T, PlaceRatingCreateArgs<ExtArgs>>): Prisma__PlaceRatingClient<$Result.GetResult<Prisma.$PlaceRatingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlaceRatings.
     * @param {PlaceRatingCreateManyArgs} args - Arguments to create many PlaceRatings.
     * @example
     * // Create many PlaceRatings
     * const placeRating = await prisma.placeRating.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlaceRatingCreateManyArgs>(args?: SelectSubset<T, PlaceRatingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlaceRatings and returns the data saved in the database.
     * @param {PlaceRatingCreateManyAndReturnArgs} args - Arguments to create many PlaceRatings.
     * @example
     * // Create many PlaceRatings
     * const placeRating = await prisma.placeRating.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlaceRatings and only return the `id`
     * const placeRatingWithIdOnly = await prisma.placeRating.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlaceRatingCreateManyAndReturnArgs>(args?: SelectSubset<T, PlaceRatingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaceRatingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlaceRating.
     * @param {PlaceRatingDeleteArgs} args - Arguments to delete one PlaceRating.
     * @example
     * // Delete one PlaceRating
     * const PlaceRating = await prisma.placeRating.delete({
     *   where: {
     *     // ... filter to delete one PlaceRating
     *   }
     * })
     * 
     */
    delete<T extends PlaceRatingDeleteArgs>(args: SelectSubset<T, PlaceRatingDeleteArgs<ExtArgs>>): Prisma__PlaceRatingClient<$Result.GetResult<Prisma.$PlaceRatingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlaceRating.
     * @param {PlaceRatingUpdateArgs} args - Arguments to update one PlaceRating.
     * @example
     * // Update one PlaceRating
     * const placeRating = await prisma.placeRating.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlaceRatingUpdateArgs>(args: SelectSubset<T, PlaceRatingUpdateArgs<ExtArgs>>): Prisma__PlaceRatingClient<$Result.GetResult<Prisma.$PlaceRatingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlaceRatings.
     * @param {PlaceRatingDeleteManyArgs} args - Arguments to filter PlaceRatings to delete.
     * @example
     * // Delete a few PlaceRatings
     * const { count } = await prisma.placeRating.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlaceRatingDeleteManyArgs>(args?: SelectSubset<T, PlaceRatingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlaceRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceRatingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlaceRatings
     * const placeRating = await prisma.placeRating.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlaceRatingUpdateManyArgs>(args: SelectSubset<T, PlaceRatingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlaceRatings and returns the data updated in the database.
     * @param {PlaceRatingUpdateManyAndReturnArgs} args - Arguments to update many PlaceRatings.
     * @example
     * // Update many PlaceRatings
     * const placeRating = await prisma.placeRating.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlaceRatings and only return the `id`
     * const placeRatingWithIdOnly = await prisma.placeRating.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlaceRatingUpdateManyAndReturnArgs>(args: SelectSubset<T, PlaceRatingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaceRatingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlaceRating.
     * @param {PlaceRatingUpsertArgs} args - Arguments to update or create a PlaceRating.
     * @example
     * // Update or create a PlaceRating
     * const placeRating = await prisma.placeRating.upsert({
     *   create: {
     *     // ... data to create a PlaceRating
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlaceRating we want to update
     *   }
     * })
     */
    upsert<T extends PlaceRatingUpsertArgs>(args: SelectSubset<T, PlaceRatingUpsertArgs<ExtArgs>>): Prisma__PlaceRatingClient<$Result.GetResult<Prisma.$PlaceRatingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlaceRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceRatingCountArgs} args - Arguments to filter PlaceRatings to count.
     * @example
     * // Count the number of PlaceRatings
     * const count = await prisma.placeRating.count({
     *   where: {
     *     // ... the filter for the PlaceRatings we want to count
     *   }
     * })
    **/
    count<T extends PlaceRatingCountArgs>(
      args?: Subset<T, PlaceRatingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlaceRatingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlaceRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceRatingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlaceRatingAggregateArgs>(args: Subset<T, PlaceRatingAggregateArgs>): Prisma.PrismaPromise<GetPlaceRatingAggregateType<T>>

    /**
     * Group by PlaceRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceRatingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlaceRatingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlaceRatingGroupByArgs['orderBy'] }
        : { orderBy?: PlaceRatingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlaceRatingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlaceRatingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlaceRating model
   */
  readonly fields: PlaceRatingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlaceRating.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlaceRatingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    place<T extends PlaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlaceDefaultArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlaceRating model
   */
  interface PlaceRatingFieldRefs {
    readonly id: FieldRef<"PlaceRating", 'Int'>
    readonly placeId: FieldRef<"PlaceRating", 'Int'>
    readonly userId: FieldRef<"PlaceRating", 'Int'>
    readonly bookingId: FieldRef<"PlaceRating", 'Int'>
    readonly ratingScore: FieldRef<"PlaceRating", 'Decimal'>
    readonly reviewComment: FieldRef<"PlaceRating", 'String'>
    readonly ratingDate: FieldRef<"PlaceRating", 'DateTime'>
    readonly isVerified: FieldRef<"PlaceRating", 'Boolean'>
    readonly createdAt: FieldRef<"PlaceRating", 'DateTime'>
    readonly updatedAt: FieldRef<"PlaceRating", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlaceRating findUnique
   */
  export type PlaceRatingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceRating
     */
    select?: PlaceRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceRating
     */
    omit?: PlaceRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceRatingInclude<ExtArgs> | null
    /**
     * Filter, which PlaceRating to fetch.
     */
    where: PlaceRatingWhereUniqueInput
  }

  /**
   * PlaceRating findUniqueOrThrow
   */
  export type PlaceRatingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceRating
     */
    select?: PlaceRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceRating
     */
    omit?: PlaceRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceRatingInclude<ExtArgs> | null
    /**
     * Filter, which PlaceRating to fetch.
     */
    where: PlaceRatingWhereUniqueInput
  }

  /**
   * PlaceRating findFirst
   */
  export type PlaceRatingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceRating
     */
    select?: PlaceRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceRating
     */
    omit?: PlaceRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceRatingInclude<ExtArgs> | null
    /**
     * Filter, which PlaceRating to fetch.
     */
    where?: PlaceRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaceRatings to fetch.
     */
    orderBy?: PlaceRatingOrderByWithRelationInput | PlaceRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlaceRatings.
     */
    cursor?: PlaceRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaceRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaceRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlaceRatings.
     */
    distinct?: PlaceRatingScalarFieldEnum | PlaceRatingScalarFieldEnum[]
  }

  /**
   * PlaceRating findFirstOrThrow
   */
  export type PlaceRatingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceRating
     */
    select?: PlaceRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceRating
     */
    omit?: PlaceRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceRatingInclude<ExtArgs> | null
    /**
     * Filter, which PlaceRating to fetch.
     */
    where?: PlaceRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaceRatings to fetch.
     */
    orderBy?: PlaceRatingOrderByWithRelationInput | PlaceRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlaceRatings.
     */
    cursor?: PlaceRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaceRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaceRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlaceRatings.
     */
    distinct?: PlaceRatingScalarFieldEnum | PlaceRatingScalarFieldEnum[]
  }

  /**
   * PlaceRating findMany
   */
  export type PlaceRatingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceRating
     */
    select?: PlaceRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceRating
     */
    omit?: PlaceRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceRatingInclude<ExtArgs> | null
    /**
     * Filter, which PlaceRatings to fetch.
     */
    where?: PlaceRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaceRatings to fetch.
     */
    orderBy?: PlaceRatingOrderByWithRelationInput | PlaceRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlaceRatings.
     */
    cursor?: PlaceRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaceRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaceRatings.
     */
    skip?: number
    distinct?: PlaceRatingScalarFieldEnum | PlaceRatingScalarFieldEnum[]
  }

  /**
   * PlaceRating create
   */
  export type PlaceRatingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceRating
     */
    select?: PlaceRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceRating
     */
    omit?: PlaceRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceRatingInclude<ExtArgs> | null
    /**
     * The data needed to create a PlaceRating.
     */
    data: XOR<PlaceRatingCreateInput, PlaceRatingUncheckedCreateInput>
  }

  /**
   * PlaceRating createMany
   */
  export type PlaceRatingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlaceRatings.
     */
    data: PlaceRatingCreateManyInput | PlaceRatingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlaceRating createManyAndReturn
   */
  export type PlaceRatingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceRating
     */
    select?: PlaceRatingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceRating
     */
    omit?: PlaceRatingOmit<ExtArgs> | null
    /**
     * The data used to create many PlaceRatings.
     */
    data: PlaceRatingCreateManyInput | PlaceRatingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceRatingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlaceRating update
   */
  export type PlaceRatingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceRating
     */
    select?: PlaceRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceRating
     */
    omit?: PlaceRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceRatingInclude<ExtArgs> | null
    /**
     * The data needed to update a PlaceRating.
     */
    data: XOR<PlaceRatingUpdateInput, PlaceRatingUncheckedUpdateInput>
    /**
     * Choose, which PlaceRating to update.
     */
    where: PlaceRatingWhereUniqueInput
  }

  /**
   * PlaceRating updateMany
   */
  export type PlaceRatingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlaceRatings.
     */
    data: XOR<PlaceRatingUpdateManyMutationInput, PlaceRatingUncheckedUpdateManyInput>
    /**
     * Filter which PlaceRatings to update
     */
    where?: PlaceRatingWhereInput
    /**
     * Limit how many PlaceRatings to update.
     */
    limit?: number
  }

  /**
   * PlaceRating updateManyAndReturn
   */
  export type PlaceRatingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceRating
     */
    select?: PlaceRatingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceRating
     */
    omit?: PlaceRatingOmit<ExtArgs> | null
    /**
     * The data used to update PlaceRatings.
     */
    data: XOR<PlaceRatingUpdateManyMutationInput, PlaceRatingUncheckedUpdateManyInput>
    /**
     * Filter which PlaceRatings to update
     */
    where?: PlaceRatingWhereInput
    /**
     * Limit how many PlaceRatings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceRatingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlaceRating upsert
   */
  export type PlaceRatingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceRating
     */
    select?: PlaceRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceRating
     */
    omit?: PlaceRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceRatingInclude<ExtArgs> | null
    /**
     * The filter to search for the PlaceRating to update in case it exists.
     */
    where: PlaceRatingWhereUniqueInput
    /**
     * In case the PlaceRating found by the `where` argument doesn't exist, create a new PlaceRating with this data.
     */
    create: XOR<PlaceRatingCreateInput, PlaceRatingUncheckedCreateInput>
    /**
     * In case the PlaceRating was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlaceRatingUpdateInput, PlaceRatingUncheckedUpdateInput>
  }

  /**
   * PlaceRating delete
   */
  export type PlaceRatingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceRating
     */
    select?: PlaceRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceRating
     */
    omit?: PlaceRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceRatingInclude<ExtArgs> | null
    /**
     * Filter which PlaceRating to delete.
     */
    where: PlaceRatingWhereUniqueInput
  }

  /**
   * PlaceRating deleteMany
   */
  export type PlaceRatingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlaceRatings to delete
     */
    where?: PlaceRatingWhereInput
    /**
     * Limit how many PlaceRatings to delete.
     */
    limit?: number
  }

  /**
   * PlaceRating without action
   */
  export type PlaceRatingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceRating
     */
    select?: PlaceRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceRating
     */
    omit?: PlaceRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceRatingInclude<ExtArgs> | null
  }


  /**
   * Model OperatingHour
   */

  export type AggregateOperatingHour = {
    _count: OperatingHourCountAggregateOutputType | null
    _avg: OperatingHourAvgAggregateOutputType | null
    _sum: OperatingHourSumAggregateOutputType | null
    _min: OperatingHourMinAggregateOutputType | null
    _max: OperatingHourMaxAggregateOutputType | null
  }

  export type OperatingHourAvgAggregateOutputType = {
    id: number | null
    placeId: number | null
  }

  export type OperatingHourSumAggregateOutputType = {
    id: number | null
    placeId: number | null
  }

  export type OperatingHourMinAggregateOutputType = {
    id: number | null
    placeId: number | null
    dayOfWeek: string | null
    openingTime: Date | null
    closingTime: Date | null
    is24hours: boolean | null
    isClosed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OperatingHourMaxAggregateOutputType = {
    id: number | null
    placeId: number | null
    dayOfWeek: string | null
    openingTime: Date | null
    closingTime: Date | null
    is24hours: boolean | null
    isClosed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OperatingHourCountAggregateOutputType = {
    id: number
    placeId: number
    dayOfWeek: number
    openingTime: number
    closingTime: number
    is24hours: number
    isClosed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OperatingHourAvgAggregateInputType = {
    id?: true
    placeId?: true
  }

  export type OperatingHourSumAggregateInputType = {
    id?: true
    placeId?: true
  }

  export type OperatingHourMinAggregateInputType = {
    id?: true
    placeId?: true
    dayOfWeek?: true
    openingTime?: true
    closingTime?: true
    is24hours?: true
    isClosed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OperatingHourMaxAggregateInputType = {
    id?: true
    placeId?: true
    dayOfWeek?: true
    openingTime?: true
    closingTime?: true
    is24hours?: true
    isClosed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OperatingHourCountAggregateInputType = {
    id?: true
    placeId?: true
    dayOfWeek?: true
    openingTime?: true
    closingTime?: true
    is24hours?: true
    isClosed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OperatingHourAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperatingHour to aggregate.
     */
    where?: OperatingHourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperatingHours to fetch.
     */
    orderBy?: OperatingHourOrderByWithRelationInput | OperatingHourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OperatingHourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperatingHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperatingHours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OperatingHours
    **/
    _count?: true | OperatingHourCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OperatingHourAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OperatingHourSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperatingHourMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperatingHourMaxAggregateInputType
  }

  export type GetOperatingHourAggregateType<T extends OperatingHourAggregateArgs> = {
        [P in keyof T & keyof AggregateOperatingHour]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperatingHour[P]>
      : GetScalarType<T[P], AggregateOperatingHour[P]>
  }




  export type OperatingHourGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperatingHourWhereInput
    orderBy?: OperatingHourOrderByWithAggregationInput | OperatingHourOrderByWithAggregationInput[]
    by: OperatingHourScalarFieldEnum[] | OperatingHourScalarFieldEnum
    having?: OperatingHourScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperatingHourCountAggregateInputType | true
    _avg?: OperatingHourAvgAggregateInputType
    _sum?: OperatingHourSumAggregateInputType
    _min?: OperatingHourMinAggregateInputType
    _max?: OperatingHourMaxAggregateInputType
  }

  export type OperatingHourGroupByOutputType = {
    id: number
    placeId: number
    dayOfWeek: string
    openingTime: Date | null
    closingTime: Date | null
    is24hours: boolean
    isClosed: boolean
    createdAt: Date
    updatedAt: Date | null
    _count: OperatingHourCountAggregateOutputType | null
    _avg: OperatingHourAvgAggregateOutputType | null
    _sum: OperatingHourSumAggregateOutputType | null
    _min: OperatingHourMinAggregateOutputType | null
    _max: OperatingHourMaxAggregateOutputType | null
  }

  type GetOperatingHourGroupByPayload<T extends OperatingHourGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OperatingHourGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperatingHourGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperatingHourGroupByOutputType[P]>
            : GetScalarType<T[P], OperatingHourGroupByOutputType[P]>
        }
      >
    >


  export type OperatingHourSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    placeId?: boolean
    dayOfWeek?: boolean
    openingTime?: boolean
    closingTime?: boolean
    is24hours?: boolean
    isClosed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operatingHour"]>

  export type OperatingHourSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    placeId?: boolean
    dayOfWeek?: boolean
    openingTime?: boolean
    closingTime?: boolean
    is24hours?: boolean
    isClosed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operatingHour"]>

  export type OperatingHourSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    placeId?: boolean
    dayOfWeek?: boolean
    openingTime?: boolean
    closingTime?: boolean
    is24hours?: boolean
    isClosed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operatingHour"]>

  export type OperatingHourSelectScalar = {
    id?: boolean
    placeId?: boolean
    dayOfWeek?: boolean
    openingTime?: boolean
    closingTime?: boolean
    is24hours?: boolean
    isClosed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OperatingHourOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "placeId" | "dayOfWeek" | "openingTime" | "closingTime" | "is24hours" | "isClosed" | "createdAt" | "updatedAt", ExtArgs["result"]["operatingHour"]>
  export type OperatingHourInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }
  export type OperatingHourIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }
  export type OperatingHourIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }

  export type $OperatingHourPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OperatingHour"
    objects: {
      place: Prisma.$PlacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      placeId: number
      dayOfWeek: string
      openingTime: Date | null
      closingTime: Date | null
      is24hours: boolean
      isClosed: boolean
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["operatingHour"]>
    composites: {}
  }

  type OperatingHourGetPayload<S extends boolean | null | undefined | OperatingHourDefaultArgs> = $Result.GetResult<Prisma.$OperatingHourPayload, S>

  type OperatingHourCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OperatingHourFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OperatingHourCountAggregateInputType | true
    }

  export interface OperatingHourDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OperatingHour'], meta: { name: 'OperatingHour' } }
    /**
     * Find zero or one OperatingHour that matches the filter.
     * @param {OperatingHourFindUniqueArgs} args - Arguments to find a OperatingHour
     * @example
     * // Get one OperatingHour
     * const operatingHour = await prisma.operatingHour.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OperatingHourFindUniqueArgs>(args: SelectSubset<T, OperatingHourFindUniqueArgs<ExtArgs>>): Prisma__OperatingHourClient<$Result.GetResult<Prisma.$OperatingHourPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OperatingHour that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OperatingHourFindUniqueOrThrowArgs} args - Arguments to find a OperatingHour
     * @example
     * // Get one OperatingHour
     * const operatingHour = await prisma.operatingHour.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OperatingHourFindUniqueOrThrowArgs>(args: SelectSubset<T, OperatingHourFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OperatingHourClient<$Result.GetResult<Prisma.$OperatingHourPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OperatingHour that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatingHourFindFirstArgs} args - Arguments to find a OperatingHour
     * @example
     * // Get one OperatingHour
     * const operatingHour = await prisma.operatingHour.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OperatingHourFindFirstArgs>(args?: SelectSubset<T, OperatingHourFindFirstArgs<ExtArgs>>): Prisma__OperatingHourClient<$Result.GetResult<Prisma.$OperatingHourPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OperatingHour that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatingHourFindFirstOrThrowArgs} args - Arguments to find a OperatingHour
     * @example
     * // Get one OperatingHour
     * const operatingHour = await prisma.operatingHour.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OperatingHourFindFirstOrThrowArgs>(args?: SelectSubset<T, OperatingHourFindFirstOrThrowArgs<ExtArgs>>): Prisma__OperatingHourClient<$Result.GetResult<Prisma.$OperatingHourPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OperatingHours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatingHourFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OperatingHours
     * const operatingHours = await prisma.operatingHour.findMany()
     * 
     * // Get first 10 OperatingHours
     * const operatingHours = await prisma.operatingHour.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const operatingHourWithIdOnly = await prisma.operatingHour.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OperatingHourFindManyArgs>(args?: SelectSubset<T, OperatingHourFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperatingHourPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OperatingHour.
     * @param {OperatingHourCreateArgs} args - Arguments to create a OperatingHour.
     * @example
     * // Create one OperatingHour
     * const OperatingHour = await prisma.operatingHour.create({
     *   data: {
     *     // ... data to create a OperatingHour
     *   }
     * })
     * 
     */
    create<T extends OperatingHourCreateArgs>(args: SelectSubset<T, OperatingHourCreateArgs<ExtArgs>>): Prisma__OperatingHourClient<$Result.GetResult<Prisma.$OperatingHourPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OperatingHours.
     * @param {OperatingHourCreateManyArgs} args - Arguments to create many OperatingHours.
     * @example
     * // Create many OperatingHours
     * const operatingHour = await prisma.operatingHour.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OperatingHourCreateManyArgs>(args?: SelectSubset<T, OperatingHourCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OperatingHours and returns the data saved in the database.
     * @param {OperatingHourCreateManyAndReturnArgs} args - Arguments to create many OperatingHours.
     * @example
     * // Create many OperatingHours
     * const operatingHour = await prisma.operatingHour.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OperatingHours and only return the `id`
     * const operatingHourWithIdOnly = await prisma.operatingHour.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OperatingHourCreateManyAndReturnArgs>(args?: SelectSubset<T, OperatingHourCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperatingHourPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OperatingHour.
     * @param {OperatingHourDeleteArgs} args - Arguments to delete one OperatingHour.
     * @example
     * // Delete one OperatingHour
     * const OperatingHour = await prisma.operatingHour.delete({
     *   where: {
     *     // ... filter to delete one OperatingHour
     *   }
     * })
     * 
     */
    delete<T extends OperatingHourDeleteArgs>(args: SelectSubset<T, OperatingHourDeleteArgs<ExtArgs>>): Prisma__OperatingHourClient<$Result.GetResult<Prisma.$OperatingHourPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OperatingHour.
     * @param {OperatingHourUpdateArgs} args - Arguments to update one OperatingHour.
     * @example
     * // Update one OperatingHour
     * const operatingHour = await prisma.operatingHour.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OperatingHourUpdateArgs>(args: SelectSubset<T, OperatingHourUpdateArgs<ExtArgs>>): Prisma__OperatingHourClient<$Result.GetResult<Prisma.$OperatingHourPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OperatingHours.
     * @param {OperatingHourDeleteManyArgs} args - Arguments to filter OperatingHours to delete.
     * @example
     * // Delete a few OperatingHours
     * const { count } = await prisma.operatingHour.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OperatingHourDeleteManyArgs>(args?: SelectSubset<T, OperatingHourDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OperatingHours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatingHourUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OperatingHours
     * const operatingHour = await prisma.operatingHour.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OperatingHourUpdateManyArgs>(args: SelectSubset<T, OperatingHourUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OperatingHours and returns the data updated in the database.
     * @param {OperatingHourUpdateManyAndReturnArgs} args - Arguments to update many OperatingHours.
     * @example
     * // Update many OperatingHours
     * const operatingHour = await prisma.operatingHour.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OperatingHours and only return the `id`
     * const operatingHourWithIdOnly = await prisma.operatingHour.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OperatingHourUpdateManyAndReturnArgs>(args: SelectSubset<T, OperatingHourUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperatingHourPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OperatingHour.
     * @param {OperatingHourUpsertArgs} args - Arguments to update or create a OperatingHour.
     * @example
     * // Update or create a OperatingHour
     * const operatingHour = await prisma.operatingHour.upsert({
     *   create: {
     *     // ... data to create a OperatingHour
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OperatingHour we want to update
     *   }
     * })
     */
    upsert<T extends OperatingHourUpsertArgs>(args: SelectSubset<T, OperatingHourUpsertArgs<ExtArgs>>): Prisma__OperatingHourClient<$Result.GetResult<Prisma.$OperatingHourPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OperatingHours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatingHourCountArgs} args - Arguments to filter OperatingHours to count.
     * @example
     * // Count the number of OperatingHours
     * const count = await prisma.operatingHour.count({
     *   where: {
     *     // ... the filter for the OperatingHours we want to count
     *   }
     * })
    **/
    count<T extends OperatingHourCountArgs>(
      args?: Subset<T, OperatingHourCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperatingHourCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OperatingHour.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatingHourAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperatingHourAggregateArgs>(args: Subset<T, OperatingHourAggregateArgs>): Prisma.PrismaPromise<GetOperatingHourAggregateType<T>>

    /**
     * Group by OperatingHour.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatingHourGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OperatingHourGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OperatingHourGroupByArgs['orderBy'] }
        : { orderBy?: OperatingHourGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OperatingHourGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperatingHourGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OperatingHour model
   */
  readonly fields: OperatingHourFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OperatingHour.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OperatingHourClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    place<T extends PlaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlaceDefaultArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OperatingHour model
   */
  interface OperatingHourFieldRefs {
    readonly id: FieldRef<"OperatingHour", 'Int'>
    readonly placeId: FieldRef<"OperatingHour", 'Int'>
    readonly dayOfWeek: FieldRef<"OperatingHour", 'String'>
    readonly openingTime: FieldRef<"OperatingHour", 'DateTime'>
    readonly closingTime: FieldRef<"OperatingHour", 'DateTime'>
    readonly is24hours: FieldRef<"OperatingHour", 'Boolean'>
    readonly isClosed: FieldRef<"OperatingHour", 'Boolean'>
    readonly createdAt: FieldRef<"OperatingHour", 'DateTime'>
    readonly updatedAt: FieldRef<"OperatingHour", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OperatingHour findUnique
   */
  export type OperatingHourFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatingHour
     */
    select?: OperatingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperatingHour
     */
    omit?: OperatingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatingHourInclude<ExtArgs> | null
    /**
     * Filter, which OperatingHour to fetch.
     */
    where: OperatingHourWhereUniqueInput
  }

  /**
   * OperatingHour findUniqueOrThrow
   */
  export type OperatingHourFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatingHour
     */
    select?: OperatingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperatingHour
     */
    omit?: OperatingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatingHourInclude<ExtArgs> | null
    /**
     * Filter, which OperatingHour to fetch.
     */
    where: OperatingHourWhereUniqueInput
  }

  /**
   * OperatingHour findFirst
   */
  export type OperatingHourFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatingHour
     */
    select?: OperatingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperatingHour
     */
    omit?: OperatingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatingHourInclude<ExtArgs> | null
    /**
     * Filter, which OperatingHour to fetch.
     */
    where?: OperatingHourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperatingHours to fetch.
     */
    orderBy?: OperatingHourOrderByWithRelationInput | OperatingHourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperatingHours.
     */
    cursor?: OperatingHourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperatingHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperatingHours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperatingHours.
     */
    distinct?: OperatingHourScalarFieldEnum | OperatingHourScalarFieldEnum[]
  }

  /**
   * OperatingHour findFirstOrThrow
   */
  export type OperatingHourFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatingHour
     */
    select?: OperatingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperatingHour
     */
    omit?: OperatingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatingHourInclude<ExtArgs> | null
    /**
     * Filter, which OperatingHour to fetch.
     */
    where?: OperatingHourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperatingHours to fetch.
     */
    orderBy?: OperatingHourOrderByWithRelationInput | OperatingHourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperatingHours.
     */
    cursor?: OperatingHourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperatingHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperatingHours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperatingHours.
     */
    distinct?: OperatingHourScalarFieldEnum | OperatingHourScalarFieldEnum[]
  }

  /**
   * OperatingHour findMany
   */
  export type OperatingHourFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatingHour
     */
    select?: OperatingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperatingHour
     */
    omit?: OperatingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatingHourInclude<ExtArgs> | null
    /**
     * Filter, which OperatingHours to fetch.
     */
    where?: OperatingHourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperatingHours to fetch.
     */
    orderBy?: OperatingHourOrderByWithRelationInput | OperatingHourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OperatingHours.
     */
    cursor?: OperatingHourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperatingHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperatingHours.
     */
    skip?: number
    distinct?: OperatingHourScalarFieldEnum | OperatingHourScalarFieldEnum[]
  }

  /**
   * OperatingHour create
   */
  export type OperatingHourCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatingHour
     */
    select?: OperatingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperatingHour
     */
    omit?: OperatingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatingHourInclude<ExtArgs> | null
    /**
     * The data needed to create a OperatingHour.
     */
    data: XOR<OperatingHourCreateInput, OperatingHourUncheckedCreateInput>
  }

  /**
   * OperatingHour createMany
   */
  export type OperatingHourCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OperatingHours.
     */
    data: OperatingHourCreateManyInput | OperatingHourCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OperatingHour createManyAndReturn
   */
  export type OperatingHourCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatingHour
     */
    select?: OperatingHourSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OperatingHour
     */
    omit?: OperatingHourOmit<ExtArgs> | null
    /**
     * The data used to create many OperatingHours.
     */
    data: OperatingHourCreateManyInput | OperatingHourCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatingHourIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OperatingHour update
   */
  export type OperatingHourUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatingHour
     */
    select?: OperatingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperatingHour
     */
    omit?: OperatingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatingHourInclude<ExtArgs> | null
    /**
     * The data needed to update a OperatingHour.
     */
    data: XOR<OperatingHourUpdateInput, OperatingHourUncheckedUpdateInput>
    /**
     * Choose, which OperatingHour to update.
     */
    where: OperatingHourWhereUniqueInput
  }

  /**
   * OperatingHour updateMany
   */
  export type OperatingHourUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OperatingHours.
     */
    data: XOR<OperatingHourUpdateManyMutationInput, OperatingHourUncheckedUpdateManyInput>
    /**
     * Filter which OperatingHours to update
     */
    where?: OperatingHourWhereInput
    /**
     * Limit how many OperatingHours to update.
     */
    limit?: number
  }

  /**
   * OperatingHour updateManyAndReturn
   */
  export type OperatingHourUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatingHour
     */
    select?: OperatingHourSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OperatingHour
     */
    omit?: OperatingHourOmit<ExtArgs> | null
    /**
     * The data used to update OperatingHours.
     */
    data: XOR<OperatingHourUpdateManyMutationInput, OperatingHourUncheckedUpdateManyInput>
    /**
     * Filter which OperatingHours to update
     */
    where?: OperatingHourWhereInput
    /**
     * Limit how many OperatingHours to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatingHourIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OperatingHour upsert
   */
  export type OperatingHourUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatingHour
     */
    select?: OperatingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperatingHour
     */
    omit?: OperatingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatingHourInclude<ExtArgs> | null
    /**
     * The filter to search for the OperatingHour to update in case it exists.
     */
    where: OperatingHourWhereUniqueInput
    /**
     * In case the OperatingHour found by the `where` argument doesn't exist, create a new OperatingHour with this data.
     */
    create: XOR<OperatingHourCreateInput, OperatingHourUncheckedCreateInput>
    /**
     * In case the OperatingHour was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OperatingHourUpdateInput, OperatingHourUncheckedUpdateInput>
  }

  /**
   * OperatingHour delete
   */
  export type OperatingHourDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatingHour
     */
    select?: OperatingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperatingHour
     */
    omit?: OperatingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatingHourInclude<ExtArgs> | null
    /**
     * Filter which OperatingHour to delete.
     */
    where: OperatingHourWhereUniqueInput
  }

  /**
   * OperatingHour deleteMany
   */
  export type OperatingHourDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperatingHours to delete
     */
    where?: OperatingHourWhereInput
    /**
     * Limit how many OperatingHours to delete.
     */
    limit?: number
  }

  /**
   * OperatingHour without action
   */
  export type OperatingHourDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatingHour
     */
    select?: OperatingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperatingHour
     */
    omit?: OperatingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatingHourInclude<ExtArgs> | null
  }


  /**
   * Model PlaceAdmin
   */

  export type AggregatePlaceAdmin = {
    _count: PlaceAdminCountAggregateOutputType | null
    _avg: PlaceAdminAvgAggregateOutputType | null
    _sum: PlaceAdminSumAggregateOutputType | null
    _min: PlaceAdminMinAggregateOutputType | null
    _max: PlaceAdminMaxAggregateOutputType | null
  }

  export type PlaceAdminAvgAggregateOutputType = {
    id: number | null
    placeId: number | null
  }

  export type PlaceAdminSumAggregateOutputType = {
    id: number | null
    placeId: number | null
  }

  export type PlaceAdminMinAggregateOutputType = {
    id: number | null
    placeId: number | null
    username: string | null
    email: string | null
    passwordHash: string | null
    fullName: string | null
    role: string | null
    contactNumber: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlaceAdminMaxAggregateOutputType = {
    id: number | null
    placeId: number | null
    username: string | null
    email: string | null
    passwordHash: string | null
    fullName: string | null
    role: string | null
    contactNumber: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlaceAdminCountAggregateOutputType = {
    id: number
    placeId: number
    username: number
    email: number
    passwordHash: number
    fullName: number
    role: number
    contactNumber: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlaceAdminAvgAggregateInputType = {
    id?: true
    placeId?: true
  }

  export type PlaceAdminSumAggregateInputType = {
    id?: true
    placeId?: true
  }

  export type PlaceAdminMinAggregateInputType = {
    id?: true
    placeId?: true
    username?: true
    email?: true
    passwordHash?: true
    fullName?: true
    role?: true
    contactNumber?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlaceAdminMaxAggregateInputType = {
    id?: true
    placeId?: true
    username?: true
    email?: true
    passwordHash?: true
    fullName?: true
    role?: true
    contactNumber?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlaceAdminCountAggregateInputType = {
    id?: true
    placeId?: true
    username?: true
    email?: true
    passwordHash?: true
    fullName?: true
    role?: true
    contactNumber?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlaceAdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlaceAdmin to aggregate.
     */
    where?: PlaceAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaceAdmins to fetch.
     */
    orderBy?: PlaceAdminOrderByWithRelationInput | PlaceAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlaceAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaceAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaceAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlaceAdmins
    **/
    _count?: true | PlaceAdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlaceAdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlaceAdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlaceAdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlaceAdminMaxAggregateInputType
  }

  export type GetPlaceAdminAggregateType<T extends PlaceAdminAggregateArgs> = {
        [P in keyof T & keyof AggregatePlaceAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlaceAdmin[P]>
      : GetScalarType<T[P], AggregatePlaceAdmin[P]>
  }




  export type PlaceAdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaceAdminWhereInput
    orderBy?: PlaceAdminOrderByWithAggregationInput | PlaceAdminOrderByWithAggregationInput[]
    by: PlaceAdminScalarFieldEnum[] | PlaceAdminScalarFieldEnum
    having?: PlaceAdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlaceAdminCountAggregateInputType | true
    _avg?: PlaceAdminAvgAggregateInputType
    _sum?: PlaceAdminSumAggregateInputType
    _min?: PlaceAdminMinAggregateInputType
    _max?: PlaceAdminMaxAggregateInputType
  }

  export type PlaceAdminGroupByOutputType = {
    id: number
    placeId: number
    username: string
    email: string
    passwordHash: string
    fullName: string
    role: string
    contactNumber: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date | null
    _count: PlaceAdminCountAggregateOutputType | null
    _avg: PlaceAdminAvgAggregateOutputType | null
    _sum: PlaceAdminSumAggregateOutputType | null
    _min: PlaceAdminMinAggregateOutputType | null
    _max: PlaceAdminMaxAggregateOutputType | null
  }

  type GetPlaceAdminGroupByPayload<T extends PlaceAdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlaceAdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlaceAdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlaceAdminGroupByOutputType[P]>
            : GetScalarType<T[P], PlaceAdminGroupByOutputType[P]>
        }
      >
    >


  export type PlaceAdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    placeId?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    fullName?: boolean
    role?: boolean
    contactNumber?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["placeAdmin"]>

  export type PlaceAdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    placeId?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    fullName?: boolean
    role?: boolean
    contactNumber?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["placeAdmin"]>

  export type PlaceAdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    placeId?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    fullName?: boolean
    role?: boolean
    contactNumber?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["placeAdmin"]>

  export type PlaceAdminSelectScalar = {
    id?: boolean
    placeId?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    fullName?: boolean
    role?: boolean
    contactNumber?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlaceAdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "placeId" | "username" | "email" | "passwordHash" | "fullName" | "role" | "contactNumber" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["placeAdmin"]>
  export type PlaceAdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }
  export type PlaceAdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }
  export type PlaceAdminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }

  export type $PlaceAdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlaceAdmin"
    objects: {
      place: Prisma.$PlacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      placeId: number
      username: string
      email: string
      passwordHash: string
      fullName: string
      role: string
      contactNumber: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["placeAdmin"]>
    composites: {}
  }

  type PlaceAdminGetPayload<S extends boolean | null | undefined | PlaceAdminDefaultArgs> = $Result.GetResult<Prisma.$PlaceAdminPayload, S>

  type PlaceAdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlaceAdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlaceAdminCountAggregateInputType | true
    }

  export interface PlaceAdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlaceAdmin'], meta: { name: 'PlaceAdmin' } }
    /**
     * Find zero or one PlaceAdmin that matches the filter.
     * @param {PlaceAdminFindUniqueArgs} args - Arguments to find a PlaceAdmin
     * @example
     * // Get one PlaceAdmin
     * const placeAdmin = await prisma.placeAdmin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlaceAdminFindUniqueArgs>(args: SelectSubset<T, PlaceAdminFindUniqueArgs<ExtArgs>>): Prisma__PlaceAdminClient<$Result.GetResult<Prisma.$PlaceAdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlaceAdmin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlaceAdminFindUniqueOrThrowArgs} args - Arguments to find a PlaceAdmin
     * @example
     * // Get one PlaceAdmin
     * const placeAdmin = await prisma.placeAdmin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlaceAdminFindUniqueOrThrowArgs>(args: SelectSubset<T, PlaceAdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlaceAdminClient<$Result.GetResult<Prisma.$PlaceAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlaceAdmin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceAdminFindFirstArgs} args - Arguments to find a PlaceAdmin
     * @example
     * // Get one PlaceAdmin
     * const placeAdmin = await prisma.placeAdmin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlaceAdminFindFirstArgs>(args?: SelectSubset<T, PlaceAdminFindFirstArgs<ExtArgs>>): Prisma__PlaceAdminClient<$Result.GetResult<Prisma.$PlaceAdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlaceAdmin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceAdminFindFirstOrThrowArgs} args - Arguments to find a PlaceAdmin
     * @example
     * // Get one PlaceAdmin
     * const placeAdmin = await prisma.placeAdmin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlaceAdminFindFirstOrThrowArgs>(args?: SelectSubset<T, PlaceAdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlaceAdminClient<$Result.GetResult<Prisma.$PlaceAdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlaceAdmins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceAdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlaceAdmins
     * const placeAdmins = await prisma.placeAdmin.findMany()
     * 
     * // Get first 10 PlaceAdmins
     * const placeAdmins = await prisma.placeAdmin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const placeAdminWithIdOnly = await prisma.placeAdmin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlaceAdminFindManyArgs>(args?: SelectSubset<T, PlaceAdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaceAdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlaceAdmin.
     * @param {PlaceAdminCreateArgs} args - Arguments to create a PlaceAdmin.
     * @example
     * // Create one PlaceAdmin
     * const PlaceAdmin = await prisma.placeAdmin.create({
     *   data: {
     *     // ... data to create a PlaceAdmin
     *   }
     * })
     * 
     */
    create<T extends PlaceAdminCreateArgs>(args: SelectSubset<T, PlaceAdminCreateArgs<ExtArgs>>): Prisma__PlaceAdminClient<$Result.GetResult<Prisma.$PlaceAdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlaceAdmins.
     * @param {PlaceAdminCreateManyArgs} args - Arguments to create many PlaceAdmins.
     * @example
     * // Create many PlaceAdmins
     * const placeAdmin = await prisma.placeAdmin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlaceAdminCreateManyArgs>(args?: SelectSubset<T, PlaceAdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlaceAdmins and returns the data saved in the database.
     * @param {PlaceAdminCreateManyAndReturnArgs} args - Arguments to create many PlaceAdmins.
     * @example
     * // Create many PlaceAdmins
     * const placeAdmin = await prisma.placeAdmin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlaceAdmins and only return the `id`
     * const placeAdminWithIdOnly = await prisma.placeAdmin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlaceAdminCreateManyAndReturnArgs>(args?: SelectSubset<T, PlaceAdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaceAdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlaceAdmin.
     * @param {PlaceAdminDeleteArgs} args - Arguments to delete one PlaceAdmin.
     * @example
     * // Delete one PlaceAdmin
     * const PlaceAdmin = await prisma.placeAdmin.delete({
     *   where: {
     *     // ... filter to delete one PlaceAdmin
     *   }
     * })
     * 
     */
    delete<T extends PlaceAdminDeleteArgs>(args: SelectSubset<T, PlaceAdminDeleteArgs<ExtArgs>>): Prisma__PlaceAdminClient<$Result.GetResult<Prisma.$PlaceAdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlaceAdmin.
     * @param {PlaceAdminUpdateArgs} args - Arguments to update one PlaceAdmin.
     * @example
     * // Update one PlaceAdmin
     * const placeAdmin = await prisma.placeAdmin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlaceAdminUpdateArgs>(args: SelectSubset<T, PlaceAdminUpdateArgs<ExtArgs>>): Prisma__PlaceAdminClient<$Result.GetResult<Prisma.$PlaceAdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlaceAdmins.
     * @param {PlaceAdminDeleteManyArgs} args - Arguments to filter PlaceAdmins to delete.
     * @example
     * // Delete a few PlaceAdmins
     * const { count } = await prisma.placeAdmin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlaceAdminDeleteManyArgs>(args?: SelectSubset<T, PlaceAdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlaceAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceAdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlaceAdmins
     * const placeAdmin = await prisma.placeAdmin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlaceAdminUpdateManyArgs>(args: SelectSubset<T, PlaceAdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlaceAdmins and returns the data updated in the database.
     * @param {PlaceAdminUpdateManyAndReturnArgs} args - Arguments to update many PlaceAdmins.
     * @example
     * // Update many PlaceAdmins
     * const placeAdmin = await prisma.placeAdmin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlaceAdmins and only return the `id`
     * const placeAdminWithIdOnly = await prisma.placeAdmin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlaceAdminUpdateManyAndReturnArgs>(args: SelectSubset<T, PlaceAdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaceAdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlaceAdmin.
     * @param {PlaceAdminUpsertArgs} args - Arguments to update or create a PlaceAdmin.
     * @example
     * // Update or create a PlaceAdmin
     * const placeAdmin = await prisma.placeAdmin.upsert({
     *   create: {
     *     // ... data to create a PlaceAdmin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlaceAdmin we want to update
     *   }
     * })
     */
    upsert<T extends PlaceAdminUpsertArgs>(args: SelectSubset<T, PlaceAdminUpsertArgs<ExtArgs>>): Prisma__PlaceAdminClient<$Result.GetResult<Prisma.$PlaceAdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlaceAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceAdminCountArgs} args - Arguments to filter PlaceAdmins to count.
     * @example
     * // Count the number of PlaceAdmins
     * const count = await prisma.placeAdmin.count({
     *   where: {
     *     // ... the filter for the PlaceAdmins we want to count
     *   }
     * })
    **/
    count<T extends PlaceAdminCountArgs>(
      args?: Subset<T, PlaceAdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlaceAdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlaceAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceAdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlaceAdminAggregateArgs>(args: Subset<T, PlaceAdminAggregateArgs>): Prisma.PrismaPromise<GetPlaceAdminAggregateType<T>>

    /**
     * Group by PlaceAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceAdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlaceAdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlaceAdminGroupByArgs['orderBy'] }
        : { orderBy?: PlaceAdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlaceAdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlaceAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlaceAdmin model
   */
  readonly fields: PlaceAdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlaceAdmin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlaceAdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    place<T extends PlaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlaceDefaultArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlaceAdmin model
   */
  interface PlaceAdminFieldRefs {
    readonly id: FieldRef<"PlaceAdmin", 'Int'>
    readonly placeId: FieldRef<"PlaceAdmin", 'Int'>
    readonly username: FieldRef<"PlaceAdmin", 'String'>
    readonly email: FieldRef<"PlaceAdmin", 'String'>
    readonly passwordHash: FieldRef<"PlaceAdmin", 'String'>
    readonly fullName: FieldRef<"PlaceAdmin", 'String'>
    readonly role: FieldRef<"PlaceAdmin", 'String'>
    readonly contactNumber: FieldRef<"PlaceAdmin", 'String'>
    readonly isActive: FieldRef<"PlaceAdmin", 'Boolean'>
    readonly createdAt: FieldRef<"PlaceAdmin", 'DateTime'>
    readonly updatedAt: FieldRef<"PlaceAdmin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlaceAdmin findUnique
   */
  export type PlaceAdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceAdmin
     */
    select?: PlaceAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceAdmin
     */
    omit?: PlaceAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceAdminInclude<ExtArgs> | null
    /**
     * Filter, which PlaceAdmin to fetch.
     */
    where: PlaceAdminWhereUniqueInput
  }

  /**
   * PlaceAdmin findUniqueOrThrow
   */
  export type PlaceAdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceAdmin
     */
    select?: PlaceAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceAdmin
     */
    omit?: PlaceAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceAdminInclude<ExtArgs> | null
    /**
     * Filter, which PlaceAdmin to fetch.
     */
    where: PlaceAdminWhereUniqueInput
  }

  /**
   * PlaceAdmin findFirst
   */
  export type PlaceAdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceAdmin
     */
    select?: PlaceAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceAdmin
     */
    omit?: PlaceAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceAdminInclude<ExtArgs> | null
    /**
     * Filter, which PlaceAdmin to fetch.
     */
    where?: PlaceAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaceAdmins to fetch.
     */
    orderBy?: PlaceAdminOrderByWithRelationInput | PlaceAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlaceAdmins.
     */
    cursor?: PlaceAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaceAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaceAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlaceAdmins.
     */
    distinct?: PlaceAdminScalarFieldEnum | PlaceAdminScalarFieldEnum[]
  }

  /**
   * PlaceAdmin findFirstOrThrow
   */
  export type PlaceAdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceAdmin
     */
    select?: PlaceAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceAdmin
     */
    omit?: PlaceAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceAdminInclude<ExtArgs> | null
    /**
     * Filter, which PlaceAdmin to fetch.
     */
    where?: PlaceAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaceAdmins to fetch.
     */
    orderBy?: PlaceAdminOrderByWithRelationInput | PlaceAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlaceAdmins.
     */
    cursor?: PlaceAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaceAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaceAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlaceAdmins.
     */
    distinct?: PlaceAdminScalarFieldEnum | PlaceAdminScalarFieldEnum[]
  }

  /**
   * PlaceAdmin findMany
   */
  export type PlaceAdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceAdmin
     */
    select?: PlaceAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceAdmin
     */
    omit?: PlaceAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceAdminInclude<ExtArgs> | null
    /**
     * Filter, which PlaceAdmins to fetch.
     */
    where?: PlaceAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaceAdmins to fetch.
     */
    orderBy?: PlaceAdminOrderByWithRelationInput | PlaceAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlaceAdmins.
     */
    cursor?: PlaceAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaceAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaceAdmins.
     */
    skip?: number
    distinct?: PlaceAdminScalarFieldEnum | PlaceAdminScalarFieldEnum[]
  }

  /**
   * PlaceAdmin create
   */
  export type PlaceAdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceAdmin
     */
    select?: PlaceAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceAdmin
     */
    omit?: PlaceAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceAdminInclude<ExtArgs> | null
    /**
     * The data needed to create a PlaceAdmin.
     */
    data: XOR<PlaceAdminCreateInput, PlaceAdminUncheckedCreateInput>
  }

  /**
   * PlaceAdmin createMany
   */
  export type PlaceAdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlaceAdmins.
     */
    data: PlaceAdminCreateManyInput | PlaceAdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlaceAdmin createManyAndReturn
   */
  export type PlaceAdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceAdmin
     */
    select?: PlaceAdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceAdmin
     */
    omit?: PlaceAdminOmit<ExtArgs> | null
    /**
     * The data used to create many PlaceAdmins.
     */
    data: PlaceAdminCreateManyInput | PlaceAdminCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceAdminIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlaceAdmin update
   */
  export type PlaceAdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceAdmin
     */
    select?: PlaceAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceAdmin
     */
    omit?: PlaceAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceAdminInclude<ExtArgs> | null
    /**
     * The data needed to update a PlaceAdmin.
     */
    data: XOR<PlaceAdminUpdateInput, PlaceAdminUncheckedUpdateInput>
    /**
     * Choose, which PlaceAdmin to update.
     */
    where: PlaceAdminWhereUniqueInput
  }

  /**
   * PlaceAdmin updateMany
   */
  export type PlaceAdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlaceAdmins.
     */
    data: XOR<PlaceAdminUpdateManyMutationInput, PlaceAdminUncheckedUpdateManyInput>
    /**
     * Filter which PlaceAdmins to update
     */
    where?: PlaceAdminWhereInput
    /**
     * Limit how many PlaceAdmins to update.
     */
    limit?: number
  }

  /**
   * PlaceAdmin updateManyAndReturn
   */
  export type PlaceAdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceAdmin
     */
    select?: PlaceAdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceAdmin
     */
    omit?: PlaceAdminOmit<ExtArgs> | null
    /**
     * The data used to update PlaceAdmins.
     */
    data: XOR<PlaceAdminUpdateManyMutationInput, PlaceAdminUncheckedUpdateManyInput>
    /**
     * Filter which PlaceAdmins to update
     */
    where?: PlaceAdminWhereInput
    /**
     * Limit how many PlaceAdmins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceAdminIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlaceAdmin upsert
   */
  export type PlaceAdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceAdmin
     */
    select?: PlaceAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceAdmin
     */
    omit?: PlaceAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceAdminInclude<ExtArgs> | null
    /**
     * The filter to search for the PlaceAdmin to update in case it exists.
     */
    where: PlaceAdminWhereUniqueInput
    /**
     * In case the PlaceAdmin found by the `where` argument doesn't exist, create a new PlaceAdmin with this data.
     */
    create: XOR<PlaceAdminCreateInput, PlaceAdminUncheckedCreateInput>
    /**
     * In case the PlaceAdmin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlaceAdminUpdateInput, PlaceAdminUncheckedUpdateInput>
  }

  /**
   * PlaceAdmin delete
   */
  export type PlaceAdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceAdmin
     */
    select?: PlaceAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceAdmin
     */
    omit?: PlaceAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceAdminInclude<ExtArgs> | null
    /**
     * Filter which PlaceAdmin to delete.
     */
    where: PlaceAdminWhereUniqueInput
  }

  /**
   * PlaceAdmin deleteMany
   */
  export type PlaceAdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlaceAdmins to delete
     */
    where?: PlaceAdminWhereInput
    /**
     * Limit how many PlaceAdmins to delete.
     */
    limit?: number
  }

  /**
   * PlaceAdmin without action
   */
  export type PlaceAdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceAdmin
     */
    select?: PlaceAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceAdmin
     */
    omit?: PlaceAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceAdminInclude<ExtArgs> | null
  }


  /**
   * Model SystemLog
   */

  export type AggregateSystemLog = {
    _count: SystemLogCountAggregateOutputType | null
    _avg: SystemLogAvgAggregateOutputType | null
    _sum: SystemLogSumAggregateOutputType | null
    _min: SystemLogMinAggregateOutputType | null
    _max: SystemLogMaxAggregateOutputType | null
  }

  export type SystemLogAvgAggregateOutputType = {
    id: number | null
    entityId: number | null
  }

  export type SystemLogSumAggregateOutputType = {
    id: number | null
    entityId: number | null
  }

  export type SystemLogMinAggregateOutputType = {
    id: number | null
    entityType: string | null
    entityId: number | null
    action: string | null
    performedBy: string | null
    logLevel: string | null
    logDetails: string | null
    logTime: Date | null
    createdAt: Date | null
  }

  export type SystemLogMaxAggregateOutputType = {
    id: number | null
    entityType: string | null
    entityId: number | null
    action: string | null
    performedBy: string | null
    logLevel: string | null
    logDetails: string | null
    logTime: Date | null
    createdAt: Date | null
  }

  export type SystemLogCountAggregateOutputType = {
    id: number
    entityType: number
    entityId: number
    action: number
    performedBy: number
    logLevel: number
    logDetails: number
    logTime: number
    createdAt: number
    _all: number
  }


  export type SystemLogAvgAggregateInputType = {
    id?: true
    entityId?: true
  }

  export type SystemLogSumAggregateInputType = {
    id?: true
    entityId?: true
  }

  export type SystemLogMinAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    action?: true
    performedBy?: true
    logLevel?: true
    logDetails?: true
    logTime?: true
    createdAt?: true
  }

  export type SystemLogMaxAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    action?: true
    performedBy?: true
    logLevel?: true
    logDetails?: true
    logTime?: true
    createdAt?: true
  }

  export type SystemLogCountAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    action?: true
    performedBy?: true
    logLevel?: true
    logDetails?: true
    logTime?: true
    createdAt?: true
    _all?: true
  }

  export type SystemLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemLog to aggregate.
     */
    where?: SystemLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemLogs to fetch.
     */
    orderBy?: SystemLogOrderByWithRelationInput | SystemLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemLogs
    **/
    _count?: true | SystemLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemLogMaxAggregateInputType
  }

  export type GetSystemLogAggregateType<T extends SystemLogAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemLog[P]>
      : GetScalarType<T[P], AggregateSystemLog[P]>
  }




  export type SystemLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemLogWhereInput
    orderBy?: SystemLogOrderByWithAggregationInput | SystemLogOrderByWithAggregationInput[]
    by: SystemLogScalarFieldEnum[] | SystemLogScalarFieldEnum
    having?: SystemLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemLogCountAggregateInputType | true
    _avg?: SystemLogAvgAggregateInputType
    _sum?: SystemLogSumAggregateInputType
    _min?: SystemLogMinAggregateInputType
    _max?: SystemLogMaxAggregateInputType
  }

  export type SystemLogGroupByOutputType = {
    id: number
    entityType: string
    entityId: number
    action: string
    performedBy: string
    logLevel: string
    logDetails: string | null
    logTime: Date
    createdAt: Date
    _count: SystemLogCountAggregateOutputType | null
    _avg: SystemLogAvgAggregateOutputType | null
    _sum: SystemLogSumAggregateOutputType | null
    _min: SystemLogMinAggregateOutputType | null
    _max: SystemLogMaxAggregateOutputType | null
  }

  type GetSystemLogGroupByPayload<T extends SystemLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemLogGroupByOutputType[P]>
            : GetScalarType<T[P], SystemLogGroupByOutputType[P]>
        }
      >
    >


  export type SystemLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    performedBy?: boolean
    logLevel?: boolean
    logDetails?: boolean
    logTime?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["systemLog"]>

  export type SystemLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    performedBy?: boolean
    logLevel?: boolean
    logDetails?: boolean
    logTime?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["systemLog"]>

  export type SystemLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    performedBy?: boolean
    logLevel?: boolean
    logDetails?: boolean
    logTime?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["systemLog"]>

  export type SystemLogSelectScalar = {
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    performedBy?: boolean
    logLevel?: boolean
    logDetails?: boolean
    logTime?: boolean
    createdAt?: boolean
  }

  export type SystemLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entityType" | "entityId" | "action" | "performedBy" | "logLevel" | "logDetails" | "logTime" | "createdAt", ExtArgs["result"]["systemLog"]>

  export type $SystemLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      entityType: string
      entityId: number
      action: string
      performedBy: string
      logLevel: string
      logDetails: string | null
      logTime: Date
      createdAt: Date
    }, ExtArgs["result"]["systemLog"]>
    composites: {}
  }

  type SystemLogGetPayload<S extends boolean | null | undefined | SystemLogDefaultArgs> = $Result.GetResult<Prisma.$SystemLogPayload, S>

  type SystemLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemLogCountAggregateInputType | true
    }

  export interface SystemLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemLog'], meta: { name: 'SystemLog' } }
    /**
     * Find zero or one SystemLog that matches the filter.
     * @param {SystemLogFindUniqueArgs} args - Arguments to find a SystemLog
     * @example
     * // Get one SystemLog
     * const systemLog = await prisma.systemLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemLogFindUniqueArgs>(args: SelectSubset<T, SystemLogFindUniqueArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemLogFindUniqueOrThrowArgs} args - Arguments to find a SystemLog
     * @example
     * // Get one SystemLog
     * const systemLog = await prisma.systemLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemLogFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogFindFirstArgs} args - Arguments to find a SystemLog
     * @example
     * // Get one SystemLog
     * const systemLog = await prisma.systemLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemLogFindFirstArgs>(args?: SelectSubset<T, SystemLogFindFirstArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogFindFirstOrThrowArgs} args - Arguments to find a SystemLog
     * @example
     * // Get one SystemLog
     * const systemLog = await prisma.systemLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemLogFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemLogs
     * const systemLogs = await prisma.systemLog.findMany()
     * 
     * // Get first 10 SystemLogs
     * const systemLogs = await prisma.systemLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemLogWithIdOnly = await prisma.systemLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemLogFindManyArgs>(args?: SelectSubset<T, SystemLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemLog.
     * @param {SystemLogCreateArgs} args - Arguments to create a SystemLog.
     * @example
     * // Create one SystemLog
     * const SystemLog = await prisma.systemLog.create({
     *   data: {
     *     // ... data to create a SystemLog
     *   }
     * })
     * 
     */
    create<T extends SystemLogCreateArgs>(args: SelectSubset<T, SystemLogCreateArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemLogs.
     * @param {SystemLogCreateManyArgs} args - Arguments to create many SystemLogs.
     * @example
     * // Create many SystemLogs
     * const systemLog = await prisma.systemLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemLogCreateManyArgs>(args?: SelectSubset<T, SystemLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemLogs and returns the data saved in the database.
     * @param {SystemLogCreateManyAndReturnArgs} args - Arguments to create many SystemLogs.
     * @example
     * // Create many SystemLogs
     * const systemLog = await prisma.systemLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemLogs and only return the `id`
     * const systemLogWithIdOnly = await prisma.systemLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemLogCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemLog.
     * @param {SystemLogDeleteArgs} args - Arguments to delete one SystemLog.
     * @example
     * // Delete one SystemLog
     * const SystemLog = await prisma.systemLog.delete({
     *   where: {
     *     // ... filter to delete one SystemLog
     *   }
     * })
     * 
     */
    delete<T extends SystemLogDeleteArgs>(args: SelectSubset<T, SystemLogDeleteArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemLog.
     * @param {SystemLogUpdateArgs} args - Arguments to update one SystemLog.
     * @example
     * // Update one SystemLog
     * const systemLog = await prisma.systemLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemLogUpdateArgs>(args: SelectSubset<T, SystemLogUpdateArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemLogs.
     * @param {SystemLogDeleteManyArgs} args - Arguments to filter SystemLogs to delete.
     * @example
     * // Delete a few SystemLogs
     * const { count } = await prisma.systemLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemLogDeleteManyArgs>(args?: SelectSubset<T, SystemLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemLogs
     * const systemLog = await prisma.systemLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemLogUpdateManyArgs>(args: SelectSubset<T, SystemLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemLogs and returns the data updated in the database.
     * @param {SystemLogUpdateManyAndReturnArgs} args - Arguments to update many SystemLogs.
     * @example
     * // Update many SystemLogs
     * const systemLog = await prisma.systemLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemLogs and only return the `id`
     * const systemLogWithIdOnly = await prisma.systemLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemLogUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemLog.
     * @param {SystemLogUpsertArgs} args - Arguments to update or create a SystemLog.
     * @example
     * // Update or create a SystemLog
     * const systemLog = await prisma.systemLog.upsert({
     *   create: {
     *     // ... data to create a SystemLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemLog we want to update
     *   }
     * })
     */
    upsert<T extends SystemLogUpsertArgs>(args: SelectSubset<T, SystemLogUpsertArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogCountArgs} args - Arguments to filter SystemLogs to count.
     * @example
     * // Count the number of SystemLogs
     * const count = await prisma.systemLog.count({
     *   where: {
     *     // ... the filter for the SystemLogs we want to count
     *   }
     * })
    **/
    count<T extends SystemLogCountArgs>(
      args?: Subset<T, SystemLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemLogAggregateArgs>(args: Subset<T, SystemLogAggregateArgs>): Prisma.PrismaPromise<GetSystemLogAggregateType<T>>

    /**
     * Group by SystemLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemLogGroupByArgs['orderBy'] }
        : { orderBy?: SystemLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemLog model
   */
  readonly fields: SystemLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemLog model
   */
  interface SystemLogFieldRefs {
    readonly id: FieldRef<"SystemLog", 'Int'>
    readonly entityType: FieldRef<"SystemLog", 'String'>
    readonly entityId: FieldRef<"SystemLog", 'Int'>
    readonly action: FieldRef<"SystemLog", 'String'>
    readonly performedBy: FieldRef<"SystemLog", 'String'>
    readonly logLevel: FieldRef<"SystemLog", 'String'>
    readonly logDetails: FieldRef<"SystemLog", 'String'>
    readonly logTime: FieldRef<"SystemLog", 'DateTime'>
    readonly createdAt: FieldRef<"SystemLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemLog findUnique
   */
  export type SystemLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemLog
     */
    omit?: SystemLogOmit<ExtArgs> | null
    /**
     * Filter, which SystemLog to fetch.
     */
    where: SystemLogWhereUniqueInput
  }

  /**
   * SystemLog findUniqueOrThrow
   */
  export type SystemLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemLog
     */
    omit?: SystemLogOmit<ExtArgs> | null
    /**
     * Filter, which SystemLog to fetch.
     */
    where: SystemLogWhereUniqueInput
  }

  /**
   * SystemLog findFirst
   */
  export type SystemLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemLog
     */
    omit?: SystemLogOmit<ExtArgs> | null
    /**
     * Filter, which SystemLog to fetch.
     */
    where?: SystemLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemLogs to fetch.
     */
    orderBy?: SystemLogOrderByWithRelationInput | SystemLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemLogs.
     */
    cursor?: SystemLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemLogs.
     */
    distinct?: SystemLogScalarFieldEnum | SystemLogScalarFieldEnum[]
  }

  /**
   * SystemLog findFirstOrThrow
   */
  export type SystemLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemLog
     */
    omit?: SystemLogOmit<ExtArgs> | null
    /**
     * Filter, which SystemLog to fetch.
     */
    where?: SystemLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemLogs to fetch.
     */
    orderBy?: SystemLogOrderByWithRelationInput | SystemLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemLogs.
     */
    cursor?: SystemLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemLogs.
     */
    distinct?: SystemLogScalarFieldEnum | SystemLogScalarFieldEnum[]
  }

  /**
   * SystemLog findMany
   */
  export type SystemLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemLog
     */
    omit?: SystemLogOmit<ExtArgs> | null
    /**
     * Filter, which SystemLogs to fetch.
     */
    where?: SystemLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemLogs to fetch.
     */
    orderBy?: SystemLogOrderByWithRelationInput | SystemLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemLogs.
     */
    cursor?: SystemLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemLogs.
     */
    skip?: number
    distinct?: SystemLogScalarFieldEnum | SystemLogScalarFieldEnum[]
  }

  /**
   * SystemLog create
   */
  export type SystemLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemLog
     */
    omit?: SystemLogOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemLog.
     */
    data: XOR<SystemLogCreateInput, SystemLogUncheckedCreateInput>
  }

  /**
   * SystemLog createMany
   */
  export type SystemLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemLogs.
     */
    data: SystemLogCreateManyInput | SystemLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemLog createManyAndReturn
   */
  export type SystemLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemLog
     */
    omit?: SystemLogOmit<ExtArgs> | null
    /**
     * The data used to create many SystemLogs.
     */
    data: SystemLogCreateManyInput | SystemLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemLog update
   */
  export type SystemLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemLog
     */
    omit?: SystemLogOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemLog.
     */
    data: XOR<SystemLogUpdateInput, SystemLogUncheckedUpdateInput>
    /**
     * Choose, which SystemLog to update.
     */
    where: SystemLogWhereUniqueInput
  }

  /**
   * SystemLog updateMany
   */
  export type SystemLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemLogs.
     */
    data: XOR<SystemLogUpdateManyMutationInput, SystemLogUncheckedUpdateManyInput>
    /**
     * Filter which SystemLogs to update
     */
    where?: SystemLogWhereInput
    /**
     * Limit how many SystemLogs to update.
     */
    limit?: number
  }

  /**
   * SystemLog updateManyAndReturn
   */
  export type SystemLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemLog
     */
    omit?: SystemLogOmit<ExtArgs> | null
    /**
     * The data used to update SystemLogs.
     */
    data: XOR<SystemLogUpdateManyMutationInput, SystemLogUncheckedUpdateManyInput>
    /**
     * Filter which SystemLogs to update
     */
    where?: SystemLogWhereInput
    /**
     * Limit how many SystemLogs to update.
     */
    limit?: number
  }

  /**
   * SystemLog upsert
   */
  export type SystemLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemLog
     */
    omit?: SystemLogOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemLog to update in case it exists.
     */
    where: SystemLogWhereUniqueInput
    /**
     * In case the SystemLog found by the `where` argument doesn't exist, create a new SystemLog with this data.
     */
    create: XOR<SystemLogCreateInput, SystemLogUncheckedCreateInput>
    /**
     * In case the SystemLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemLogUpdateInput, SystemLogUncheckedUpdateInput>
  }

  /**
   * SystemLog delete
   */
  export type SystemLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemLog
     */
    omit?: SystemLogOmit<ExtArgs> | null
    /**
     * Filter which SystemLog to delete.
     */
    where: SystemLogWhereUniqueInput
  }

  /**
   * SystemLog deleteMany
   */
  export type SystemLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemLogs to delete
     */
    where?: SystemLogWhereInput
    /**
     * Limit how many SystemLogs to delete.
     */
    limit?: number
  }

  /**
   * SystemLog without action
   */
  export type SystemLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemLog
     */
    omit?: SystemLogOmit<ExtArgs> | null
  }


  /**
   * Model EmailVerificationToken
   */

  export type AggregateEmailVerificationToken = {
    _count: EmailVerificationTokenCountAggregateOutputType | null
    _avg: EmailVerificationTokenAvgAggregateOutputType | null
    _sum: EmailVerificationTokenSumAggregateOutputType | null
    _min: EmailVerificationTokenMinAggregateOutputType | null
    _max: EmailVerificationTokenMaxAggregateOutputType | null
  }

  export type EmailVerificationTokenAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type EmailVerificationTokenSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type EmailVerificationTokenMinAggregateOutputType = {
    id: number | null
    userId: number | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type EmailVerificationTokenMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type EmailVerificationTokenCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type EmailVerificationTokenAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type EmailVerificationTokenSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type EmailVerificationTokenMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
  }

  export type EmailVerificationTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
  }

  export type EmailVerificationTokenCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type EmailVerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailVerificationToken to aggregate.
     */
    where?: EmailVerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailVerificationTokens to fetch.
     */
    orderBy?: EmailVerificationTokenOrderByWithRelationInput | EmailVerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailVerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailVerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailVerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailVerificationTokens
    **/
    _count?: true | EmailVerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailVerificationTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailVerificationTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailVerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailVerificationTokenMaxAggregateInputType
  }

  export type GetEmailVerificationTokenAggregateType<T extends EmailVerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailVerificationToken[P]>
      : GetScalarType<T[P], AggregateEmailVerificationToken[P]>
  }




  export type EmailVerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailVerificationTokenWhereInput
    orderBy?: EmailVerificationTokenOrderByWithAggregationInput | EmailVerificationTokenOrderByWithAggregationInput[]
    by: EmailVerificationTokenScalarFieldEnum[] | EmailVerificationTokenScalarFieldEnum
    having?: EmailVerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailVerificationTokenCountAggregateInputType | true
    _avg?: EmailVerificationTokenAvgAggregateInputType
    _sum?: EmailVerificationTokenSumAggregateInputType
    _min?: EmailVerificationTokenMinAggregateInputType
    _max?: EmailVerificationTokenMaxAggregateInputType
  }

  export type EmailVerificationTokenGroupByOutputType = {
    id: number
    userId: number
    token: string
    expiresAt: Date
    createdAt: Date
    _count: EmailVerificationTokenCountAggregateOutputType | null
    _avg: EmailVerificationTokenAvgAggregateOutputType | null
    _sum: EmailVerificationTokenSumAggregateOutputType | null
    _min: EmailVerificationTokenMinAggregateOutputType | null
    _max: EmailVerificationTokenMaxAggregateOutputType | null
  }

  type GetEmailVerificationTokenGroupByPayload<T extends EmailVerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailVerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailVerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailVerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], EmailVerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type EmailVerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailVerificationToken"]>

  export type EmailVerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailVerificationToken"]>

  export type EmailVerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailVerificationToken"]>

  export type EmailVerificationTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type EmailVerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "expiresAt" | "createdAt", ExtArgs["result"]["emailVerificationToken"]>
  export type EmailVerificationTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmailVerificationTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmailVerificationTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EmailVerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailVerificationToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      token: string
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["emailVerificationToken"]>
    composites: {}
  }

  type EmailVerificationTokenGetPayload<S extends boolean | null | undefined | EmailVerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$EmailVerificationTokenPayload, S>

  type EmailVerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailVerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailVerificationTokenCountAggregateInputType | true
    }

  export interface EmailVerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailVerificationToken'], meta: { name: 'EmailVerificationToken' } }
    /**
     * Find zero or one EmailVerificationToken that matches the filter.
     * @param {EmailVerificationTokenFindUniqueArgs} args - Arguments to find a EmailVerificationToken
     * @example
     * // Get one EmailVerificationToken
     * const emailVerificationToken = await prisma.emailVerificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailVerificationTokenFindUniqueArgs>(args: SelectSubset<T, EmailVerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__EmailVerificationTokenClient<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailVerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailVerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a EmailVerificationToken
     * @example
     * // Get one EmailVerificationToken
     * const emailVerificationToken = await prisma.emailVerificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailVerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailVerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailVerificationTokenClient<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailVerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenFindFirstArgs} args - Arguments to find a EmailVerificationToken
     * @example
     * // Get one EmailVerificationToken
     * const emailVerificationToken = await prisma.emailVerificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailVerificationTokenFindFirstArgs>(args?: SelectSubset<T, EmailVerificationTokenFindFirstArgs<ExtArgs>>): Prisma__EmailVerificationTokenClient<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailVerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenFindFirstOrThrowArgs} args - Arguments to find a EmailVerificationToken
     * @example
     * // Get one EmailVerificationToken
     * const emailVerificationToken = await prisma.emailVerificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailVerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailVerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailVerificationTokenClient<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailVerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailVerificationTokens
     * const emailVerificationTokens = await prisma.emailVerificationToken.findMany()
     * 
     * // Get first 10 EmailVerificationTokens
     * const emailVerificationTokens = await prisma.emailVerificationToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailVerificationTokenWithIdOnly = await prisma.emailVerificationToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailVerificationTokenFindManyArgs>(args?: SelectSubset<T, EmailVerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailVerificationToken.
     * @param {EmailVerificationTokenCreateArgs} args - Arguments to create a EmailVerificationToken.
     * @example
     * // Create one EmailVerificationToken
     * const EmailVerificationToken = await prisma.emailVerificationToken.create({
     *   data: {
     *     // ... data to create a EmailVerificationToken
     *   }
     * })
     * 
     */
    create<T extends EmailVerificationTokenCreateArgs>(args: SelectSubset<T, EmailVerificationTokenCreateArgs<ExtArgs>>): Prisma__EmailVerificationTokenClient<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailVerificationTokens.
     * @param {EmailVerificationTokenCreateManyArgs} args - Arguments to create many EmailVerificationTokens.
     * @example
     * // Create many EmailVerificationTokens
     * const emailVerificationToken = await prisma.emailVerificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailVerificationTokenCreateManyArgs>(args?: SelectSubset<T, EmailVerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailVerificationTokens and returns the data saved in the database.
     * @param {EmailVerificationTokenCreateManyAndReturnArgs} args - Arguments to create many EmailVerificationTokens.
     * @example
     * // Create many EmailVerificationTokens
     * const emailVerificationToken = await prisma.emailVerificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailVerificationTokens and only return the `id`
     * const emailVerificationTokenWithIdOnly = await prisma.emailVerificationToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailVerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailVerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailVerificationToken.
     * @param {EmailVerificationTokenDeleteArgs} args - Arguments to delete one EmailVerificationToken.
     * @example
     * // Delete one EmailVerificationToken
     * const EmailVerificationToken = await prisma.emailVerificationToken.delete({
     *   where: {
     *     // ... filter to delete one EmailVerificationToken
     *   }
     * })
     * 
     */
    delete<T extends EmailVerificationTokenDeleteArgs>(args: SelectSubset<T, EmailVerificationTokenDeleteArgs<ExtArgs>>): Prisma__EmailVerificationTokenClient<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailVerificationToken.
     * @param {EmailVerificationTokenUpdateArgs} args - Arguments to update one EmailVerificationToken.
     * @example
     * // Update one EmailVerificationToken
     * const emailVerificationToken = await prisma.emailVerificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailVerificationTokenUpdateArgs>(args: SelectSubset<T, EmailVerificationTokenUpdateArgs<ExtArgs>>): Prisma__EmailVerificationTokenClient<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailVerificationTokens.
     * @param {EmailVerificationTokenDeleteManyArgs} args - Arguments to filter EmailVerificationTokens to delete.
     * @example
     * // Delete a few EmailVerificationTokens
     * const { count } = await prisma.emailVerificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailVerificationTokenDeleteManyArgs>(args?: SelectSubset<T, EmailVerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailVerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailVerificationTokens
     * const emailVerificationToken = await prisma.emailVerificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailVerificationTokenUpdateManyArgs>(args: SelectSubset<T, EmailVerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailVerificationTokens and returns the data updated in the database.
     * @param {EmailVerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many EmailVerificationTokens.
     * @example
     * // Update many EmailVerificationTokens
     * const emailVerificationToken = await prisma.emailVerificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailVerificationTokens and only return the `id`
     * const emailVerificationTokenWithIdOnly = await prisma.emailVerificationToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailVerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailVerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailVerificationToken.
     * @param {EmailVerificationTokenUpsertArgs} args - Arguments to update or create a EmailVerificationToken.
     * @example
     * // Update or create a EmailVerificationToken
     * const emailVerificationToken = await prisma.emailVerificationToken.upsert({
     *   create: {
     *     // ... data to create a EmailVerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailVerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends EmailVerificationTokenUpsertArgs>(args: SelectSubset<T, EmailVerificationTokenUpsertArgs<ExtArgs>>): Prisma__EmailVerificationTokenClient<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailVerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenCountArgs} args - Arguments to filter EmailVerificationTokens to count.
     * @example
     * // Count the number of EmailVerificationTokens
     * const count = await prisma.emailVerificationToken.count({
     *   where: {
     *     // ... the filter for the EmailVerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends EmailVerificationTokenCountArgs>(
      args?: Subset<T, EmailVerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailVerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailVerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailVerificationTokenAggregateArgs>(args: Subset<T, EmailVerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetEmailVerificationTokenAggregateType<T>>

    /**
     * Group by EmailVerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailVerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailVerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: EmailVerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailVerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailVerificationToken model
   */
  readonly fields: EmailVerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailVerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailVerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailVerificationToken model
   */
  interface EmailVerificationTokenFieldRefs {
    readonly id: FieldRef<"EmailVerificationToken", 'Int'>
    readonly userId: FieldRef<"EmailVerificationToken", 'Int'>
    readonly token: FieldRef<"EmailVerificationToken", 'String'>
    readonly expiresAt: FieldRef<"EmailVerificationToken", 'DateTime'>
    readonly createdAt: FieldRef<"EmailVerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailVerificationToken findUnique
   */
  export type EmailVerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
    /**
     * Filter, which EmailVerificationToken to fetch.
     */
    where: EmailVerificationTokenWhereUniqueInput
  }

  /**
   * EmailVerificationToken findUniqueOrThrow
   */
  export type EmailVerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
    /**
     * Filter, which EmailVerificationToken to fetch.
     */
    where: EmailVerificationTokenWhereUniqueInput
  }

  /**
   * EmailVerificationToken findFirst
   */
  export type EmailVerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
    /**
     * Filter, which EmailVerificationToken to fetch.
     */
    where?: EmailVerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailVerificationTokens to fetch.
     */
    orderBy?: EmailVerificationTokenOrderByWithRelationInput | EmailVerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailVerificationTokens.
     */
    cursor?: EmailVerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailVerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailVerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailVerificationTokens.
     */
    distinct?: EmailVerificationTokenScalarFieldEnum | EmailVerificationTokenScalarFieldEnum[]
  }

  /**
   * EmailVerificationToken findFirstOrThrow
   */
  export type EmailVerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
    /**
     * Filter, which EmailVerificationToken to fetch.
     */
    where?: EmailVerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailVerificationTokens to fetch.
     */
    orderBy?: EmailVerificationTokenOrderByWithRelationInput | EmailVerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailVerificationTokens.
     */
    cursor?: EmailVerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailVerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailVerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailVerificationTokens.
     */
    distinct?: EmailVerificationTokenScalarFieldEnum | EmailVerificationTokenScalarFieldEnum[]
  }

  /**
   * EmailVerificationToken findMany
   */
  export type EmailVerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
    /**
     * Filter, which EmailVerificationTokens to fetch.
     */
    where?: EmailVerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailVerificationTokens to fetch.
     */
    orderBy?: EmailVerificationTokenOrderByWithRelationInput | EmailVerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailVerificationTokens.
     */
    cursor?: EmailVerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailVerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailVerificationTokens.
     */
    skip?: number
    distinct?: EmailVerificationTokenScalarFieldEnum | EmailVerificationTokenScalarFieldEnum[]
  }

  /**
   * EmailVerificationToken create
   */
  export type EmailVerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailVerificationToken.
     */
    data: XOR<EmailVerificationTokenCreateInput, EmailVerificationTokenUncheckedCreateInput>
  }

  /**
   * EmailVerificationToken createMany
   */
  export type EmailVerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailVerificationTokens.
     */
    data: EmailVerificationTokenCreateManyInput | EmailVerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailVerificationToken createManyAndReturn
   */
  export type EmailVerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many EmailVerificationTokens.
     */
    data: EmailVerificationTokenCreateManyInput | EmailVerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailVerificationToken update
   */
  export type EmailVerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailVerificationToken.
     */
    data: XOR<EmailVerificationTokenUpdateInput, EmailVerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which EmailVerificationToken to update.
     */
    where: EmailVerificationTokenWhereUniqueInput
  }

  /**
   * EmailVerificationToken updateMany
   */
  export type EmailVerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailVerificationTokens.
     */
    data: XOR<EmailVerificationTokenUpdateManyMutationInput, EmailVerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which EmailVerificationTokens to update
     */
    where?: EmailVerificationTokenWhereInput
    /**
     * Limit how many EmailVerificationTokens to update.
     */
    limit?: number
  }

  /**
   * EmailVerificationToken updateManyAndReturn
   */
  export type EmailVerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update EmailVerificationTokens.
     */
    data: XOR<EmailVerificationTokenUpdateManyMutationInput, EmailVerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which EmailVerificationTokens to update
     */
    where?: EmailVerificationTokenWhereInput
    /**
     * Limit how many EmailVerificationTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailVerificationToken upsert
   */
  export type EmailVerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailVerificationToken to update in case it exists.
     */
    where: EmailVerificationTokenWhereUniqueInput
    /**
     * In case the EmailVerificationToken found by the `where` argument doesn't exist, create a new EmailVerificationToken with this data.
     */
    create: XOR<EmailVerificationTokenCreateInput, EmailVerificationTokenUncheckedCreateInput>
    /**
     * In case the EmailVerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailVerificationTokenUpdateInput, EmailVerificationTokenUncheckedUpdateInput>
  }

  /**
   * EmailVerificationToken delete
   */
  export type EmailVerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
    /**
     * Filter which EmailVerificationToken to delete.
     */
    where: EmailVerificationTokenWhereUniqueInput
  }

  /**
   * EmailVerificationToken deleteMany
   */
  export type EmailVerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailVerificationTokens to delete
     */
    where?: EmailVerificationTokenWhereInput
    /**
     * Limit how many EmailVerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * EmailVerificationToken without action
   */
  export type EmailVerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
  }


  /**
   * Model PhoneVerificationOtp
   */

  export type AggregatePhoneVerificationOtp = {
    _count: PhoneVerificationOtpCountAggregateOutputType | null
    _avg: PhoneVerificationOtpAvgAggregateOutputType | null
    _sum: PhoneVerificationOtpSumAggregateOutputType | null
    _min: PhoneVerificationOtpMinAggregateOutputType | null
    _max: PhoneVerificationOtpMaxAggregateOutputType | null
  }

  export type PhoneVerificationOtpAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type PhoneVerificationOtpSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type PhoneVerificationOtpMinAggregateOutputType = {
    id: number | null
    userId: number | null
    phoneNumber: string | null
    otp: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type PhoneVerificationOtpMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    phoneNumber: string | null
    otp: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type PhoneVerificationOtpCountAggregateOutputType = {
    id: number
    userId: number
    phoneNumber: number
    otp: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type PhoneVerificationOtpAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PhoneVerificationOtpSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PhoneVerificationOtpMinAggregateInputType = {
    id?: true
    userId?: true
    phoneNumber?: true
    otp?: true
    expiresAt?: true
    createdAt?: true
  }

  export type PhoneVerificationOtpMaxAggregateInputType = {
    id?: true
    userId?: true
    phoneNumber?: true
    otp?: true
    expiresAt?: true
    createdAt?: true
  }

  export type PhoneVerificationOtpCountAggregateInputType = {
    id?: true
    userId?: true
    phoneNumber?: true
    otp?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type PhoneVerificationOtpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PhoneVerificationOtp to aggregate.
     */
    where?: PhoneVerificationOtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhoneVerificationOtps to fetch.
     */
    orderBy?: PhoneVerificationOtpOrderByWithRelationInput | PhoneVerificationOtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PhoneVerificationOtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhoneVerificationOtps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhoneVerificationOtps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PhoneVerificationOtps
    **/
    _count?: true | PhoneVerificationOtpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PhoneVerificationOtpAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PhoneVerificationOtpSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhoneVerificationOtpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhoneVerificationOtpMaxAggregateInputType
  }

  export type GetPhoneVerificationOtpAggregateType<T extends PhoneVerificationOtpAggregateArgs> = {
        [P in keyof T & keyof AggregatePhoneVerificationOtp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhoneVerificationOtp[P]>
      : GetScalarType<T[P], AggregatePhoneVerificationOtp[P]>
  }




  export type PhoneVerificationOtpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhoneVerificationOtpWhereInput
    orderBy?: PhoneVerificationOtpOrderByWithAggregationInput | PhoneVerificationOtpOrderByWithAggregationInput[]
    by: PhoneVerificationOtpScalarFieldEnum[] | PhoneVerificationOtpScalarFieldEnum
    having?: PhoneVerificationOtpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhoneVerificationOtpCountAggregateInputType | true
    _avg?: PhoneVerificationOtpAvgAggregateInputType
    _sum?: PhoneVerificationOtpSumAggregateInputType
    _min?: PhoneVerificationOtpMinAggregateInputType
    _max?: PhoneVerificationOtpMaxAggregateInputType
  }

  export type PhoneVerificationOtpGroupByOutputType = {
    id: number
    userId: number
    phoneNumber: string
    otp: string
    expiresAt: Date
    createdAt: Date
    _count: PhoneVerificationOtpCountAggregateOutputType | null
    _avg: PhoneVerificationOtpAvgAggregateOutputType | null
    _sum: PhoneVerificationOtpSumAggregateOutputType | null
    _min: PhoneVerificationOtpMinAggregateOutputType | null
    _max: PhoneVerificationOtpMaxAggregateOutputType | null
  }

  type GetPhoneVerificationOtpGroupByPayload<T extends PhoneVerificationOtpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PhoneVerificationOtpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhoneVerificationOtpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhoneVerificationOtpGroupByOutputType[P]>
            : GetScalarType<T[P], PhoneVerificationOtpGroupByOutputType[P]>
        }
      >
    >


  export type PhoneVerificationOtpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    phoneNumber?: boolean
    otp?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["phoneVerificationOtp"]>

  export type PhoneVerificationOtpSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    phoneNumber?: boolean
    otp?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["phoneVerificationOtp"]>

  export type PhoneVerificationOtpSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    phoneNumber?: boolean
    otp?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["phoneVerificationOtp"]>

  export type PhoneVerificationOtpSelectScalar = {
    id?: boolean
    userId?: boolean
    phoneNumber?: boolean
    otp?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type PhoneVerificationOtpOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "phoneNumber" | "otp" | "expiresAt" | "createdAt", ExtArgs["result"]["phoneVerificationOtp"]>
  export type PhoneVerificationOtpInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PhoneVerificationOtpIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PhoneVerificationOtpIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PhoneVerificationOtpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PhoneVerificationOtp"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      phoneNumber: string
      otp: string
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["phoneVerificationOtp"]>
    composites: {}
  }

  type PhoneVerificationOtpGetPayload<S extends boolean | null | undefined | PhoneVerificationOtpDefaultArgs> = $Result.GetResult<Prisma.$PhoneVerificationOtpPayload, S>

  type PhoneVerificationOtpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PhoneVerificationOtpFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PhoneVerificationOtpCountAggregateInputType | true
    }

  export interface PhoneVerificationOtpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PhoneVerificationOtp'], meta: { name: 'PhoneVerificationOtp' } }
    /**
     * Find zero or one PhoneVerificationOtp that matches the filter.
     * @param {PhoneVerificationOtpFindUniqueArgs} args - Arguments to find a PhoneVerificationOtp
     * @example
     * // Get one PhoneVerificationOtp
     * const phoneVerificationOtp = await prisma.phoneVerificationOtp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PhoneVerificationOtpFindUniqueArgs>(args: SelectSubset<T, PhoneVerificationOtpFindUniqueArgs<ExtArgs>>): Prisma__PhoneVerificationOtpClient<$Result.GetResult<Prisma.$PhoneVerificationOtpPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PhoneVerificationOtp that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PhoneVerificationOtpFindUniqueOrThrowArgs} args - Arguments to find a PhoneVerificationOtp
     * @example
     * // Get one PhoneVerificationOtp
     * const phoneVerificationOtp = await prisma.phoneVerificationOtp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PhoneVerificationOtpFindUniqueOrThrowArgs>(args: SelectSubset<T, PhoneVerificationOtpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PhoneVerificationOtpClient<$Result.GetResult<Prisma.$PhoneVerificationOtpPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PhoneVerificationOtp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneVerificationOtpFindFirstArgs} args - Arguments to find a PhoneVerificationOtp
     * @example
     * // Get one PhoneVerificationOtp
     * const phoneVerificationOtp = await prisma.phoneVerificationOtp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PhoneVerificationOtpFindFirstArgs>(args?: SelectSubset<T, PhoneVerificationOtpFindFirstArgs<ExtArgs>>): Prisma__PhoneVerificationOtpClient<$Result.GetResult<Prisma.$PhoneVerificationOtpPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PhoneVerificationOtp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneVerificationOtpFindFirstOrThrowArgs} args - Arguments to find a PhoneVerificationOtp
     * @example
     * // Get one PhoneVerificationOtp
     * const phoneVerificationOtp = await prisma.phoneVerificationOtp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PhoneVerificationOtpFindFirstOrThrowArgs>(args?: SelectSubset<T, PhoneVerificationOtpFindFirstOrThrowArgs<ExtArgs>>): Prisma__PhoneVerificationOtpClient<$Result.GetResult<Prisma.$PhoneVerificationOtpPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PhoneVerificationOtps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneVerificationOtpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PhoneVerificationOtps
     * const phoneVerificationOtps = await prisma.phoneVerificationOtp.findMany()
     * 
     * // Get first 10 PhoneVerificationOtps
     * const phoneVerificationOtps = await prisma.phoneVerificationOtp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const phoneVerificationOtpWithIdOnly = await prisma.phoneVerificationOtp.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PhoneVerificationOtpFindManyArgs>(args?: SelectSubset<T, PhoneVerificationOtpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhoneVerificationOtpPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PhoneVerificationOtp.
     * @param {PhoneVerificationOtpCreateArgs} args - Arguments to create a PhoneVerificationOtp.
     * @example
     * // Create one PhoneVerificationOtp
     * const PhoneVerificationOtp = await prisma.phoneVerificationOtp.create({
     *   data: {
     *     // ... data to create a PhoneVerificationOtp
     *   }
     * })
     * 
     */
    create<T extends PhoneVerificationOtpCreateArgs>(args: SelectSubset<T, PhoneVerificationOtpCreateArgs<ExtArgs>>): Prisma__PhoneVerificationOtpClient<$Result.GetResult<Prisma.$PhoneVerificationOtpPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PhoneVerificationOtps.
     * @param {PhoneVerificationOtpCreateManyArgs} args - Arguments to create many PhoneVerificationOtps.
     * @example
     * // Create many PhoneVerificationOtps
     * const phoneVerificationOtp = await prisma.phoneVerificationOtp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PhoneVerificationOtpCreateManyArgs>(args?: SelectSubset<T, PhoneVerificationOtpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PhoneVerificationOtps and returns the data saved in the database.
     * @param {PhoneVerificationOtpCreateManyAndReturnArgs} args - Arguments to create many PhoneVerificationOtps.
     * @example
     * // Create many PhoneVerificationOtps
     * const phoneVerificationOtp = await prisma.phoneVerificationOtp.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PhoneVerificationOtps and only return the `id`
     * const phoneVerificationOtpWithIdOnly = await prisma.phoneVerificationOtp.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PhoneVerificationOtpCreateManyAndReturnArgs>(args?: SelectSubset<T, PhoneVerificationOtpCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhoneVerificationOtpPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PhoneVerificationOtp.
     * @param {PhoneVerificationOtpDeleteArgs} args - Arguments to delete one PhoneVerificationOtp.
     * @example
     * // Delete one PhoneVerificationOtp
     * const PhoneVerificationOtp = await prisma.phoneVerificationOtp.delete({
     *   where: {
     *     // ... filter to delete one PhoneVerificationOtp
     *   }
     * })
     * 
     */
    delete<T extends PhoneVerificationOtpDeleteArgs>(args: SelectSubset<T, PhoneVerificationOtpDeleteArgs<ExtArgs>>): Prisma__PhoneVerificationOtpClient<$Result.GetResult<Prisma.$PhoneVerificationOtpPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PhoneVerificationOtp.
     * @param {PhoneVerificationOtpUpdateArgs} args - Arguments to update one PhoneVerificationOtp.
     * @example
     * // Update one PhoneVerificationOtp
     * const phoneVerificationOtp = await prisma.phoneVerificationOtp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PhoneVerificationOtpUpdateArgs>(args: SelectSubset<T, PhoneVerificationOtpUpdateArgs<ExtArgs>>): Prisma__PhoneVerificationOtpClient<$Result.GetResult<Prisma.$PhoneVerificationOtpPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PhoneVerificationOtps.
     * @param {PhoneVerificationOtpDeleteManyArgs} args - Arguments to filter PhoneVerificationOtps to delete.
     * @example
     * // Delete a few PhoneVerificationOtps
     * const { count } = await prisma.phoneVerificationOtp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PhoneVerificationOtpDeleteManyArgs>(args?: SelectSubset<T, PhoneVerificationOtpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PhoneVerificationOtps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneVerificationOtpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PhoneVerificationOtps
     * const phoneVerificationOtp = await prisma.phoneVerificationOtp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PhoneVerificationOtpUpdateManyArgs>(args: SelectSubset<T, PhoneVerificationOtpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PhoneVerificationOtps and returns the data updated in the database.
     * @param {PhoneVerificationOtpUpdateManyAndReturnArgs} args - Arguments to update many PhoneVerificationOtps.
     * @example
     * // Update many PhoneVerificationOtps
     * const phoneVerificationOtp = await prisma.phoneVerificationOtp.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PhoneVerificationOtps and only return the `id`
     * const phoneVerificationOtpWithIdOnly = await prisma.phoneVerificationOtp.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PhoneVerificationOtpUpdateManyAndReturnArgs>(args: SelectSubset<T, PhoneVerificationOtpUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhoneVerificationOtpPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PhoneVerificationOtp.
     * @param {PhoneVerificationOtpUpsertArgs} args - Arguments to update or create a PhoneVerificationOtp.
     * @example
     * // Update or create a PhoneVerificationOtp
     * const phoneVerificationOtp = await prisma.phoneVerificationOtp.upsert({
     *   create: {
     *     // ... data to create a PhoneVerificationOtp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PhoneVerificationOtp we want to update
     *   }
     * })
     */
    upsert<T extends PhoneVerificationOtpUpsertArgs>(args: SelectSubset<T, PhoneVerificationOtpUpsertArgs<ExtArgs>>): Prisma__PhoneVerificationOtpClient<$Result.GetResult<Prisma.$PhoneVerificationOtpPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PhoneVerificationOtps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneVerificationOtpCountArgs} args - Arguments to filter PhoneVerificationOtps to count.
     * @example
     * // Count the number of PhoneVerificationOtps
     * const count = await prisma.phoneVerificationOtp.count({
     *   where: {
     *     // ... the filter for the PhoneVerificationOtps we want to count
     *   }
     * })
    **/
    count<T extends PhoneVerificationOtpCountArgs>(
      args?: Subset<T, PhoneVerificationOtpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhoneVerificationOtpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PhoneVerificationOtp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneVerificationOtpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhoneVerificationOtpAggregateArgs>(args: Subset<T, PhoneVerificationOtpAggregateArgs>): Prisma.PrismaPromise<GetPhoneVerificationOtpAggregateType<T>>

    /**
     * Group by PhoneVerificationOtp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneVerificationOtpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhoneVerificationOtpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhoneVerificationOtpGroupByArgs['orderBy'] }
        : { orderBy?: PhoneVerificationOtpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhoneVerificationOtpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhoneVerificationOtpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PhoneVerificationOtp model
   */
  readonly fields: PhoneVerificationOtpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PhoneVerificationOtp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PhoneVerificationOtpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PhoneVerificationOtp model
   */
  interface PhoneVerificationOtpFieldRefs {
    readonly id: FieldRef<"PhoneVerificationOtp", 'Int'>
    readonly userId: FieldRef<"PhoneVerificationOtp", 'Int'>
    readonly phoneNumber: FieldRef<"PhoneVerificationOtp", 'String'>
    readonly otp: FieldRef<"PhoneVerificationOtp", 'String'>
    readonly expiresAt: FieldRef<"PhoneVerificationOtp", 'DateTime'>
    readonly createdAt: FieldRef<"PhoneVerificationOtp", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PhoneVerificationOtp findUnique
   */
  export type PhoneVerificationOtpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerificationOtp
     */
    select?: PhoneVerificationOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneVerificationOtp
     */
    omit?: PhoneVerificationOtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneVerificationOtpInclude<ExtArgs> | null
    /**
     * Filter, which PhoneVerificationOtp to fetch.
     */
    where: PhoneVerificationOtpWhereUniqueInput
  }

  /**
   * PhoneVerificationOtp findUniqueOrThrow
   */
  export type PhoneVerificationOtpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerificationOtp
     */
    select?: PhoneVerificationOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneVerificationOtp
     */
    omit?: PhoneVerificationOtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneVerificationOtpInclude<ExtArgs> | null
    /**
     * Filter, which PhoneVerificationOtp to fetch.
     */
    where: PhoneVerificationOtpWhereUniqueInput
  }

  /**
   * PhoneVerificationOtp findFirst
   */
  export type PhoneVerificationOtpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerificationOtp
     */
    select?: PhoneVerificationOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneVerificationOtp
     */
    omit?: PhoneVerificationOtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneVerificationOtpInclude<ExtArgs> | null
    /**
     * Filter, which PhoneVerificationOtp to fetch.
     */
    where?: PhoneVerificationOtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhoneVerificationOtps to fetch.
     */
    orderBy?: PhoneVerificationOtpOrderByWithRelationInput | PhoneVerificationOtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhoneVerificationOtps.
     */
    cursor?: PhoneVerificationOtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhoneVerificationOtps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhoneVerificationOtps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhoneVerificationOtps.
     */
    distinct?: PhoneVerificationOtpScalarFieldEnum | PhoneVerificationOtpScalarFieldEnum[]
  }

  /**
   * PhoneVerificationOtp findFirstOrThrow
   */
  export type PhoneVerificationOtpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerificationOtp
     */
    select?: PhoneVerificationOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneVerificationOtp
     */
    omit?: PhoneVerificationOtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneVerificationOtpInclude<ExtArgs> | null
    /**
     * Filter, which PhoneVerificationOtp to fetch.
     */
    where?: PhoneVerificationOtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhoneVerificationOtps to fetch.
     */
    orderBy?: PhoneVerificationOtpOrderByWithRelationInput | PhoneVerificationOtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhoneVerificationOtps.
     */
    cursor?: PhoneVerificationOtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhoneVerificationOtps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhoneVerificationOtps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhoneVerificationOtps.
     */
    distinct?: PhoneVerificationOtpScalarFieldEnum | PhoneVerificationOtpScalarFieldEnum[]
  }

  /**
   * PhoneVerificationOtp findMany
   */
  export type PhoneVerificationOtpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerificationOtp
     */
    select?: PhoneVerificationOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneVerificationOtp
     */
    omit?: PhoneVerificationOtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneVerificationOtpInclude<ExtArgs> | null
    /**
     * Filter, which PhoneVerificationOtps to fetch.
     */
    where?: PhoneVerificationOtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhoneVerificationOtps to fetch.
     */
    orderBy?: PhoneVerificationOtpOrderByWithRelationInput | PhoneVerificationOtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PhoneVerificationOtps.
     */
    cursor?: PhoneVerificationOtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhoneVerificationOtps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhoneVerificationOtps.
     */
    skip?: number
    distinct?: PhoneVerificationOtpScalarFieldEnum | PhoneVerificationOtpScalarFieldEnum[]
  }

  /**
   * PhoneVerificationOtp create
   */
  export type PhoneVerificationOtpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerificationOtp
     */
    select?: PhoneVerificationOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneVerificationOtp
     */
    omit?: PhoneVerificationOtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneVerificationOtpInclude<ExtArgs> | null
    /**
     * The data needed to create a PhoneVerificationOtp.
     */
    data: XOR<PhoneVerificationOtpCreateInput, PhoneVerificationOtpUncheckedCreateInput>
  }

  /**
   * PhoneVerificationOtp createMany
   */
  export type PhoneVerificationOtpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PhoneVerificationOtps.
     */
    data: PhoneVerificationOtpCreateManyInput | PhoneVerificationOtpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PhoneVerificationOtp createManyAndReturn
   */
  export type PhoneVerificationOtpCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerificationOtp
     */
    select?: PhoneVerificationOtpSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneVerificationOtp
     */
    omit?: PhoneVerificationOtpOmit<ExtArgs> | null
    /**
     * The data used to create many PhoneVerificationOtps.
     */
    data: PhoneVerificationOtpCreateManyInput | PhoneVerificationOtpCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneVerificationOtpIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PhoneVerificationOtp update
   */
  export type PhoneVerificationOtpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerificationOtp
     */
    select?: PhoneVerificationOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneVerificationOtp
     */
    omit?: PhoneVerificationOtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneVerificationOtpInclude<ExtArgs> | null
    /**
     * The data needed to update a PhoneVerificationOtp.
     */
    data: XOR<PhoneVerificationOtpUpdateInput, PhoneVerificationOtpUncheckedUpdateInput>
    /**
     * Choose, which PhoneVerificationOtp to update.
     */
    where: PhoneVerificationOtpWhereUniqueInput
  }

  /**
   * PhoneVerificationOtp updateMany
   */
  export type PhoneVerificationOtpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PhoneVerificationOtps.
     */
    data: XOR<PhoneVerificationOtpUpdateManyMutationInput, PhoneVerificationOtpUncheckedUpdateManyInput>
    /**
     * Filter which PhoneVerificationOtps to update
     */
    where?: PhoneVerificationOtpWhereInput
    /**
     * Limit how many PhoneVerificationOtps to update.
     */
    limit?: number
  }

  /**
   * PhoneVerificationOtp updateManyAndReturn
   */
  export type PhoneVerificationOtpUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerificationOtp
     */
    select?: PhoneVerificationOtpSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneVerificationOtp
     */
    omit?: PhoneVerificationOtpOmit<ExtArgs> | null
    /**
     * The data used to update PhoneVerificationOtps.
     */
    data: XOR<PhoneVerificationOtpUpdateManyMutationInput, PhoneVerificationOtpUncheckedUpdateManyInput>
    /**
     * Filter which PhoneVerificationOtps to update
     */
    where?: PhoneVerificationOtpWhereInput
    /**
     * Limit how many PhoneVerificationOtps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneVerificationOtpIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PhoneVerificationOtp upsert
   */
  export type PhoneVerificationOtpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerificationOtp
     */
    select?: PhoneVerificationOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneVerificationOtp
     */
    omit?: PhoneVerificationOtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneVerificationOtpInclude<ExtArgs> | null
    /**
     * The filter to search for the PhoneVerificationOtp to update in case it exists.
     */
    where: PhoneVerificationOtpWhereUniqueInput
    /**
     * In case the PhoneVerificationOtp found by the `where` argument doesn't exist, create a new PhoneVerificationOtp with this data.
     */
    create: XOR<PhoneVerificationOtpCreateInput, PhoneVerificationOtpUncheckedCreateInput>
    /**
     * In case the PhoneVerificationOtp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PhoneVerificationOtpUpdateInput, PhoneVerificationOtpUncheckedUpdateInput>
  }

  /**
   * PhoneVerificationOtp delete
   */
  export type PhoneVerificationOtpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerificationOtp
     */
    select?: PhoneVerificationOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneVerificationOtp
     */
    omit?: PhoneVerificationOtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneVerificationOtpInclude<ExtArgs> | null
    /**
     * Filter which PhoneVerificationOtp to delete.
     */
    where: PhoneVerificationOtpWhereUniqueInput
  }

  /**
   * PhoneVerificationOtp deleteMany
   */
  export type PhoneVerificationOtpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PhoneVerificationOtps to delete
     */
    where?: PhoneVerificationOtpWhereInput
    /**
     * Limit how many PhoneVerificationOtps to delete.
     */
    limit?: number
  }

  /**
   * PhoneVerificationOtp without action
   */
  export type PhoneVerificationOtpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerificationOtp
     */
    select?: PhoneVerificationOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneVerificationOtp
     */
    omit?: PhoneVerificationOtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneVerificationOtpInclude<ExtArgs> | null
  }


  /**
   * Model PasswordResetToken
   */

  export type AggregatePasswordResetToken = {
    _count: PasswordResetTokenCountAggregateOutputType | null
    _avg: PasswordResetTokenAvgAggregateOutputType | null
    _sum: PasswordResetTokenSumAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  export type PasswordResetTokenAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type PasswordResetTokenSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type PasswordResetTokenMinAggregateOutputType = {
    id: number | null
    userId: number | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type PasswordResetTokenMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type PasswordResetTokenCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type PasswordResetTokenAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PasswordResetTokenSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PasswordResetTokenMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
  }

  export type PasswordResetTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
  }

  export type PasswordResetTokenCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type PasswordResetTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetToken to aggregate.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResetTokens
    **/
    _count?: true | PasswordResetTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PasswordResetTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PasswordResetTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type GetPasswordResetTokenAggregateType<T extends PasswordResetTokenAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordResetToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordResetToken[P]>
      : GetScalarType<T[P], AggregatePasswordResetToken[P]>
  }




  export type PasswordResetTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithAggregationInput | PasswordResetTokenOrderByWithAggregationInput[]
    by: PasswordResetTokenScalarFieldEnum[] | PasswordResetTokenScalarFieldEnum
    having?: PasswordResetTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetTokenCountAggregateInputType | true
    _avg?: PasswordResetTokenAvgAggregateInputType
    _sum?: PasswordResetTokenSumAggregateInputType
    _min?: PasswordResetTokenMinAggregateInputType
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type PasswordResetTokenGroupByOutputType = {
    id: number
    userId: number
    token: string
    expiresAt: Date
    createdAt: Date
    _count: PasswordResetTokenCountAggregateOutputType | null
    _avg: PasswordResetTokenAvgAggregateOutputType | null
    _sum: PasswordResetTokenSumAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  type GetPasswordResetTokenGroupByPayload<T extends PasswordResetTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type PasswordResetTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "expiresAt" | "createdAt", ExtArgs["result"]["passwordResetToken"]>
  export type PasswordResetTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PasswordResetTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordResetToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      token: string
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["passwordResetToken"]>
    composites: {}
  }

  type PasswordResetTokenGetPayload<S extends boolean | null | undefined | PasswordResetTokenDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetTokenPayload, S>

  type PasswordResetTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordResetTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordResetTokenCountAggregateInputType | true
    }

  export interface PasswordResetTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordResetToken'], meta: { name: 'PasswordResetToken' } }
    /**
     * Find zero or one PasswordResetToken that matches the filter.
     * @param {PasswordResetTokenFindUniqueArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetTokenFindUniqueArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordResetToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordResetTokenFindUniqueOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetTokenFindFirstArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordResetTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany()
     * 
     * // Get first 10 PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordResetTokenFindManyArgs>(args?: SelectSubset<T, PasswordResetTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordResetToken.
     * @param {PasswordResetTokenCreateArgs} args - Arguments to create a PasswordResetToken.
     * @example
     * // Create one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.create({
     *   data: {
     *     // ... data to create a PasswordResetToken
     *   }
     * })
     * 
     */
    create<T extends PasswordResetTokenCreateArgs>(args: SelectSubset<T, PasswordResetTokenCreateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordResetTokens.
     * @param {PasswordResetTokenCreateManyArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordResetTokenCreateManyArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordResetTokens and returns the data saved in the database.
     * @param {PasswordResetTokenCreateManyAndReturnArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordResetTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordResetToken.
     * @param {PasswordResetTokenDeleteArgs} args - Arguments to delete one PasswordResetToken.
     * @example
     * // Delete one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.delete({
     *   where: {
     *     // ... filter to delete one PasswordResetToken
     *   }
     * })
     * 
     */
    delete<T extends PasswordResetTokenDeleteArgs>(args: SelectSubset<T, PasswordResetTokenDeleteArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordResetToken.
     * @param {PasswordResetTokenUpdateArgs} args - Arguments to update one PasswordResetToken.
     * @example
     * // Update one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordResetTokenUpdateArgs>(args: SelectSubset<T, PasswordResetTokenUpdateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordResetTokens.
     * @param {PasswordResetTokenDeleteManyArgs} args - Arguments to filter PasswordResetTokens to delete.
     * @example
     * // Delete a few PasswordResetTokens
     * const { count } = await prisma.passwordResetToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordResetTokenDeleteManyArgs>(args?: SelectSubset<T, PasswordResetTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordResetTokenUpdateManyArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens and returns the data updated in the database.
     * @param {PasswordResetTokenUpdateManyAndReturnArgs} args - Arguments to update many PasswordResetTokens.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordResetTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordResetToken.
     * @param {PasswordResetTokenUpsertArgs} args - Arguments to update or create a PasswordResetToken.
     * @example
     * // Update or create a PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.upsert({
     *   create: {
     *     // ... data to create a PasswordResetToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordResetToken we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetTokenUpsertArgs>(args: SelectSubset<T, PasswordResetTokenUpsertArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenCountArgs} args - Arguments to filter PasswordResetTokens to count.
     * @example
     * // Count the number of PasswordResetTokens
     * const count = await prisma.passwordResetToken.count({
     *   where: {
     *     // ... the filter for the PasswordResetTokens we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetTokenCountArgs>(
      args?: Subset<T, PasswordResetTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetTokenAggregateArgs>(args: Subset<T, PasswordResetTokenAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetTokenAggregateType<T>>

    /**
     * Group by PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetTokenGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordResetToken model
   */
  readonly fields: PasswordResetTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordResetToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordResetToken model
   */
  interface PasswordResetTokenFieldRefs {
    readonly id: FieldRef<"PasswordResetToken", 'Int'>
    readonly userId: FieldRef<"PasswordResetToken", 'Int'>
    readonly token: FieldRef<"PasswordResetToken", 'String'>
    readonly expiresAt: FieldRef<"PasswordResetToken", 'DateTime'>
    readonly createdAt: FieldRef<"PasswordResetToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordResetToken findUnique
   */
  export type PasswordResetTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findUniqueOrThrow
   */
  export type PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findFirst
   */
  export type PasswordResetTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findFirstOrThrow
   */
  export type PasswordResetTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findMany
   */
  export type PasswordResetTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetTokens to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken create
   */
  export type PasswordResetTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
  }

  /**
   * PasswordResetToken createMany
   */
  export type PasswordResetTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordResetToken createManyAndReturn
   */
  export type PasswordResetTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordResetToken update
   */
  export type PasswordResetTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
    /**
     * Choose, which PasswordResetToken to update.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken updateMany
   */
  export type PasswordResetTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to update.
     */
    limit?: number
  }

  /**
   * PasswordResetToken updateManyAndReturn
   */
  export type PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordResetToken upsert
   */
  export type PasswordResetTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordResetToken to update in case it exists.
     */
    where: PasswordResetTokenWhereUniqueInput
    /**
     * In case the PasswordResetToken found by the `where` argument doesn't exist, create a new PasswordResetToken with this data.
     */
    create: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
    /**
     * In case the PasswordResetToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
  }

  /**
   * PasswordResetToken delete
   */
  export type PasswordResetTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter which PasswordResetToken to delete.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken deleteMany
   */
  export type PasswordResetTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetTokens to delete
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to delete.
     */
    limit?: number
  }

  /**
   * PasswordResetToken without action
   */
  export type PasswordResetTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    passwordHash: 'passwordHash',
    phoneNumber: 'phoneNumber',
    accountType: 'accountType',
    emailVerified: 'emailVerified',
    phoneVerified: 'phoneVerified',
    accountStatus: 'accountStatus',
    googleId: 'googleId',
    lastLogin: 'lastLogin',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    deviceInfo: 'deviceInfo',
    ipAddress: 'ipAddress',
    lastActivity: 'lastActivity',
    expiryTime: 'expiryTime',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserSessionScalarFieldEnum = (typeof UserSessionScalarFieldEnum)[keyof typeof UserSessionScalarFieldEnum]


  export const UserProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    firstName: 'firstName',
    lastName: 'lastName',
    profilePhoto: 'profilePhoto',
    gender: 'gender',
    dateOfBirth: 'dateOfBirth',
    address: 'address',
    city: 'city',
    state: 'state',
    postalCode: 'postalCode',
    country: 'country',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserProfileScalarFieldEnum = (typeof UserProfileScalarFieldEnum)[keyof typeof UserProfileScalarFieldEnum]


  export const VehicleScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    licensePlate: 'licensePlate',
    vehicleType: 'vehicleType',
    brand: 'brand',
    model: 'model',
    color: 'color',
    rfidTag: 'rfidTag',
    length: 'length',
    width: 'width',
    height: 'height',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VehicleScalarFieldEnum = (typeof VehicleScalarFieldEnum)[keyof typeof VehicleScalarFieldEnum]


  export const PlaceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    image: 'image',
    placeType: 'placeType',
    address: 'address',
    latitude: 'latitude',
    longitude: 'longitude',
    contactNumber: 'contactNumber',
    email: 'email',
    description: 'description',
    totalCapacity: 'totalCapacity',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlaceScalarFieldEnum = (typeof PlaceScalarFieldEnum)[keyof typeof PlaceScalarFieldEnum]


  export const ParkingZoneScalarFieldEnum: {
    id: 'id',
    placeId: 'placeId',
    zoneName: 'zoneName',
    floorLevel: 'floorLevel',
    zoneType: 'zoneType',
    totalSlots: 'totalSlots',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ParkingZoneScalarFieldEnum = (typeof ParkingZoneScalarFieldEnum)[keyof typeof ParkingZoneScalarFieldEnum]


  export const ParkingSlotScalarFieldEnum: {
    id: 'id',
    zoneId: 'zoneId',
    slotNumber: 'slotNumber',
    slotType: 'slotType',
    isReserved: 'isReserved',
    isOccupied: 'isOccupied',
    isDisabledFriendly: 'isDisabledFriendly',
    hasEvCharger: 'hasEvCharger',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ParkingSlotScalarFieldEnum = (typeof ParkingSlotScalarFieldEnum)[keyof typeof ParkingSlotScalarFieldEnum]


  export const SlotAvailabilityScalarFieldEnum: {
    id: 'id',
    slotId: 'slotId',
    availableFrom: 'availableFrom',
    availableUntil: 'availableUntil',
    isBookable: 'isBookable',
    statusReason: 'statusReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SlotAvailabilityScalarFieldEnum = (typeof SlotAvailabilityScalarFieldEnum)[keyof typeof SlotAvailabilityScalarFieldEnum]


  export const TariffPlanScalarFieldEnum: {
    id: 'id',
    placeId: 'placeId',
    planName: 'planName',
    description: 'description',
    effectiveFrom: 'effectiveFrom',
    effectiveUntil: 'effectiveUntil',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TariffPlanScalarFieldEnum = (typeof TariffPlanScalarFieldEnum)[keyof typeof TariffPlanScalarFieldEnum]


  export const TariffRateScalarFieldEnum: {
    id: 'id',
    planId: 'planId',
    vehicleType: 'vehicleType',
    slotType: 'slotType',
    startTime: 'startTime',
    endTime: 'endTime',
    dayCategory: 'dayCategory',
    basePrice: 'basePrice',
    hourlyRate: 'hourlyRate',
    dayRate: 'dayRate',
    minimumCharge: 'minimumCharge',
    gracePeriodMinutes: 'gracePeriodMinutes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TariffRateScalarFieldEnum = (typeof TariffRateScalarFieldEnum)[keyof typeof TariffRateScalarFieldEnum]


  export const BookingScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    vehicleId: 'vehicleId',
    slotId: 'slotId',
    promoCodeId: 'promoCodeId',
    bookingReference: 'bookingReference',
    bookingTime: 'bookingTime',
    scheduledEntry: 'scheduledEntry',
    scheduledExit: 'scheduledExit',
    actualEntry: 'actualEntry',
    actualExit: 'actualExit',
    qrCode: 'qrCode',
    bookingStatus: 'bookingStatus',
    estimatedPrice: 'estimatedPrice',
    finalPrice: 'finalPrice',
    cancellationReason: 'cancellationReason',
    cancellationTimeMinutes: 'cancellationTimeMinutes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BookingScalarFieldEnum = (typeof BookingScalarFieldEnum)[keyof typeof BookingScalarFieldEnum]


  export const BookingStatusLogScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    previousStatus: 'previousStatus',
    newStatus: 'newStatus',
    changedBy: 'changedBy',
    reason: 'reason',
    statusTime: 'statusTime',
    createdAt: 'createdAt'
  };

  export type BookingStatusLogScalarFieldEnum = (typeof BookingStatusLogScalarFieldEnum)[keyof typeof BookingStatusLogScalarFieldEnum]


  export const BookingPaymentScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    paymentReference: 'paymentReference',
    paymentStatus: 'paymentStatus',
    originalAmount: 'originalAmount',
    discountAmount: 'discountAmount',
    taxAmount: 'taxAmount',
    surchargeAmount: 'surchargeAmount',
    finalAmount: 'finalAmount',
    isPrepaid: 'isPrepaid',
    isRefunded: 'isRefunded',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BookingPaymentScalarFieldEnum = (typeof BookingPaymentScalarFieldEnum)[keyof typeof BookingPaymentScalarFieldEnum]


  export const PaymentTransactionScalarFieldEnum: {
    id: 'id',
    paymentId: 'paymentId',
    paymentMethodId: 'paymentMethodId',
    transactionReference: 'transactionReference',
    transactionType: 'transactionType',
    amount: 'amount',
    currency: 'currency',
    transactionStatus: 'transactionStatus',
    gatewayResponse: 'gatewayResponse',
    transactionData: 'transactionData',
    transactionTime: 'transactionTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentTransactionScalarFieldEnum = (typeof PaymentTransactionScalarFieldEnum)[keyof typeof PaymentTransactionScalarFieldEnum]


  export const RefundTransactionScalarFieldEnum: {
    id: 'id',
    paymentId: 'paymentId',
    refundReference: 'refundReference',
    refundAmount: 'refundAmount',
    refundReason: 'refundReason',
    refundStatus: 'refundStatus',
    processorResponse: 'processorResponse',
    refundData: 'refundData',
    refundTime: 'refundTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RefundTransactionScalarFieldEnum = (typeof RefundTransactionScalarFieldEnum)[keyof typeof RefundTransactionScalarFieldEnum]


  export const PaymentMethodScalarFieldEnum: {
    id: 'id',
    methodName: 'methodName',
    provider: 'provider',
    methodType: 'methodType',
    description: 'description',
    processingFeePercent: 'processingFeePercent',
    fixedFee: 'fixedFee',
    supportsRefunds: 'supportsRefunds',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentMethodScalarFieldEnum = (typeof PaymentMethodScalarFieldEnum)[keyof typeof PaymentMethodScalarFieldEnum]


  export const UserPaymentMethodScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    paymentMethodId: 'paymentMethodId',
    tokenReference: 'tokenReference',
    maskedInfo: 'maskedInfo',
    expiryInfo: 'expiryInfo',
    isDefault: 'isDefault',
    isVerified: 'isVerified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserPaymentMethodScalarFieldEnum = (typeof UserPaymentMethodScalarFieldEnum)[keyof typeof UserPaymentMethodScalarFieldEnum]


  export const PromoCodeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    description: 'description',
    discountType: 'discountType',
    discountValue: 'discountValue',
    minimumSpend: 'minimumSpend',
    validFrom: 'validFrom',
    validUntil: 'validUntil',
    usageLimit: 'usageLimit',
    usageCount: 'usageCount',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PromoCodeScalarFieldEnum = (typeof PromoCodeScalarFieldEnum)[keyof typeof PromoCodeScalarFieldEnum]


  export const ParkingPassScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    placeId: 'placeId',
    passType: 'passType',
    passReference: 'passReference',
    startDate: 'startDate',
    endDate: 'endDate',
    price: 'price',
    status: 'status',
    autoRenew: 'autoRenew',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ParkingPassScalarFieldEnum = (typeof ParkingPassScalarFieldEnum)[keyof typeof ParkingPassScalarFieldEnum]


  export const ParkingPassPaymentScalarFieldEnum: {
    id: 'id',
    passId: 'passId',
    paymentMethodId: 'paymentMethodId',
    amount: 'amount',
    paymentStatus: 'paymentStatus',
    transactionReference: 'transactionReference',
    paymentDate: 'paymentDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ParkingPassPaymentScalarFieldEnum = (typeof ParkingPassPaymentScalarFieldEnum)[keyof typeof ParkingPassPaymentScalarFieldEnum]


  export const AccessLogScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    logType: 'logType',
    logTime: 'logTime',
    verificationMethod: 'verificationMethod',
    verifiedBy: 'verifiedBy',
    location: 'location',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type AccessLogScalarFieldEnum = (typeof AccessLogScalarFieldEnum)[keyof typeof AccessLogScalarFieldEnum]


  export const BookingExtensionScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    originalEndTime: 'originalEndTime',
    newEndTime: 'newEndTime',
    additionalCharge: 'additionalCharge',
    paymentStatus: 'paymentStatus',
    requestTime: 'requestTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BookingExtensionScalarFieldEnum = (typeof BookingExtensionScalarFieldEnum)[keyof typeof BookingExtensionScalarFieldEnum]


  export const NotificationSettingScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    emailEnabled: 'emailEnabled',
    smsEnabled: 'smsEnabled',
    pushEnabled: 'pushEnabled',
    bookingConfirmation: 'bookingConfirmation',
    paymentNotifications: 'paymentNotifications',
    reminderNotifications: 'reminderNotifications',
    marketingNotifications: 'marketingNotifications',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationSettingScalarFieldEnum = (typeof NotificationSettingScalarFieldEnum)[keyof typeof NotificationSettingScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    bookingId: 'bookingId',
    notificationType: 'notificationType',
    channel: 'channel',
    content: 'content',
    isRead: 'isRead',
    sentTime: 'sentTime',
    readTime: 'readTime',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const PlaceRatingScalarFieldEnum: {
    id: 'id',
    placeId: 'placeId',
    userId: 'userId',
    bookingId: 'bookingId',
    ratingScore: 'ratingScore',
    reviewComment: 'reviewComment',
    ratingDate: 'ratingDate',
    isVerified: 'isVerified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlaceRatingScalarFieldEnum = (typeof PlaceRatingScalarFieldEnum)[keyof typeof PlaceRatingScalarFieldEnum]


  export const OperatingHourScalarFieldEnum: {
    id: 'id',
    placeId: 'placeId',
    dayOfWeek: 'dayOfWeek',
    openingTime: 'openingTime',
    closingTime: 'closingTime',
    is24hours: 'is24hours',
    isClosed: 'isClosed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OperatingHourScalarFieldEnum = (typeof OperatingHourScalarFieldEnum)[keyof typeof OperatingHourScalarFieldEnum]


  export const PlaceAdminScalarFieldEnum: {
    id: 'id',
    placeId: 'placeId',
    username: 'username',
    email: 'email',
    passwordHash: 'passwordHash',
    fullName: 'fullName',
    role: 'role',
    contactNumber: 'contactNumber',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlaceAdminScalarFieldEnum = (typeof PlaceAdminScalarFieldEnum)[keyof typeof PlaceAdminScalarFieldEnum]


  export const SystemLogScalarFieldEnum: {
    id: 'id',
    entityType: 'entityType',
    entityId: 'entityId',
    action: 'action',
    performedBy: 'performedBy',
    logLevel: 'logLevel',
    logDetails: 'logDetails',
    logTime: 'logTime',
    createdAt: 'createdAt'
  };

  export type SystemLogScalarFieldEnum = (typeof SystemLogScalarFieldEnum)[keyof typeof SystemLogScalarFieldEnum]


  export const EmailVerificationTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type EmailVerificationTokenScalarFieldEnum = (typeof EmailVerificationTokenScalarFieldEnum)[keyof typeof EmailVerificationTokenScalarFieldEnum]


  export const PhoneVerificationOtpScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    phoneNumber: 'phoneNumber',
    otp: 'otp',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type PhoneVerificationOtpScalarFieldEnum = (typeof PhoneVerificationOtpScalarFieldEnum)[keyof typeof PhoneVerificationOtpScalarFieldEnum]


  export const PasswordResetTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type PasswordResetTokenScalarFieldEnum = (typeof PasswordResetTokenScalarFieldEnum)[keyof typeof PasswordResetTokenScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    phoneNumber?: StringNullableFilter<"User"> | string | null
    accountType?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    phoneVerified?: BoolFilter<"User"> | boolean
    accountStatus?: StringFilter<"User"> | string
    googleId?: StringNullableFilter<"User"> | string | null
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    profile?: XOR<UserProfileNullableScalarRelationFilter, UserProfileWhereInput> | null
    vehicles?: VehicleListRelationFilter
    bookings?: BookingListRelationFilter
    userPaymentMethods?: UserPaymentMethodListRelationFilter
    notifications?: NotificationListRelationFilter
    parkingPasses?: ParkingPassListRelationFilter
    placeRatings?: PlaceRatingListRelationFilter
    notificationSettings?: XOR<NotificationSettingNullableScalarRelationFilter, NotificationSettingWhereInput> | null
    sessions?: UserSessionListRelationFilter
    EmailVerificationToken?: EmailVerificationTokenListRelationFilter
    PhoneVerificationOtp?: PhoneVerificationOtpListRelationFilter
    PasswordResetToken?: PasswordResetTokenListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    accountType?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    accountStatus?: SortOrder
    googleId?: SortOrderInput | SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    profile?: UserProfileOrderByWithRelationInput
    vehicles?: VehicleOrderByRelationAggregateInput
    bookings?: BookingOrderByRelationAggregateInput
    userPaymentMethods?: UserPaymentMethodOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    parkingPasses?: ParkingPassOrderByRelationAggregateInput
    placeRatings?: PlaceRatingOrderByRelationAggregateInput
    notificationSettings?: NotificationSettingOrderByWithRelationInput
    sessions?: UserSessionOrderByRelationAggregateInput
    EmailVerificationToken?: EmailVerificationTokenOrderByRelationAggregateInput
    PhoneVerificationOtp?: PhoneVerificationOtpOrderByRelationAggregateInput
    PasswordResetToken?: PasswordResetTokenOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    email?: string
    phoneNumber?: string
    googleId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    accountType?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    phoneVerified?: BoolFilter<"User"> | boolean
    accountStatus?: StringFilter<"User"> | string
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    profile?: XOR<UserProfileNullableScalarRelationFilter, UserProfileWhereInput> | null
    vehicles?: VehicleListRelationFilter
    bookings?: BookingListRelationFilter
    userPaymentMethods?: UserPaymentMethodListRelationFilter
    notifications?: NotificationListRelationFilter
    parkingPasses?: ParkingPassListRelationFilter
    placeRatings?: PlaceRatingListRelationFilter
    notificationSettings?: XOR<NotificationSettingNullableScalarRelationFilter, NotificationSettingWhereInput> | null
    sessions?: UserSessionListRelationFilter
    EmailVerificationToken?: EmailVerificationTokenListRelationFilter
    PhoneVerificationOtp?: PhoneVerificationOtpListRelationFilter
    PasswordResetToken?: PasswordResetTokenListRelationFilter
  }, "id" | "username" | "email" | "phoneNumber" | "googleId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    accountType?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    accountStatus?: SortOrder
    googleId?: SortOrderInput | SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    username?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    accountType?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    phoneVerified?: BoolWithAggregatesFilter<"User"> | boolean
    accountStatus?: StringWithAggregatesFilter<"User"> | string
    googleId?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type UserSessionWhereInput = {
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    id?: IntFilter<"UserSession"> | number
    userId?: IntFilter<"UserSession"> | number
    token?: StringFilter<"UserSession"> | string
    deviceInfo?: StringNullableFilter<"UserSession"> | string | null
    ipAddress?: StringNullableFilter<"UserSession"> | string | null
    lastActivity?: DateTimeFilter<"UserSession"> | Date | string
    expiryTime?: DateTimeFilter<"UserSession"> | Date | string
    isActive?: BoolFilter<"UserSession"> | boolean
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeNullableFilter<"UserSession"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    lastActivity?: SortOrder
    expiryTime?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    token?: string
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    userId?: IntFilter<"UserSession"> | number
    deviceInfo?: StringNullableFilter<"UserSession"> | string | null
    ipAddress?: StringNullableFilter<"UserSession"> | string | null
    lastActivity?: DateTimeFilter<"UserSession"> | Date | string
    expiryTime?: DateTimeFilter<"UserSession"> | Date | string
    isActive?: BoolFilter<"UserSession"> | boolean
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeNullableFilter<"UserSession"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type UserSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    lastActivity?: SortOrder
    expiryTime?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: UserSessionCountOrderByAggregateInput
    _avg?: UserSessionAvgOrderByAggregateInput
    _max?: UserSessionMaxOrderByAggregateInput
    _min?: UserSessionMinOrderByAggregateInput
    _sum?: UserSessionSumOrderByAggregateInput
  }

  export type UserSessionScalarWhereWithAggregatesInput = {
    AND?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    OR?: UserSessionScalarWhereWithAggregatesInput[]
    NOT?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserSession"> | number
    userId?: IntWithAggregatesFilter<"UserSession"> | number
    token?: StringWithAggregatesFilter<"UserSession"> | string
    deviceInfo?: StringNullableWithAggregatesFilter<"UserSession"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"UserSession"> | string | null
    lastActivity?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    expiryTime?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    isActive?: BoolWithAggregatesFilter<"UserSession"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"UserSession"> | Date | string | null
  }

  export type UserProfileWhereInput = {
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    id?: IntFilter<"UserProfile"> | number
    userId?: IntFilter<"UserProfile"> | number
    firstName?: StringNullableFilter<"UserProfile"> | string | null
    lastName?: StringNullableFilter<"UserProfile"> | string | null
    profilePhoto?: StringNullableFilter<"UserProfile"> | string | null
    gender?: StringNullableFilter<"UserProfile"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"UserProfile"> | Date | string | null
    address?: StringNullableFilter<"UserProfile"> | string | null
    city?: StringNullableFilter<"UserProfile"> | string | null
    state?: StringNullableFilter<"UserProfile"> | string | null
    postalCode?: StringNullableFilter<"UserProfile"> | string | null
    country?: StringNullableFilter<"UserProfile"> | string | null
    createdAt?: DateTimeFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeNullableFilter<"UserProfile"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    profilePhoto?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    firstName?: StringNullableFilter<"UserProfile"> | string | null
    lastName?: StringNullableFilter<"UserProfile"> | string | null
    profilePhoto?: StringNullableFilter<"UserProfile"> | string | null
    gender?: StringNullableFilter<"UserProfile"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"UserProfile"> | Date | string | null
    address?: StringNullableFilter<"UserProfile"> | string | null
    city?: StringNullableFilter<"UserProfile"> | string | null
    state?: StringNullableFilter<"UserProfile"> | string | null
    postalCode?: StringNullableFilter<"UserProfile"> | string | null
    country?: StringNullableFilter<"UserProfile"> | string | null
    createdAt?: DateTimeFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeNullableFilter<"UserProfile"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    profilePhoto?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: UserProfileCountOrderByAggregateInput
    _avg?: UserProfileAvgOrderByAggregateInput
    _max?: UserProfileMaxOrderByAggregateInput
    _min?: UserProfileMinOrderByAggregateInput
    _sum?: UserProfileSumOrderByAggregateInput
  }

  export type UserProfileScalarWhereWithAggregatesInput = {
    AND?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    OR?: UserProfileScalarWhereWithAggregatesInput[]
    NOT?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserProfile"> | number
    userId?: IntWithAggregatesFilter<"UserProfile"> | number
    firstName?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    profilePhoto?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    gender?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"UserProfile"> | Date | string | null
    address?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    city?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    state?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    postalCode?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    country?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"UserProfile"> | Date | string | null
  }

  export type VehicleWhereInput = {
    AND?: VehicleWhereInput | VehicleWhereInput[]
    OR?: VehicleWhereInput[]
    NOT?: VehicleWhereInput | VehicleWhereInput[]
    id?: IntFilter<"Vehicle"> | number
    userId?: IntFilter<"Vehicle"> | number
    licensePlate?: StringFilter<"Vehicle"> | string
    vehicleType?: StringFilter<"Vehicle"> | string
    brand?: StringNullableFilter<"Vehicle"> | string | null
    model?: StringNullableFilter<"Vehicle"> | string | null
    color?: StringNullableFilter<"Vehicle"> | string | null
    rfidTag?: StringNullableFilter<"Vehicle"> | string | null
    length?: DecimalNullableFilter<"Vehicle"> | Decimal | DecimalJsLike | number | string | null
    width?: DecimalNullableFilter<"Vehicle"> | Decimal | DecimalJsLike | number | string | null
    height?: DecimalNullableFilter<"Vehicle"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFilter<"Vehicle"> | boolean
    createdAt?: DateTimeFilter<"Vehicle"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Vehicle"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    bookings?: BookingListRelationFilter
  }

  export type VehicleOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    licensePlate?: SortOrder
    vehicleType?: SortOrder
    brand?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    rfidTag?: SortOrderInput | SortOrder
    length?: SortOrderInput | SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    bookings?: BookingOrderByRelationAggregateInput
  }

  export type VehicleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    licensePlate?: string
    AND?: VehicleWhereInput | VehicleWhereInput[]
    OR?: VehicleWhereInput[]
    NOT?: VehicleWhereInput | VehicleWhereInput[]
    userId?: IntFilter<"Vehicle"> | number
    vehicleType?: StringFilter<"Vehicle"> | string
    brand?: StringNullableFilter<"Vehicle"> | string | null
    model?: StringNullableFilter<"Vehicle"> | string | null
    color?: StringNullableFilter<"Vehicle"> | string | null
    rfidTag?: StringNullableFilter<"Vehicle"> | string | null
    length?: DecimalNullableFilter<"Vehicle"> | Decimal | DecimalJsLike | number | string | null
    width?: DecimalNullableFilter<"Vehicle"> | Decimal | DecimalJsLike | number | string | null
    height?: DecimalNullableFilter<"Vehicle"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFilter<"Vehicle"> | boolean
    createdAt?: DateTimeFilter<"Vehicle"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Vehicle"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    bookings?: BookingListRelationFilter
  }, "id" | "licensePlate">

  export type VehicleOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    licensePlate?: SortOrder
    vehicleType?: SortOrder
    brand?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    rfidTag?: SortOrderInput | SortOrder
    length?: SortOrderInput | SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: VehicleCountOrderByAggregateInput
    _avg?: VehicleAvgOrderByAggregateInput
    _max?: VehicleMaxOrderByAggregateInput
    _min?: VehicleMinOrderByAggregateInput
    _sum?: VehicleSumOrderByAggregateInput
  }

  export type VehicleScalarWhereWithAggregatesInput = {
    AND?: VehicleScalarWhereWithAggregatesInput | VehicleScalarWhereWithAggregatesInput[]
    OR?: VehicleScalarWhereWithAggregatesInput[]
    NOT?: VehicleScalarWhereWithAggregatesInput | VehicleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Vehicle"> | number
    userId?: IntWithAggregatesFilter<"Vehicle"> | number
    licensePlate?: StringWithAggregatesFilter<"Vehicle"> | string
    vehicleType?: StringWithAggregatesFilter<"Vehicle"> | string
    brand?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    model?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    color?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    rfidTag?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    length?: DecimalNullableWithAggregatesFilter<"Vehicle"> | Decimal | DecimalJsLike | number | string | null
    width?: DecimalNullableWithAggregatesFilter<"Vehicle"> | Decimal | DecimalJsLike | number | string | null
    height?: DecimalNullableWithAggregatesFilter<"Vehicle"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolWithAggregatesFilter<"Vehicle"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Vehicle"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Vehicle"> | Date | string | null
  }

  export type PlaceWhereInput = {
    AND?: PlaceWhereInput | PlaceWhereInput[]
    OR?: PlaceWhereInput[]
    NOT?: PlaceWhereInput | PlaceWhereInput[]
    id?: IntFilter<"Place"> | number
    name?: StringFilter<"Place"> | string
    image?: StringNullableFilter<"Place"> | string | null
    placeType?: StringFilter<"Place"> | string
    address?: StringFilter<"Place"> | string
    latitude?: DecimalNullableFilter<"Place"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Place"> | Decimal | DecimalJsLike | number | string | null
    contactNumber?: StringNullableFilter<"Place"> | string | null
    email?: StringNullableFilter<"Place"> | string | null
    description?: StringNullableFilter<"Place"> | string | null
    totalCapacity?: IntFilter<"Place"> | number
    isActive?: BoolFilter<"Place"> | boolean
    createdAt?: DateTimeFilter<"Place"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Place"> | Date | string | null
    parkingZones?: ParkingZoneListRelationFilter
    tariffPlans?: TariffPlanListRelationFilter
    parkingPasses?: ParkingPassListRelationFilter
    operatingHours?: OperatingHourListRelationFilter
    placeAdmins?: PlaceAdminListRelationFilter
    placeRatings?: PlaceRatingListRelationFilter
  }

  export type PlaceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrderInput | SortOrder
    placeType?: SortOrder
    address?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    contactNumber?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    totalCapacity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    parkingZones?: ParkingZoneOrderByRelationAggregateInput
    tariffPlans?: TariffPlanOrderByRelationAggregateInput
    parkingPasses?: ParkingPassOrderByRelationAggregateInput
    operatingHours?: OperatingHourOrderByRelationAggregateInput
    placeAdmins?: PlaceAdminOrderByRelationAggregateInput
    placeRatings?: PlaceRatingOrderByRelationAggregateInput
  }

  export type PlaceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PlaceWhereInput | PlaceWhereInput[]
    OR?: PlaceWhereInput[]
    NOT?: PlaceWhereInput | PlaceWhereInput[]
    name?: StringFilter<"Place"> | string
    image?: StringNullableFilter<"Place"> | string | null
    placeType?: StringFilter<"Place"> | string
    address?: StringFilter<"Place"> | string
    latitude?: DecimalNullableFilter<"Place"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Place"> | Decimal | DecimalJsLike | number | string | null
    contactNumber?: StringNullableFilter<"Place"> | string | null
    email?: StringNullableFilter<"Place"> | string | null
    description?: StringNullableFilter<"Place"> | string | null
    totalCapacity?: IntFilter<"Place"> | number
    isActive?: BoolFilter<"Place"> | boolean
    createdAt?: DateTimeFilter<"Place"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Place"> | Date | string | null
    parkingZones?: ParkingZoneListRelationFilter
    tariffPlans?: TariffPlanListRelationFilter
    parkingPasses?: ParkingPassListRelationFilter
    operatingHours?: OperatingHourListRelationFilter
    placeAdmins?: PlaceAdminListRelationFilter
    placeRatings?: PlaceRatingListRelationFilter
  }, "id">

  export type PlaceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrderInput | SortOrder
    placeType?: SortOrder
    address?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    contactNumber?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    totalCapacity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: PlaceCountOrderByAggregateInput
    _avg?: PlaceAvgOrderByAggregateInput
    _max?: PlaceMaxOrderByAggregateInput
    _min?: PlaceMinOrderByAggregateInput
    _sum?: PlaceSumOrderByAggregateInput
  }

  export type PlaceScalarWhereWithAggregatesInput = {
    AND?: PlaceScalarWhereWithAggregatesInput | PlaceScalarWhereWithAggregatesInput[]
    OR?: PlaceScalarWhereWithAggregatesInput[]
    NOT?: PlaceScalarWhereWithAggregatesInput | PlaceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Place"> | number
    name?: StringWithAggregatesFilter<"Place"> | string
    image?: StringNullableWithAggregatesFilter<"Place"> | string | null
    placeType?: StringWithAggregatesFilter<"Place"> | string
    address?: StringWithAggregatesFilter<"Place"> | string
    latitude?: DecimalNullableWithAggregatesFilter<"Place"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableWithAggregatesFilter<"Place"> | Decimal | DecimalJsLike | number | string | null
    contactNumber?: StringNullableWithAggregatesFilter<"Place"> | string | null
    email?: StringNullableWithAggregatesFilter<"Place"> | string | null
    description?: StringNullableWithAggregatesFilter<"Place"> | string | null
    totalCapacity?: IntWithAggregatesFilter<"Place"> | number
    isActive?: BoolWithAggregatesFilter<"Place"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Place"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Place"> | Date | string | null
  }

  export type ParkingZoneWhereInput = {
    AND?: ParkingZoneWhereInput | ParkingZoneWhereInput[]
    OR?: ParkingZoneWhereInput[]
    NOT?: ParkingZoneWhereInput | ParkingZoneWhereInput[]
    id?: IntFilter<"ParkingZone"> | number
    placeId?: IntFilter<"ParkingZone"> | number
    zoneName?: StringFilter<"ParkingZone"> | string
    floorLevel?: StringNullableFilter<"ParkingZone"> | string | null
    zoneType?: StringNullableFilter<"ParkingZone"> | string | null
    totalSlots?: IntFilter<"ParkingZone"> | number
    isActive?: BoolFilter<"ParkingZone"> | boolean
    createdAt?: DateTimeFilter<"ParkingZone"> | Date | string
    updatedAt?: DateTimeNullableFilter<"ParkingZone"> | Date | string | null
    place?: XOR<PlaceScalarRelationFilter, PlaceWhereInput>
    parkingSlots?: ParkingSlotListRelationFilter
  }

  export type ParkingZoneOrderByWithRelationInput = {
    id?: SortOrder
    placeId?: SortOrder
    zoneName?: SortOrder
    floorLevel?: SortOrderInput | SortOrder
    zoneType?: SortOrderInput | SortOrder
    totalSlots?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    place?: PlaceOrderByWithRelationInput
    parkingSlots?: ParkingSlotOrderByRelationAggregateInput
  }

  export type ParkingZoneWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ParkingZoneWhereInput | ParkingZoneWhereInput[]
    OR?: ParkingZoneWhereInput[]
    NOT?: ParkingZoneWhereInput | ParkingZoneWhereInput[]
    placeId?: IntFilter<"ParkingZone"> | number
    zoneName?: StringFilter<"ParkingZone"> | string
    floorLevel?: StringNullableFilter<"ParkingZone"> | string | null
    zoneType?: StringNullableFilter<"ParkingZone"> | string | null
    totalSlots?: IntFilter<"ParkingZone"> | number
    isActive?: BoolFilter<"ParkingZone"> | boolean
    createdAt?: DateTimeFilter<"ParkingZone"> | Date | string
    updatedAt?: DateTimeNullableFilter<"ParkingZone"> | Date | string | null
    place?: XOR<PlaceScalarRelationFilter, PlaceWhereInput>
    parkingSlots?: ParkingSlotListRelationFilter
  }, "id">

  export type ParkingZoneOrderByWithAggregationInput = {
    id?: SortOrder
    placeId?: SortOrder
    zoneName?: SortOrder
    floorLevel?: SortOrderInput | SortOrder
    zoneType?: SortOrderInput | SortOrder
    totalSlots?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: ParkingZoneCountOrderByAggregateInput
    _avg?: ParkingZoneAvgOrderByAggregateInput
    _max?: ParkingZoneMaxOrderByAggregateInput
    _min?: ParkingZoneMinOrderByAggregateInput
    _sum?: ParkingZoneSumOrderByAggregateInput
  }

  export type ParkingZoneScalarWhereWithAggregatesInput = {
    AND?: ParkingZoneScalarWhereWithAggregatesInput | ParkingZoneScalarWhereWithAggregatesInput[]
    OR?: ParkingZoneScalarWhereWithAggregatesInput[]
    NOT?: ParkingZoneScalarWhereWithAggregatesInput | ParkingZoneScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ParkingZone"> | number
    placeId?: IntWithAggregatesFilter<"ParkingZone"> | number
    zoneName?: StringWithAggregatesFilter<"ParkingZone"> | string
    floorLevel?: StringNullableWithAggregatesFilter<"ParkingZone"> | string | null
    zoneType?: StringNullableWithAggregatesFilter<"ParkingZone"> | string | null
    totalSlots?: IntWithAggregatesFilter<"ParkingZone"> | number
    isActive?: BoolWithAggregatesFilter<"ParkingZone"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ParkingZone"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"ParkingZone"> | Date | string | null
  }

  export type ParkingSlotWhereInput = {
    AND?: ParkingSlotWhereInput | ParkingSlotWhereInput[]
    OR?: ParkingSlotWhereInput[]
    NOT?: ParkingSlotWhereInput | ParkingSlotWhereInput[]
    id?: IntFilter<"ParkingSlot"> | number
    zoneId?: IntFilter<"ParkingSlot"> | number
    slotNumber?: StringFilter<"ParkingSlot"> | string
    slotType?: StringFilter<"ParkingSlot"> | string
    isReserved?: BoolFilter<"ParkingSlot"> | boolean
    isOccupied?: BoolFilter<"ParkingSlot"> | boolean
    isDisabledFriendly?: BoolFilter<"ParkingSlot"> | boolean
    hasEvCharger?: BoolFilter<"ParkingSlot"> | boolean
    isActive?: BoolFilter<"ParkingSlot"> | boolean
    createdAt?: DateTimeFilter<"ParkingSlot"> | Date | string
    updatedAt?: DateTimeNullableFilter<"ParkingSlot"> | Date | string | null
    parkingZone?: XOR<ParkingZoneScalarRelationFilter, ParkingZoneWhereInput>
    slotAvailability?: SlotAvailabilityListRelationFilter
    bookings?: BookingListRelationFilter
  }

  export type ParkingSlotOrderByWithRelationInput = {
    id?: SortOrder
    zoneId?: SortOrder
    slotNumber?: SortOrder
    slotType?: SortOrder
    isReserved?: SortOrder
    isOccupied?: SortOrder
    isDisabledFriendly?: SortOrder
    hasEvCharger?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    parkingZone?: ParkingZoneOrderByWithRelationInput
    slotAvailability?: SlotAvailabilityOrderByRelationAggregateInput
    bookings?: BookingOrderByRelationAggregateInput
  }

  export type ParkingSlotWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ParkingSlotWhereInput | ParkingSlotWhereInput[]
    OR?: ParkingSlotWhereInput[]
    NOT?: ParkingSlotWhereInput | ParkingSlotWhereInput[]
    zoneId?: IntFilter<"ParkingSlot"> | number
    slotNumber?: StringFilter<"ParkingSlot"> | string
    slotType?: StringFilter<"ParkingSlot"> | string
    isReserved?: BoolFilter<"ParkingSlot"> | boolean
    isOccupied?: BoolFilter<"ParkingSlot"> | boolean
    isDisabledFriendly?: BoolFilter<"ParkingSlot"> | boolean
    hasEvCharger?: BoolFilter<"ParkingSlot"> | boolean
    isActive?: BoolFilter<"ParkingSlot"> | boolean
    createdAt?: DateTimeFilter<"ParkingSlot"> | Date | string
    updatedAt?: DateTimeNullableFilter<"ParkingSlot"> | Date | string | null
    parkingZone?: XOR<ParkingZoneScalarRelationFilter, ParkingZoneWhereInput>
    slotAvailability?: SlotAvailabilityListRelationFilter
    bookings?: BookingListRelationFilter
  }, "id">

  export type ParkingSlotOrderByWithAggregationInput = {
    id?: SortOrder
    zoneId?: SortOrder
    slotNumber?: SortOrder
    slotType?: SortOrder
    isReserved?: SortOrder
    isOccupied?: SortOrder
    isDisabledFriendly?: SortOrder
    hasEvCharger?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: ParkingSlotCountOrderByAggregateInput
    _avg?: ParkingSlotAvgOrderByAggregateInput
    _max?: ParkingSlotMaxOrderByAggregateInput
    _min?: ParkingSlotMinOrderByAggregateInput
    _sum?: ParkingSlotSumOrderByAggregateInput
  }

  export type ParkingSlotScalarWhereWithAggregatesInput = {
    AND?: ParkingSlotScalarWhereWithAggregatesInput | ParkingSlotScalarWhereWithAggregatesInput[]
    OR?: ParkingSlotScalarWhereWithAggregatesInput[]
    NOT?: ParkingSlotScalarWhereWithAggregatesInput | ParkingSlotScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ParkingSlot"> | number
    zoneId?: IntWithAggregatesFilter<"ParkingSlot"> | number
    slotNumber?: StringWithAggregatesFilter<"ParkingSlot"> | string
    slotType?: StringWithAggregatesFilter<"ParkingSlot"> | string
    isReserved?: BoolWithAggregatesFilter<"ParkingSlot"> | boolean
    isOccupied?: BoolWithAggregatesFilter<"ParkingSlot"> | boolean
    isDisabledFriendly?: BoolWithAggregatesFilter<"ParkingSlot"> | boolean
    hasEvCharger?: BoolWithAggregatesFilter<"ParkingSlot"> | boolean
    isActive?: BoolWithAggregatesFilter<"ParkingSlot"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ParkingSlot"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"ParkingSlot"> | Date | string | null
  }

  export type SlotAvailabilityWhereInput = {
    AND?: SlotAvailabilityWhereInput | SlotAvailabilityWhereInput[]
    OR?: SlotAvailabilityWhereInput[]
    NOT?: SlotAvailabilityWhereInput | SlotAvailabilityWhereInput[]
    id?: IntFilter<"SlotAvailability"> | number
    slotId?: IntFilter<"SlotAvailability"> | number
    availableFrom?: DateTimeFilter<"SlotAvailability"> | Date | string
    availableUntil?: DateTimeFilter<"SlotAvailability"> | Date | string
    isBookable?: BoolFilter<"SlotAvailability"> | boolean
    statusReason?: StringNullableFilter<"SlotAvailability"> | string | null
    createdAt?: DateTimeFilter<"SlotAvailability"> | Date | string
    updatedAt?: DateTimeNullableFilter<"SlotAvailability"> | Date | string | null
    parkingSlot?: XOR<ParkingSlotScalarRelationFilter, ParkingSlotWhereInput>
  }

  export type SlotAvailabilityOrderByWithRelationInput = {
    id?: SortOrder
    slotId?: SortOrder
    availableFrom?: SortOrder
    availableUntil?: SortOrder
    isBookable?: SortOrder
    statusReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    parkingSlot?: ParkingSlotOrderByWithRelationInput
  }

  export type SlotAvailabilityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SlotAvailabilityWhereInput | SlotAvailabilityWhereInput[]
    OR?: SlotAvailabilityWhereInput[]
    NOT?: SlotAvailabilityWhereInput | SlotAvailabilityWhereInput[]
    slotId?: IntFilter<"SlotAvailability"> | number
    availableFrom?: DateTimeFilter<"SlotAvailability"> | Date | string
    availableUntil?: DateTimeFilter<"SlotAvailability"> | Date | string
    isBookable?: BoolFilter<"SlotAvailability"> | boolean
    statusReason?: StringNullableFilter<"SlotAvailability"> | string | null
    createdAt?: DateTimeFilter<"SlotAvailability"> | Date | string
    updatedAt?: DateTimeNullableFilter<"SlotAvailability"> | Date | string | null
    parkingSlot?: XOR<ParkingSlotScalarRelationFilter, ParkingSlotWhereInput>
  }, "id">

  export type SlotAvailabilityOrderByWithAggregationInput = {
    id?: SortOrder
    slotId?: SortOrder
    availableFrom?: SortOrder
    availableUntil?: SortOrder
    isBookable?: SortOrder
    statusReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: SlotAvailabilityCountOrderByAggregateInput
    _avg?: SlotAvailabilityAvgOrderByAggregateInput
    _max?: SlotAvailabilityMaxOrderByAggregateInput
    _min?: SlotAvailabilityMinOrderByAggregateInput
    _sum?: SlotAvailabilitySumOrderByAggregateInput
  }

  export type SlotAvailabilityScalarWhereWithAggregatesInput = {
    AND?: SlotAvailabilityScalarWhereWithAggregatesInput | SlotAvailabilityScalarWhereWithAggregatesInput[]
    OR?: SlotAvailabilityScalarWhereWithAggregatesInput[]
    NOT?: SlotAvailabilityScalarWhereWithAggregatesInput | SlotAvailabilityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SlotAvailability"> | number
    slotId?: IntWithAggregatesFilter<"SlotAvailability"> | number
    availableFrom?: DateTimeWithAggregatesFilter<"SlotAvailability"> | Date | string
    availableUntil?: DateTimeWithAggregatesFilter<"SlotAvailability"> | Date | string
    isBookable?: BoolWithAggregatesFilter<"SlotAvailability"> | boolean
    statusReason?: StringNullableWithAggregatesFilter<"SlotAvailability"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SlotAvailability"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"SlotAvailability"> | Date | string | null
  }

  export type TariffPlanWhereInput = {
    AND?: TariffPlanWhereInput | TariffPlanWhereInput[]
    OR?: TariffPlanWhereInput[]
    NOT?: TariffPlanWhereInput | TariffPlanWhereInput[]
    id?: IntFilter<"TariffPlan"> | number
    placeId?: IntFilter<"TariffPlan"> | number
    planName?: StringFilter<"TariffPlan"> | string
    description?: StringNullableFilter<"TariffPlan"> | string | null
    effectiveFrom?: DateTimeFilter<"TariffPlan"> | Date | string
    effectiveUntil?: DateTimeNullableFilter<"TariffPlan"> | Date | string | null
    isActive?: BoolFilter<"TariffPlan"> | boolean
    createdAt?: DateTimeFilter<"TariffPlan"> | Date | string
    updatedAt?: DateTimeNullableFilter<"TariffPlan"> | Date | string | null
    place?: XOR<PlaceScalarRelationFilter, PlaceWhereInput>
    tariffRates?: TariffRateListRelationFilter
  }

  export type TariffPlanOrderByWithRelationInput = {
    id?: SortOrder
    placeId?: SortOrder
    planName?: SortOrder
    description?: SortOrderInput | SortOrder
    effectiveFrom?: SortOrder
    effectiveUntil?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    place?: PlaceOrderByWithRelationInput
    tariffRates?: TariffRateOrderByRelationAggregateInput
  }

  export type TariffPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TariffPlanWhereInput | TariffPlanWhereInput[]
    OR?: TariffPlanWhereInput[]
    NOT?: TariffPlanWhereInput | TariffPlanWhereInput[]
    placeId?: IntFilter<"TariffPlan"> | number
    planName?: StringFilter<"TariffPlan"> | string
    description?: StringNullableFilter<"TariffPlan"> | string | null
    effectiveFrom?: DateTimeFilter<"TariffPlan"> | Date | string
    effectiveUntil?: DateTimeNullableFilter<"TariffPlan"> | Date | string | null
    isActive?: BoolFilter<"TariffPlan"> | boolean
    createdAt?: DateTimeFilter<"TariffPlan"> | Date | string
    updatedAt?: DateTimeNullableFilter<"TariffPlan"> | Date | string | null
    place?: XOR<PlaceScalarRelationFilter, PlaceWhereInput>
    tariffRates?: TariffRateListRelationFilter
  }, "id">

  export type TariffPlanOrderByWithAggregationInput = {
    id?: SortOrder
    placeId?: SortOrder
    planName?: SortOrder
    description?: SortOrderInput | SortOrder
    effectiveFrom?: SortOrder
    effectiveUntil?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: TariffPlanCountOrderByAggregateInput
    _avg?: TariffPlanAvgOrderByAggregateInput
    _max?: TariffPlanMaxOrderByAggregateInput
    _min?: TariffPlanMinOrderByAggregateInput
    _sum?: TariffPlanSumOrderByAggregateInput
  }

  export type TariffPlanScalarWhereWithAggregatesInput = {
    AND?: TariffPlanScalarWhereWithAggregatesInput | TariffPlanScalarWhereWithAggregatesInput[]
    OR?: TariffPlanScalarWhereWithAggregatesInput[]
    NOT?: TariffPlanScalarWhereWithAggregatesInput | TariffPlanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TariffPlan"> | number
    placeId?: IntWithAggregatesFilter<"TariffPlan"> | number
    planName?: StringWithAggregatesFilter<"TariffPlan"> | string
    description?: StringNullableWithAggregatesFilter<"TariffPlan"> | string | null
    effectiveFrom?: DateTimeWithAggregatesFilter<"TariffPlan"> | Date | string
    effectiveUntil?: DateTimeNullableWithAggregatesFilter<"TariffPlan"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"TariffPlan"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TariffPlan"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"TariffPlan"> | Date | string | null
  }

  export type TariffRateWhereInput = {
    AND?: TariffRateWhereInput | TariffRateWhereInput[]
    OR?: TariffRateWhereInput[]
    NOT?: TariffRateWhereInput | TariffRateWhereInput[]
    id?: IntFilter<"TariffRate"> | number
    planId?: IntFilter<"TariffRate"> | number
    vehicleType?: StringFilter<"TariffRate"> | string
    slotType?: StringFilter<"TariffRate"> | string
    startTime?: DateTimeNullableFilter<"TariffRate"> | Date | string | null
    endTime?: DateTimeNullableFilter<"TariffRate"> | Date | string | null
    dayCategory?: StringNullableFilter<"TariffRate"> | string | null
    basePrice?: DecimalFilter<"TariffRate"> | Decimal | DecimalJsLike | number | string
    hourlyRate?: DecimalFilter<"TariffRate"> | Decimal | DecimalJsLike | number | string
    dayRate?: DecimalNullableFilter<"TariffRate"> | Decimal | DecimalJsLike | number | string | null
    minimumCharge?: DecimalFilter<"TariffRate"> | Decimal | DecimalJsLike | number | string
    gracePeriodMinutes?: IntFilter<"TariffRate"> | number
    createdAt?: DateTimeFilter<"TariffRate"> | Date | string
    updatedAt?: DateTimeNullableFilter<"TariffRate"> | Date | string | null
    tariffPlan?: XOR<TariffPlanScalarRelationFilter, TariffPlanWhereInput>
  }

  export type TariffRateOrderByWithRelationInput = {
    id?: SortOrder
    planId?: SortOrder
    vehicleType?: SortOrder
    slotType?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    dayCategory?: SortOrderInput | SortOrder
    basePrice?: SortOrder
    hourlyRate?: SortOrder
    dayRate?: SortOrderInput | SortOrder
    minimumCharge?: SortOrder
    gracePeriodMinutes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    tariffPlan?: TariffPlanOrderByWithRelationInput
  }

  export type TariffRateWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TariffRateWhereInput | TariffRateWhereInput[]
    OR?: TariffRateWhereInput[]
    NOT?: TariffRateWhereInput | TariffRateWhereInput[]
    planId?: IntFilter<"TariffRate"> | number
    vehicleType?: StringFilter<"TariffRate"> | string
    slotType?: StringFilter<"TariffRate"> | string
    startTime?: DateTimeNullableFilter<"TariffRate"> | Date | string | null
    endTime?: DateTimeNullableFilter<"TariffRate"> | Date | string | null
    dayCategory?: StringNullableFilter<"TariffRate"> | string | null
    basePrice?: DecimalFilter<"TariffRate"> | Decimal | DecimalJsLike | number | string
    hourlyRate?: DecimalFilter<"TariffRate"> | Decimal | DecimalJsLike | number | string
    dayRate?: DecimalNullableFilter<"TariffRate"> | Decimal | DecimalJsLike | number | string | null
    minimumCharge?: DecimalFilter<"TariffRate"> | Decimal | DecimalJsLike | number | string
    gracePeriodMinutes?: IntFilter<"TariffRate"> | number
    createdAt?: DateTimeFilter<"TariffRate"> | Date | string
    updatedAt?: DateTimeNullableFilter<"TariffRate"> | Date | string | null
    tariffPlan?: XOR<TariffPlanScalarRelationFilter, TariffPlanWhereInput>
  }, "id">

  export type TariffRateOrderByWithAggregationInput = {
    id?: SortOrder
    planId?: SortOrder
    vehicleType?: SortOrder
    slotType?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    dayCategory?: SortOrderInput | SortOrder
    basePrice?: SortOrder
    hourlyRate?: SortOrder
    dayRate?: SortOrderInput | SortOrder
    minimumCharge?: SortOrder
    gracePeriodMinutes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: TariffRateCountOrderByAggregateInput
    _avg?: TariffRateAvgOrderByAggregateInput
    _max?: TariffRateMaxOrderByAggregateInput
    _min?: TariffRateMinOrderByAggregateInput
    _sum?: TariffRateSumOrderByAggregateInput
  }

  export type TariffRateScalarWhereWithAggregatesInput = {
    AND?: TariffRateScalarWhereWithAggregatesInput | TariffRateScalarWhereWithAggregatesInput[]
    OR?: TariffRateScalarWhereWithAggregatesInput[]
    NOT?: TariffRateScalarWhereWithAggregatesInput | TariffRateScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TariffRate"> | number
    planId?: IntWithAggregatesFilter<"TariffRate"> | number
    vehicleType?: StringWithAggregatesFilter<"TariffRate"> | string
    slotType?: StringWithAggregatesFilter<"TariffRate"> | string
    startTime?: DateTimeNullableWithAggregatesFilter<"TariffRate"> | Date | string | null
    endTime?: DateTimeNullableWithAggregatesFilter<"TariffRate"> | Date | string | null
    dayCategory?: StringNullableWithAggregatesFilter<"TariffRate"> | string | null
    basePrice?: DecimalWithAggregatesFilter<"TariffRate"> | Decimal | DecimalJsLike | number | string
    hourlyRate?: DecimalWithAggregatesFilter<"TariffRate"> | Decimal | DecimalJsLike | number | string
    dayRate?: DecimalNullableWithAggregatesFilter<"TariffRate"> | Decimal | DecimalJsLike | number | string | null
    minimumCharge?: DecimalWithAggregatesFilter<"TariffRate"> | Decimal | DecimalJsLike | number | string
    gracePeriodMinutes?: IntWithAggregatesFilter<"TariffRate"> | number
    createdAt?: DateTimeWithAggregatesFilter<"TariffRate"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"TariffRate"> | Date | string | null
  }

  export type BookingWhereInput = {
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    id?: IntFilter<"Booking"> | number
    userId?: IntFilter<"Booking"> | number
    vehicleId?: IntFilter<"Booking"> | number
    slotId?: IntFilter<"Booking"> | number
    promoCodeId?: IntNullableFilter<"Booking"> | number | null
    bookingReference?: StringFilter<"Booking"> | string
    bookingTime?: DateTimeFilter<"Booking"> | Date | string
    scheduledEntry?: DateTimeFilter<"Booking"> | Date | string
    scheduledExit?: DateTimeFilter<"Booking"> | Date | string
    actualEntry?: DateTimeNullableFilter<"Booking"> | Date | string | null
    actualExit?: DateTimeNullableFilter<"Booking"> | Date | string | null
    qrCode?: StringNullableFilter<"Booking"> | string | null
    bookingStatus?: StringFilter<"Booking"> | string
    estimatedPrice?: DecimalFilter<"Booking"> | Decimal | DecimalJsLike | number | string
    finalPrice?: DecimalNullableFilter<"Booking"> | Decimal | DecimalJsLike | number | string | null
    cancellationReason?: StringNullableFilter<"Booking"> | string | null
    cancellationTimeMinutes?: IntNullableFilter<"Booking"> | number | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    vehicle?: XOR<VehicleScalarRelationFilter, VehicleWhereInput>
    parkingSlot?: XOR<ParkingSlotScalarRelationFilter, ParkingSlotWhereInput>
    promoCode?: XOR<PromoCodeNullableScalarRelationFilter, PromoCodeWhereInput> | null
    bookingStatusLogs?: BookingStatusLogListRelationFilter
    bookingPayment?: XOR<BookingPaymentNullableScalarRelationFilter, BookingPaymentWhereInput> | null
    accessLogs?: AccessLogListRelationFilter
    bookingExtensions?: BookingExtensionListRelationFilter
    placeRatings?: PlaceRatingListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type BookingOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    vehicleId?: SortOrder
    slotId?: SortOrder
    promoCodeId?: SortOrderInput | SortOrder
    bookingReference?: SortOrder
    bookingTime?: SortOrder
    scheduledEntry?: SortOrder
    scheduledExit?: SortOrder
    actualEntry?: SortOrderInput | SortOrder
    actualExit?: SortOrderInput | SortOrder
    qrCode?: SortOrderInput | SortOrder
    bookingStatus?: SortOrder
    estimatedPrice?: SortOrder
    finalPrice?: SortOrderInput | SortOrder
    cancellationReason?: SortOrderInput | SortOrder
    cancellationTimeMinutes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    vehicle?: VehicleOrderByWithRelationInput
    parkingSlot?: ParkingSlotOrderByWithRelationInput
    promoCode?: PromoCodeOrderByWithRelationInput
    bookingStatusLogs?: BookingStatusLogOrderByRelationAggregateInput
    bookingPayment?: BookingPaymentOrderByWithRelationInput
    accessLogs?: AccessLogOrderByRelationAggregateInput
    bookingExtensions?: BookingExtensionOrderByRelationAggregateInput
    placeRatings?: PlaceRatingOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type BookingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    bookingReference?: string
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    userId?: IntFilter<"Booking"> | number
    vehicleId?: IntFilter<"Booking"> | number
    slotId?: IntFilter<"Booking"> | number
    promoCodeId?: IntNullableFilter<"Booking"> | number | null
    bookingTime?: DateTimeFilter<"Booking"> | Date | string
    scheduledEntry?: DateTimeFilter<"Booking"> | Date | string
    scheduledExit?: DateTimeFilter<"Booking"> | Date | string
    actualEntry?: DateTimeNullableFilter<"Booking"> | Date | string | null
    actualExit?: DateTimeNullableFilter<"Booking"> | Date | string | null
    qrCode?: StringNullableFilter<"Booking"> | string | null
    bookingStatus?: StringFilter<"Booking"> | string
    estimatedPrice?: DecimalFilter<"Booking"> | Decimal | DecimalJsLike | number | string
    finalPrice?: DecimalNullableFilter<"Booking"> | Decimal | DecimalJsLike | number | string | null
    cancellationReason?: StringNullableFilter<"Booking"> | string | null
    cancellationTimeMinutes?: IntNullableFilter<"Booking"> | number | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    vehicle?: XOR<VehicleScalarRelationFilter, VehicleWhereInput>
    parkingSlot?: XOR<ParkingSlotScalarRelationFilter, ParkingSlotWhereInput>
    promoCode?: XOR<PromoCodeNullableScalarRelationFilter, PromoCodeWhereInput> | null
    bookingStatusLogs?: BookingStatusLogListRelationFilter
    bookingPayment?: XOR<BookingPaymentNullableScalarRelationFilter, BookingPaymentWhereInput> | null
    accessLogs?: AccessLogListRelationFilter
    bookingExtensions?: BookingExtensionListRelationFilter
    placeRatings?: PlaceRatingListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id" | "bookingReference">

  export type BookingOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    vehicleId?: SortOrder
    slotId?: SortOrder
    promoCodeId?: SortOrderInput | SortOrder
    bookingReference?: SortOrder
    bookingTime?: SortOrder
    scheduledEntry?: SortOrder
    scheduledExit?: SortOrder
    actualEntry?: SortOrderInput | SortOrder
    actualExit?: SortOrderInput | SortOrder
    qrCode?: SortOrderInput | SortOrder
    bookingStatus?: SortOrder
    estimatedPrice?: SortOrder
    finalPrice?: SortOrderInput | SortOrder
    cancellationReason?: SortOrderInput | SortOrder
    cancellationTimeMinutes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: BookingCountOrderByAggregateInput
    _avg?: BookingAvgOrderByAggregateInput
    _max?: BookingMaxOrderByAggregateInput
    _min?: BookingMinOrderByAggregateInput
    _sum?: BookingSumOrderByAggregateInput
  }

  export type BookingScalarWhereWithAggregatesInput = {
    AND?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    OR?: BookingScalarWhereWithAggregatesInput[]
    NOT?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Booking"> | number
    userId?: IntWithAggregatesFilter<"Booking"> | number
    vehicleId?: IntWithAggregatesFilter<"Booking"> | number
    slotId?: IntWithAggregatesFilter<"Booking"> | number
    promoCodeId?: IntNullableWithAggregatesFilter<"Booking"> | number | null
    bookingReference?: StringWithAggregatesFilter<"Booking"> | string
    bookingTime?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    scheduledEntry?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    scheduledExit?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    actualEntry?: DateTimeNullableWithAggregatesFilter<"Booking"> | Date | string | null
    actualExit?: DateTimeNullableWithAggregatesFilter<"Booking"> | Date | string | null
    qrCode?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    bookingStatus?: StringWithAggregatesFilter<"Booking"> | string
    estimatedPrice?: DecimalWithAggregatesFilter<"Booking"> | Decimal | DecimalJsLike | number | string
    finalPrice?: DecimalNullableWithAggregatesFilter<"Booking"> | Decimal | DecimalJsLike | number | string | null
    cancellationReason?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    cancellationTimeMinutes?: IntNullableWithAggregatesFilter<"Booking"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Booking"> | Date | string | null
  }

  export type BookingStatusLogWhereInput = {
    AND?: BookingStatusLogWhereInput | BookingStatusLogWhereInput[]
    OR?: BookingStatusLogWhereInput[]
    NOT?: BookingStatusLogWhereInput | BookingStatusLogWhereInput[]
    id?: IntFilter<"BookingStatusLog"> | number
    bookingId?: IntFilter<"BookingStatusLog"> | number
    previousStatus?: StringFilter<"BookingStatusLog"> | string
    newStatus?: StringFilter<"BookingStatusLog"> | string
    changedBy?: StringFilter<"BookingStatusLog"> | string
    reason?: StringNullableFilter<"BookingStatusLog"> | string | null
    statusTime?: DateTimeFilter<"BookingStatusLog"> | Date | string
    createdAt?: DateTimeFilter<"BookingStatusLog"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
  }

  export type BookingStatusLogOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    previousStatus?: SortOrder
    newStatus?: SortOrder
    changedBy?: SortOrder
    reason?: SortOrderInput | SortOrder
    statusTime?: SortOrder
    createdAt?: SortOrder
    booking?: BookingOrderByWithRelationInput
  }

  export type BookingStatusLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BookingStatusLogWhereInput | BookingStatusLogWhereInput[]
    OR?: BookingStatusLogWhereInput[]
    NOT?: BookingStatusLogWhereInput | BookingStatusLogWhereInput[]
    bookingId?: IntFilter<"BookingStatusLog"> | number
    previousStatus?: StringFilter<"BookingStatusLog"> | string
    newStatus?: StringFilter<"BookingStatusLog"> | string
    changedBy?: StringFilter<"BookingStatusLog"> | string
    reason?: StringNullableFilter<"BookingStatusLog"> | string | null
    statusTime?: DateTimeFilter<"BookingStatusLog"> | Date | string
    createdAt?: DateTimeFilter<"BookingStatusLog"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
  }, "id">

  export type BookingStatusLogOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    previousStatus?: SortOrder
    newStatus?: SortOrder
    changedBy?: SortOrder
    reason?: SortOrderInput | SortOrder
    statusTime?: SortOrder
    createdAt?: SortOrder
    _count?: BookingStatusLogCountOrderByAggregateInput
    _avg?: BookingStatusLogAvgOrderByAggregateInput
    _max?: BookingStatusLogMaxOrderByAggregateInput
    _min?: BookingStatusLogMinOrderByAggregateInput
    _sum?: BookingStatusLogSumOrderByAggregateInput
  }

  export type BookingStatusLogScalarWhereWithAggregatesInput = {
    AND?: BookingStatusLogScalarWhereWithAggregatesInput | BookingStatusLogScalarWhereWithAggregatesInput[]
    OR?: BookingStatusLogScalarWhereWithAggregatesInput[]
    NOT?: BookingStatusLogScalarWhereWithAggregatesInput | BookingStatusLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BookingStatusLog"> | number
    bookingId?: IntWithAggregatesFilter<"BookingStatusLog"> | number
    previousStatus?: StringWithAggregatesFilter<"BookingStatusLog"> | string
    newStatus?: StringWithAggregatesFilter<"BookingStatusLog"> | string
    changedBy?: StringWithAggregatesFilter<"BookingStatusLog"> | string
    reason?: StringNullableWithAggregatesFilter<"BookingStatusLog"> | string | null
    statusTime?: DateTimeWithAggregatesFilter<"BookingStatusLog"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"BookingStatusLog"> | Date | string
  }

  export type BookingPaymentWhereInput = {
    AND?: BookingPaymentWhereInput | BookingPaymentWhereInput[]
    OR?: BookingPaymentWhereInput[]
    NOT?: BookingPaymentWhereInput | BookingPaymentWhereInput[]
    id?: IntFilter<"BookingPayment"> | number
    bookingId?: IntFilter<"BookingPayment"> | number
    paymentReference?: StringNullableFilter<"BookingPayment"> | string | null
    paymentStatus?: StringFilter<"BookingPayment"> | string
    originalAmount?: DecimalFilter<"BookingPayment"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"BookingPayment"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"BookingPayment"> | Decimal | DecimalJsLike | number | string
    surchargeAmount?: DecimalFilter<"BookingPayment"> | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFilter<"BookingPayment"> | Decimal | DecimalJsLike | number | string
    isPrepaid?: BoolFilter<"BookingPayment"> | boolean
    isRefunded?: BoolFilter<"BookingPayment"> | boolean
    createdAt?: DateTimeFilter<"BookingPayment"> | Date | string
    updatedAt?: DateTimeNullableFilter<"BookingPayment"> | Date | string | null
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    paymentTransactions?: PaymentTransactionListRelationFilter
    refundTransactions?: RefundTransactionListRelationFilter
  }

  export type BookingPaymentOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    paymentReference?: SortOrderInput | SortOrder
    paymentStatus?: SortOrder
    originalAmount?: SortOrder
    discountAmount?: SortOrder
    taxAmount?: SortOrder
    surchargeAmount?: SortOrder
    finalAmount?: SortOrder
    isPrepaid?: SortOrder
    isRefunded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    booking?: BookingOrderByWithRelationInput
    paymentTransactions?: PaymentTransactionOrderByRelationAggregateInput
    refundTransactions?: RefundTransactionOrderByRelationAggregateInput
  }

  export type BookingPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    bookingId?: number
    paymentReference?: string
    AND?: BookingPaymentWhereInput | BookingPaymentWhereInput[]
    OR?: BookingPaymentWhereInput[]
    NOT?: BookingPaymentWhereInput | BookingPaymentWhereInput[]
    paymentStatus?: StringFilter<"BookingPayment"> | string
    originalAmount?: DecimalFilter<"BookingPayment"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"BookingPayment"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"BookingPayment"> | Decimal | DecimalJsLike | number | string
    surchargeAmount?: DecimalFilter<"BookingPayment"> | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFilter<"BookingPayment"> | Decimal | DecimalJsLike | number | string
    isPrepaid?: BoolFilter<"BookingPayment"> | boolean
    isRefunded?: BoolFilter<"BookingPayment"> | boolean
    createdAt?: DateTimeFilter<"BookingPayment"> | Date | string
    updatedAt?: DateTimeNullableFilter<"BookingPayment"> | Date | string | null
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    paymentTransactions?: PaymentTransactionListRelationFilter
    refundTransactions?: RefundTransactionListRelationFilter
  }, "id" | "bookingId" | "paymentReference">

  export type BookingPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    paymentReference?: SortOrderInput | SortOrder
    paymentStatus?: SortOrder
    originalAmount?: SortOrder
    discountAmount?: SortOrder
    taxAmount?: SortOrder
    surchargeAmount?: SortOrder
    finalAmount?: SortOrder
    isPrepaid?: SortOrder
    isRefunded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: BookingPaymentCountOrderByAggregateInput
    _avg?: BookingPaymentAvgOrderByAggregateInput
    _max?: BookingPaymentMaxOrderByAggregateInput
    _min?: BookingPaymentMinOrderByAggregateInput
    _sum?: BookingPaymentSumOrderByAggregateInput
  }

  export type BookingPaymentScalarWhereWithAggregatesInput = {
    AND?: BookingPaymentScalarWhereWithAggregatesInput | BookingPaymentScalarWhereWithAggregatesInput[]
    OR?: BookingPaymentScalarWhereWithAggregatesInput[]
    NOT?: BookingPaymentScalarWhereWithAggregatesInput | BookingPaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BookingPayment"> | number
    bookingId?: IntWithAggregatesFilter<"BookingPayment"> | number
    paymentReference?: StringNullableWithAggregatesFilter<"BookingPayment"> | string | null
    paymentStatus?: StringWithAggregatesFilter<"BookingPayment"> | string
    originalAmount?: DecimalWithAggregatesFilter<"BookingPayment"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalWithAggregatesFilter<"BookingPayment"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalWithAggregatesFilter<"BookingPayment"> | Decimal | DecimalJsLike | number | string
    surchargeAmount?: DecimalWithAggregatesFilter<"BookingPayment"> | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalWithAggregatesFilter<"BookingPayment"> | Decimal | DecimalJsLike | number | string
    isPrepaid?: BoolWithAggregatesFilter<"BookingPayment"> | boolean
    isRefunded?: BoolWithAggregatesFilter<"BookingPayment"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BookingPayment"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"BookingPayment"> | Date | string | null
  }

  export type PaymentTransactionWhereInput = {
    AND?: PaymentTransactionWhereInput | PaymentTransactionWhereInput[]
    OR?: PaymentTransactionWhereInput[]
    NOT?: PaymentTransactionWhereInput | PaymentTransactionWhereInput[]
    id?: IntFilter<"PaymentTransaction"> | number
    paymentId?: IntFilter<"PaymentTransaction"> | number
    paymentMethodId?: IntFilter<"PaymentTransaction"> | number
    transactionReference?: StringNullableFilter<"PaymentTransaction"> | string | null
    transactionType?: StringFilter<"PaymentTransaction"> | string
    amount?: DecimalFilter<"PaymentTransaction"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"PaymentTransaction"> | string
    transactionStatus?: StringFilter<"PaymentTransaction"> | string
    gatewayResponse?: StringNullableFilter<"PaymentTransaction"> | string | null
    transactionData?: StringNullableFilter<"PaymentTransaction"> | string | null
    transactionTime?: DateTimeNullableFilter<"PaymentTransaction"> | Date | string | null
    createdAt?: DateTimeFilter<"PaymentTransaction"> | Date | string
    updatedAt?: DateTimeNullableFilter<"PaymentTransaction"> | Date | string | null
    bookingPayment?: XOR<BookingPaymentScalarRelationFilter, BookingPaymentWhereInput>
    paymentMethod?: XOR<PaymentMethodScalarRelationFilter, PaymentMethodWhereInput>
  }

  export type PaymentTransactionOrderByWithRelationInput = {
    id?: SortOrder
    paymentId?: SortOrder
    paymentMethodId?: SortOrder
    transactionReference?: SortOrderInput | SortOrder
    transactionType?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    transactionStatus?: SortOrder
    gatewayResponse?: SortOrderInput | SortOrder
    transactionData?: SortOrderInput | SortOrder
    transactionTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    bookingPayment?: BookingPaymentOrderByWithRelationInput
    paymentMethod?: PaymentMethodOrderByWithRelationInput
  }

  export type PaymentTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    transactionReference?: string
    AND?: PaymentTransactionWhereInput | PaymentTransactionWhereInput[]
    OR?: PaymentTransactionWhereInput[]
    NOT?: PaymentTransactionWhereInput | PaymentTransactionWhereInput[]
    paymentId?: IntFilter<"PaymentTransaction"> | number
    paymentMethodId?: IntFilter<"PaymentTransaction"> | number
    transactionType?: StringFilter<"PaymentTransaction"> | string
    amount?: DecimalFilter<"PaymentTransaction"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"PaymentTransaction"> | string
    transactionStatus?: StringFilter<"PaymentTransaction"> | string
    gatewayResponse?: StringNullableFilter<"PaymentTransaction"> | string | null
    transactionData?: StringNullableFilter<"PaymentTransaction"> | string | null
    transactionTime?: DateTimeNullableFilter<"PaymentTransaction"> | Date | string | null
    createdAt?: DateTimeFilter<"PaymentTransaction"> | Date | string
    updatedAt?: DateTimeNullableFilter<"PaymentTransaction"> | Date | string | null
    bookingPayment?: XOR<BookingPaymentScalarRelationFilter, BookingPaymentWhereInput>
    paymentMethod?: XOR<PaymentMethodScalarRelationFilter, PaymentMethodWhereInput>
  }, "id" | "transactionReference">

  export type PaymentTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    paymentId?: SortOrder
    paymentMethodId?: SortOrder
    transactionReference?: SortOrderInput | SortOrder
    transactionType?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    transactionStatus?: SortOrder
    gatewayResponse?: SortOrderInput | SortOrder
    transactionData?: SortOrderInput | SortOrder
    transactionTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: PaymentTransactionCountOrderByAggregateInput
    _avg?: PaymentTransactionAvgOrderByAggregateInput
    _max?: PaymentTransactionMaxOrderByAggregateInput
    _min?: PaymentTransactionMinOrderByAggregateInput
    _sum?: PaymentTransactionSumOrderByAggregateInput
  }

  export type PaymentTransactionScalarWhereWithAggregatesInput = {
    AND?: PaymentTransactionScalarWhereWithAggregatesInput | PaymentTransactionScalarWhereWithAggregatesInput[]
    OR?: PaymentTransactionScalarWhereWithAggregatesInput[]
    NOT?: PaymentTransactionScalarWhereWithAggregatesInput | PaymentTransactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PaymentTransaction"> | number
    paymentId?: IntWithAggregatesFilter<"PaymentTransaction"> | number
    paymentMethodId?: IntWithAggregatesFilter<"PaymentTransaction"> | number
    transactionReference?: StringNullableWithAggregatesFilter<"PaymentTransaction"> | string | null
    transactionType?: StringWithAggregatesFilter<"PaymentTransaction"> | string
    amount?: DecimalWithAggregatesFilter<"PaymentTransaction"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"PaymentTransaction"> | string
    transactionStatus?: StringWithAggregatesFilter<"PaymentTransaction"> | string
    gatewayResponse?: StringNullableWithAggregatesFilter<"PaymentTransaction"> | string | null
    transactionData?: StringNullableWithAggregatesFilter<"PaymentTransaction"> | string | null
    transactionTime?: DateTimeNullableWithAggregatesFilter<"PaymentTransaction"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PaymentTransaction"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"PaymentTransaction"> | Date | string | null
  }

  export type RefundTransactionWhereInput = {
    AND?: RefundTransactionWhereInput | RefundTransactionWhereInput[]
    OR?: RefundTransactionWhereInput[]
    NOT?: RefundTransactionWhereInput | RefundTransactionWhereInput[]
    id?: IntFilter<"RefundTransaction"> | number
    paymentId?: IntFilter<"RefundTransaction"> | number
    refundReference?: StringNullableFilter<"RefundTransaction"> | string | null
    refundAmount?: DecimalFilter<"RefundTransaction"> | Decimal | DecimalJsLike | number | string
    refundReason?: StringNullableFilter<"RefundTransaction"> | string | null
    refundStatus?: StringFilter<"RefundTransaction"> | string
    processorResponse?: StringNullableFilter<"RefundTransaction"> | string | null
    refundData?: StringNullableFilter<"RefundTransaction"> | string | null
    refundTime?: DateTimeNullableFilter<"RefundTransaction"> | Date | string | null
    createdAt?: DateTimeFilter<"RefundTransaction"> | Date | string
    updatedAt?: DateTimeNullableFilter<"RefundTransaction"> | Date | string | null
    bookingPayment?: XOR<BookingPaymentScalarRelationFilter, BookingPaymentWhereInput>
  }

  export type RefundTransactionOrderByWithRelationInput = {
    id?: SortOrder
    paymentId?: SortOrder
    refundReference?: SortOrderInput | SortOrder
    refundAmount?: SortOrder
    refundReason?: SortOrderInput | SortOrder
    refundStatus?: SortOrder
    processorResponse?: SortOrderInput | SortOrder
    refundData?: SortOrderInput | SortOrder
    refundTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    bookingPayment?: BookingPaymentOrderByWithRelationInput
  }

  export type RefundTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    refundReference?: string
    AND?: RefundTransactionWhereInput | RefundTransactionWhereInput[]
    OR?: RefundTransactionWhereInput[]
    NOT?: RefundTransactionWhereInput | RefundTransactionWhereInput[]
    paymentId?: IntFilter<"RefundTransaction"> | number
    refundAmount?: DecimalFilter<"RefundTransaction"> | Decimal | DecimalJsLike | number | string
    refundReason?: StringNullableFilter<"RefundTransaction"> | string | null
    refundStatus?: StringFilter<"RefundTransaction"> | string
    processorResponse?: StringNullableFilter<"RefundTransaction"> | string | null
    refundData?: StringNullableFilter<"RefundTransaction"> | string | null
    refundTime?: DateTimeNullableFilter<"RefundTransaction"> | Date | string | null
    createdAt?: DateTimeFilter<"RefundTransaction"> | Date | string
    updatedAt?: DateTimeNullableFilter<"RefundTransaction"> | Date | string | null
    bookingPayment?: XOR<BookingPaymentScalarRelationFilter, BookingPaymentWhereInput>
  }, "id" | "refundReference">

  export type RefundTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    paymentId?: SortOrder
    refundReference?: SortOrderInput | SortOrder
    refundAmount?: SortOrder
    refundReason?: SortOrderInput | SortOrder
    refundStatus?: SortOrder
    processorResponse?: SortOrderInput | SortOrder
    refundData?: SortOrderInput | SortOrder
    refundTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: RefundTransactionCountOrderByAggregateInput
    _avg?: RefundTransactionAvgOrderByAggregateInput
    _max?: RefundTransactionMaxOrderByAggregateInput
    _min?: RefundTransactionMinOrderByAggregateInput
    _sum?: RefundTransactionSumOrderByAggregateInput
  }

  export type RefundTransactionScalarWhereWithAggregatesInput = {
    AND?: RefundTransactionScalarWhereWithAggregatesInput | RefundTransactionScalarWhereWithAggregatesInput[]
    OR?: RefundTransactionScalarWhereWithAggregatesInput[]
    NOT?: RefundTransactionScalarWhereWithAggregatesInput | RefundTransactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RefundTransaction"> | number
    paymentId?: IntWithAggregatesFilter<"RefundTransaction"> | number
    refundReference?: StringNullableWithAggregatesFilter<"RefundTransaction"> | string | null
    refundAmount?: DecimalWithAggregatesFilter<"RefundTransaction"> | Decimal | DecimalJsLike | number | string
    refundReason?: StringNullableWithAggregatesFilter<"RefundTransaction"> | string | null
    refundStatus?: StringWithAggregatesFilter<"RefundTransaction"> | string
    processorResponse?: StringNullableWithAggregatesFilter<"RefundTransaction"> | string | null
    refundData?: StringNullableWithAggregatesFilter<"RefundTransaction"> | string | null
    refundTime?: DateTimeNullableWithAggregatesFilter<"RefundTransaction"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RefundTransaction"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"RefundTransaction"> | Date | string | null
  }

  export type PaymentMethodWhereInput = {
    AND?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    OR?: PaymentMethodWhereInput[]
    NOT?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    id?: IntFilter<"PaymentMethod"> | number
    methodName?: StringFilter<"PaymentMethod"> | string
    provider?: StringFilter<"PaymentMethod"> | string
    methodType?: StringFilter<"PaymentMethod"> | string
    description?: StringNullableFilter<"PaymentMethod"> | string | null
    processingFeePercent?: DecimalFilter<"PaymentMethod"> | Decimal | DecimalJsLike | number | string
    fixedFee?: DecimalFilter<"PaymentMethod"> | Decimal | DecimalJsLike | number | string
    supportsRefunds?: BoolFilter<"PaymentMethod"> | boolean
    isActive?: BoolFilter<"PaymentMethod"> | boolean
    createdAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeNullableFilter<"PaymentMethod"> | Date | string | null
    paymentTransactions?: PaymentTransactionListRelationFilter
    userPaymentMethods?: UserPaymentMethodListRelationFilter
    parkingPassPayments?: ParkingPassPaymentListRelationFilter
  }

  export type PaymentMethodOrderByWithRelationInput = {
    id?: SortOrder
    methodName?: SortOrder
    provider?: SortOrder
    methodType?: SortOrder
    description?: SortOrderInput | SortOrder
    processingFeePercent?: SortOrder
    fixedFee?: SortOrder
    supportsRefunds?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    paymentTransactions?: PaymentTransactionOrderByRelationAggregateInput
    userPaymentMethods?: UserPaymentMethodOrderByRelationAggregateInput
    parkingPassPayments?: ParkingPassPaymentOrderByRelationAggregateInput
  }

  export type PaymentMethodWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    OR?: PaymentMethodWhereInput[]
    NOT?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    methodName?: StringFilter<"PaymentMethod"> | string
    provider?: StringFilter<"PaymentMethod"> | string
    methodType?: StringFilter<"PaymentMethod"> | string
    description?: StringNullableFilter<"PaymentMethod"> | string | null
    processingFeePercent?: DecimalFilter<"PaymentMethod"> | Decimal | DecimalJsLike | number | string
    fixedFee?: DecimalFilter<"PaymentMethod"> | Decimal | DecimalJsLike | number | string
    supportsRefunds?: BoolFilter<"PaymentMethod"> | boolean
    isActive?: BoolFilter<"PaymentMethod"> | boolean
    createdAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeNullableFilter<"PaymentMethod"> | Date | string | null
    paymentTransactions?: PaymentTransactionListRelationFilter
    userPaymentMethods?: UserPaymentMethodListRelationFilter
    parkingPassPayments?: ParkingPassPaymentListRelationFilter
  }, "id">

  export type PaymentMethodOrderByWithAggregationInput = {
    id?: SortOrder
    methodName?: SortOrder
    provider?: SortOrder
    methodType?: SortOrder
    description?: SortOrderInput | SortOrder
    processingFeePercent?: SortOrder
    fixedFee?: SortOrder
    supportsRefunds?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: PaymentMethodCountOrderByAggregateInput
    _avg?: PaymentMethodAvgOrderByAggregateInput
    _max?: PaymentMethodMaxOrderByAggregateInput
    _min?: PaymentMethodMinOrderByAggregateInput
    _sum?: PaymentMethodSumOrderByAggregateInput
  }

  export type PaymentMethodScalarWhereWithAggregatesInput = {
    AND?: PaymentMethodScalarWhereWithAggregatesInput | PaymentMethodScalarWhereWithAggregatesInput[]
    OR?: PaymentMethodScalarWhereWithAggregatesInput[]
    NOT?: PaymentMethodScalarWhereWithAggregatesInput | PaymentMethodScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PaymentMethod"> | number
    methodName?: StringWithAggregatesFilter<"PaymentMethod"> | string
    provider?: StringWithAggregatesFilter<"PaymentMethod"> | string
    methodType?: StringWithAggregatesFilter<"PaymentMethod"> | string
    description?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    processingFeePercent?: DecimalWithAggregatesFilter<"PaymentMethod"> | Decimal | DecimalJsLike | number | string
    fixedFee?: DecimalWithAggregatesFilter<"PaymentMethod"> | Decimal | DecimalJsLike | number | string
    supportsRefunds?: BoolWithAggregatesFilter<"PaymentMethod"> | boolean
    isActive?: BoolWithAggregatesFilter<"PaymentMethod"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"PaymentMethod"> | Date | string | null
  }

  export type UserPaymentMethodWhereInput = {
    AND?: UserPaymentMethodWhereInput | UserPaymentMethodWhereInput[]
    OR?: UserPaymentMethodWhereInput[]
    NOT?: UserPaymentMethodWhereInput | UserPaymentMethodWhereInput[]
    id?: IntFilter<"UserPaymentMethod"> | number
    userId?: IntFilter<"UserPaymentMethod"> | number
    paymentMethodId?: IntFilter<"UserPaymentMethod"> | number
    tokenReference?: StringFilter<"UserPaymentMethod"> | string
    maskedInfo?: StringNullableFilter<"UserPaymentMethod"> | string | null
    expiryInfo?: StringNullableFilter<"UserPaymentMethod"> | string | null
    isDefault?: BoolFilter<"UserPaymentMethod"> | boolean
    isVerified?: BoolFilter<"UserPaymentMethod"> | boolean
    createdAt?: DateTimeFilter<"UserPaymentMethod"> | Date | string
    updatedAt?: DateTimeNullableFilter<"UserPaymentMethod"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    paymentMethod?: XOR<PaymentMethodScalarRelationFilter, PaymentMethodWhereInput>
  }

  export type UserPaymentMethodOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    paymentMethodId?: SortOrder
    tokenReference?: SortOrder
    maskedInfo?: SortOrderInput | SortOrder
    expiryInfo?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    paymentMethod?: PaymentMethodOrderByWithRelationInput
  }

  export type UserPaymentMethodWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserPaymentMethodWhereInput | UserPaymentMethodWhereInput[]
    OR?: UserPaymentMethodWhereInput[]
    NOT?: UserPaymentMethodWhereInput | UserPaymentMethodWhereInput[]
    userId?: IntFilter<"UserPaymentMethod"> | number
    paymentMethodId?: IntFilter<"UserPaymentMethod"> | number
    tokenReference?: StringFilter<"UserPaymentMethod"> | string
    maskedInfo?: StringNullableFilter<"UserPaymentMethod"> | string | null
    expiryInfo?: StringNullableFilter<"UserPaymentMethod"> | string | null
    isDefault?: BoolFilter<"UserPaymentMethod"> | boolean
    isVerified?: BoolFilter<"UserPaymentMethod"> | boolean
    createdAt?: DateTimeFilter<"UserPaymentMethod"> | Date | string
    updatedAt?: DateTimeNullableFilter<"UserPaymentMethod"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    paymentMethod?: XOR<PaymentMethodScalarRelationFilter, PaymentMethodWhereInput>
  }, "id">

  export type UserPaymentMethodOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    paymentMethodId?: SortOrder
    tokenReference?: SortOrder
    maskedInfo?: SortOrderInput | SortOrder
    expiryInfo?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: UserPaymentMethodCountOrderByAggregateInput
    _avg?: UserPaymentMethodAvgOrderByAggregateInput
    _max?: UserPaymentMethodMaxOrderByAggregateInput
    _min?: UserPaymentMethodMinOrderByAggregateInput
    _sum?: UserPaymentMethodSumOrderByAggregateInput
  }

  export type UserPaymentMethodScalarWhereWithAggregatesInput = {
    AND?: UserPaymentMethodScalarWhereWithAggregatesInput | UserPaymentMethodScalarWhereWithAggregatesInput[]
    OR?: UserPaymentMethodScalarWhereWithAggregatesInput[]
    NOT?: UserPaymentMethodScalarWhereWithAggregatesInput | UserPaymentMethodScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserPaymentMethod"> | number
    userId?: IntWithAggregatesFilter<"UserPaymentMethod"> | number
    paymentMethodId?: IntWithAggregatesFilter<"UserPaymentMethod"> | number
    tokenReference?: StringWithAggregatesFilter<"UserPaymentMethod"> | string
    maskedInfo?: StringNullableWithAggregatesFilter<"UserPaymentMethod"> | string | null
    expiryInfo?: StringNullableWithAggregatesFilter<"UserPaymentMethod"> | string | null
    isDefault?: BoolWithAggregatesFilter<"UserPaymentMethod"> | boolean
    isVerified?: BoolWithAggregatesFilter<"UserPaymentMethod"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserPaymentMethod"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"UserPaymentMethod"> | Date | string | null
  }

  export type PromoCodeWhereInput = {
    AND?: PromoCodeWhereInput | PromoCodeWhereInput[]
    OR?: PromoCodeWhereInput[]
    NOT?: PromoCodeWhereInput | PromoCodeWhereInput[]
    id?: IntFilter<"PromoCode"> | number
    code?: StringFilter<"PromoCode"> | string
    description?: StringNullableFilter<"PromoCode"> | string | null
    discountType?: StringFilter<"PromoCode"> | string
    discountValue?: DecimalFilter<"PromoCode"> | Decimal | DecimalJsLike | number | string
    minimumSpend?: DecimalFilter<"PromoCode"> | Decimal | DecimalJsLike | number | string
    validFrom?: DateTimeFilter<"PromoCode"> | Date | string
    validUntil?: DateTimeNullableFilter<"PromoCode"> | Date | string | null
    usageLimit?: IntNullableFilter<"PromoCode"> | number | null
    usageCount?: IntFilter<"PromoCode"> | number
    isActive?: BoolFilter<"PromoCode"> | boolean
    createdAt?: DateTimeFilter<"PromoCode"> | Date | string
    updatedAt?: DateTimeNullableFilter<"PromoCode"> | Date | string | null
    bookings?: BookingListRelationFilter
  }

  export type PromoCodeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    minimumSpend?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrderInput | SortOrder
    usageLimit?: SortOrderInput | SortOrder
    usageCount?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    bookings?: BookingOrderByRelationAggregateInput
  }

  export type PromoCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: PromoCodeWhereInput | PromoCodeWhereInput[]
    OR?: PromoCodeWhereInput[]
    NOT?: PromoCodeWhereInput | PromoCodeWhereInput[]
    description?: StringNullableFilter<"PromoCode"> | string | null
    discountType?: StringFilter<"PromoCode"> | string
    discountValue?: DecimalFilter<"PromoCode"> | Decimal | DecimalJsLike | number | string
    minimumSpend?: DecimalFilter<"PromoCode"> | Decimal | DecimalJsLike | number | string
    validFrom?: DateTimeFilter<"PromoCode"> | Date | string
    validUntil?: DateTimeNullableFilter<"PromoCode"> | Date | string | null
    usageLimit?: IntNullableFilter<"PromoCode"> | number | null
    usageCount?: IntFilter<"PromoCode"> | number
    isActive?: BoolFilter<"PromoCode"> | boolean
    createdAt?: DateTimeFilter<"PromoCode"> | Date | string
    updatedAt?: DateTimeNullableFilter<"PromoCode"> | Date | string | null
    bookings?: BookingListRelationFilter
  }, "id" | "code">

  export type PromoCodeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    minimumSpend?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrderInput | SortOrder
    usageLimit?: SortOrderInput | SortOrder
    usageCount?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: PromoCodeCountOrderByAggregateInput
    _avg?: PromoCodeAvgOrderByAggregateInput
    _max?: PromoCodeMaxOrderByAggregateInput
    _min?: PromoCodeMinOrderByAggregateInput
    _sum?: PromoCodeSumOrderByAggregateInput
  }

  export type PromoCodeScalarWhereWithAggregatesInput = {
    AND?: PromoCodeScalarWhereWithAggregatesInput | PromoCodeScalarWhereWithAggregatesInput[]
    OR?: PromoCodeScalarWhereWithAggregatesInput[]
    NOT?: PromoCodeScalarWhereWithAggregatesInput | PromoCodeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PromoCode"> | number
    code?: StringWithAggregatesFilter<"PromoCode"> | string
    description?: StringNullableWithAggregatesFilter<"PromoCode"> | string | null
    discountType?: StringWithAggregatesFilter<"PromoCode"> | string
    discountValue?: DecimalWithAggregatesFilter<"PromoCode"> | Decimal | DecimalJsLike | number | string
    minimumSpend?: DecimalWithAggregatesFilter<"PromoCode"> | Decimal | DecimalJsLike | number | string
    validFrom?: DateTimeWithAggregatesFilter<"PromoCode"> | Date | string
    validUntil?: DateTimeNullableWithAggregatesFilter<"PromoCode"> | Date | string | null
    usageLimit?: IntNullableWithAggregatesFilter<"PromoCode"> | number | null
    usageCount?: IntWithAggregatesFilter<"PromoCode"> | number
    isActive?: BoolWithAggregatesFilter<"PromoCode"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PromoCode"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"PromoCode"> | Date | string | null
  }

  export type ParkingPassWhereInput = {
    AND?: ParkingPassWhereInput | ParkingPassWhereInput[]
    OR?: ParkingPassWhereInput[]
    NOT?: ParkingPassWhereInput | ParkingPassWhereInput[]
    id?: IntFilter<"ParkingPass"> | number
    userId?: IntFilter<"ParkingPass"> | number
    placeId?: IntFilter<"ParkingPass"> | number
    passType?: StringFilter<"ParkingPass"> | string
    passReference?: StringNullableFilter<"ParkingPass"> | string | null
    startDate?: DateTimeFilter<"ParkingPass"> | Date | string
    endDate?: DateTimeFilter<"ParkingPass"> | Date | string
    price?: DecimalFilter<"ParkingPass"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"ParkingPass"> | string
    autoRenew?: BoolFilter<"ParkingPass"> | boolean
    createdAt?: DateTimeFilter<"ParkingPass"> | Date | string
    updatedAt?: DateTimeNullableFilter<"ParkingPass"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    place?: XOR<PlaceScalarRelationFilter, PlaceWhereInput>
    parkingPassPayments?: ParkingPassPaymentListRelationFilter
  }

  export type ParkingPassOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    placeId?: SortOrder
    passType?: SortOrder
    passReference?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    price?: SortOrder
    status?: SortOrder
    autoRenew?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    place?: PlaceOrderByWithRelationInput
    parkingPassPayments?: ParkingPassPaymentOrderByRelationAggregateInput
  }

  export type ParkingPassWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    passReference?: string
    AND?: ParkingPassWhereInput | ParkingPassWhereInput[]
    OR?: ParkingPassWhereInput[]
    NOT?: ParkingPassWhereInput | ParkingPassWhereInput[]
    userId?: IntFilter<"ParkingPass"> | number
    placeId?: IntFilter<"ParkingPass"> | number
    passType?: StringFilter<"ParkingPass"> | string
    startDate?: DateTimeFilter<"ParkingPass"> | Date | string
    endDate?: DateTimeFilter<"ParkingPass"> | Date | string
    price?: DecimalFilter<"ParkingPass"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"ParkingPass"> | string
    autoRenew?: BoolFilter<"ParkingPass"> | boolean
    createdAt?: DateTimeFilter<"ParkingPass"> | Date | string
    updatedAt?: DateTimeNullableFilter<"ParkingPass"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    place?: XOR<PlaceScalarRelationFilter, PlaceWhereInput>
    parkingPassPayments?: ParkingPassPaymentListRelationFilter
  }, "id" | "passReference">

  export type ParkingPassOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    placeId?: SortOrder
    passType?: SortOrder
    passReference?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    price?: SortOrder
    status?: SortOrder
    autoRenew?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: ParkingPassCountOrderByAggregateInput
    _avg?: ParkingPassAvgOrderByAggregateInput
    _max?: ParkingPassMaxOrderByAggregateInput
    _min?: ParkingPassMinOrderByAggregateInput
    _sum?: ParkingPassSumOrderByAggregateInput
  }

  export type ParkingPassScalarWhereWithAggregatesInput = {
    AND?: ParkingPassScalarWhereWithAggregatesInput | ParkingPassScalarWhereWithAggregatesInput[]
    OR?: ParkingPassScalarWhereWithAggregatesInput[]
    NOT?: ParkingPassScalarWhereWithAggregatesInput | ParkingPassScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ParkingPass"> | number
    userId?: IntWithAggregatesFilter<"ParkingPass"> | number
    placeId?: IntWithAggregatesFilter<"ParkingPass"> | number
    passType?: StringWithAggregatesFilter<"ParkingPass"> | string
    passReference?: StringNullableWithAggregatesFilter<"ParkingPass"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"ParkingPass"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"ParkingPass"> | Date | string
    price?: DecimalWithAggregatesFilter<"ParkingPass"> | Decimal | DecimalJsLike | number | string
    status?: StringWithAggregatesFilter<"ParkingPass"> | string
    autoRenew?: BoolWithAggregatesFilter<"ParkingPass"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ParkingPass"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"ParkingPass"> | Date | string | null
  }

  export type ParkingPassPaymentWhereInput = {
    AND?: ParkingPassPaymentWhereInput | ParkingPassPaymentWhereInput[]
    OR?: ParkingPassPaymentWhereInput[]
    NOT?: ParkingPassPaymentWhereInput | ParkingPassPaymentWhereInput[]
    id?: IntFilter<"ParkingPassPayment"> | number
    passId?: IntFilter<"ParkingPassPayment"> | number
    paymentMethodId?: IntFilter<"ParkingPassPayment"> | number
    amount?: DecimalFilter<"ParkingPassPayment"> | Decimal | DecimalJsLike | number | string
    paymentStatus?: StringFilter<"ParkingPassPayment"> | string
    transactionReference?: StringNullableFilter<"ParkingPassPayment"> | string | null
    paymentDate?: DateTimeNullableFilter<"ParkingPassPayment"> | Date | string | null
    createdAt?: DateTimeFilter<"ParkingPassPayment"> | Date | string
    updatedAt?: DateTimeNullableFilter<"ParkingPassPayment"> | Date | string | null
    parkingPass?: XOR<ParkingPassScalarRelationFilter, ParkingPassWhereInput>
    paymentMethod?: XOR<PaymentMethodScalarRelationFilter, PaymentMethodWhereInput>
  }

  export type ParkingPassPaymentOrderByWithRelationInput = {
    id?: SortOrder
    passId?: SortOrder
    paymentMethodId?: SortOrder
    amount?: SortOrder
    paymentStatus?: SortOrder
    transactionReference?: SortOrderInput | SortOrder
    paymentDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    parkingPass?: ParkingPassOrderByWithRelationInput
    paymentMethod?: PaymentMethodOrderByWithRelationInput
  }

  export type ParkingPassPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    transactionReference?: string
    AND?: ParkingPassPaymentWhereInput | ParkingPassPaymentWhereInput[]
    OR?: ParkingPassPaymentWhereInput[]
    NOT?: ParkingPassPaymentWhereInput | ParkingPassPaymentWhereInput[]
    passId?: IntFilter<"ParkingPassPayment"> | number
    paymentMethodId?: IntFilter<"ParkingPassPayment"> | number
    amount?: DecimalFilter<"ParkingPassPayment"> | Decimal | DecimalJsLike | number | string
    paymentStatus?: StringFilter<"ParkingPassPayment"> | string
    paymentDate?: DateTimeNullableFilter<"ParkingPassPayment"> | Date | string | null
    createdAt?: DateTimeFilter<"ParkingPassPayment"> | Date | string
    updatedAt?: DateTimeNullableFilter<"ParkingPassPayment"> | Date | string | null
    parkingPass?: XOR<ParkingPassScalarRelationFilter, ParkingPassWhereInput>
    paymentMethod?: XOR<PaymentMethodScalarRelationFilter, PaymentMethodWhereInput>
  }, "id" | "transactionReference">

  export type ParkingPassPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    passId?: SortOrder
    paymentMethodId?: SortOrder
    amount?: SortOrder
    paymentStatus?: SortOrder
    transactionReference?: SortOrderInput | SortOrder
    paymentDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: ParkingPassPaymentCountOrderByAggregateInput
    _avg?: ParkingPassPaymentAvgOrderByAggregateInput
    _max?: ParkingPassPaymentMaxOrderByAggregateInput
    _min?: ParkingPassPaymentMinOrderByAggregateInput
    _sum?: ParkingPassPaymentSumOrderByAggregateInput
  }

  export type ParkingPassPaymentScalarWhereWithAggregatesInput = {
    AND?: ParkingPassPaymentScalarWhereWithAggregatesInput | ParkingPassPaymentScalarWhereWithAggregatesInput[]
    OR?: ParkingPassPaymentScalarWhereWithAggregatesInput[]
    NOT?: ParkingPassPaymentScalarWhereWithAggregatesInput | ParkingPassPaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ParkingPassPayment"> | number
    passId?: IntWithAggregatesFilter<"ParkingPassPayment"> | number
    paymentMethodId?: IntWithAggregatesFilter<"ParkingPassPayment"> | number
    amount?: DecimalWithAggregatesFilter<"ParkingPassPayment"> | Decimal | DecimalJsLike | number | string
    paymentStatus?: StringWithAggregatesFilter<"ParkingPassPayment"> | string
    transactionReference?: StringNullableWithAggregatesFilter<"ParkingPassPayment"> | string | null
    paymentDate?: DateTimeNullableWithAggregatesFilter<"ParkingPassPayment"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ParkingPassPayment"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"ParkingPassPayment"> | Date | string | null
  }

  export type AccessLogWhereInput = {
    AND?: AccessLogWhereInput | AccessLogWhereInput[]
    OR?: AccessLogWhereInput[]
    NOT?: AccessLogWhereInput | AccessLogWhereInput[]
    id?: IntFilter<"AccessLog"> | number
    bookingId?: IntFilter<"AccessLog"> | number
    logType?: StringFilter<"AccessLog"> | string
    logTime?: DateTimeFilter<"AccessLog"> | Date | string
    verificationMethod?: StringNullableFilter<"AccessLog"> | string | null
    verifiedBy?: StringNullableFilter<"AccessLog"> | string | null
    location?: StringNullableFilter<"AccessLog"> | string | null
    notes?: StringNullableFilter<"AccessLog"> | string | null
    createdAt?: DateTimeFilter<"AccessLog"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
  }

  export type AccessLogOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    logType?: SortOrder
    logTime?: SortOrder
    verificationMethod?: SortOrderInput | SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    booking?: BookingOrderByWithRelationInput
  }

  export type AccessLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AccessLogWhereInput | AccessLogWhereInput[]
    OR?: AccessLogWhereInput[]
    NOT?: AccessLogWhereInput | AccessLogWhereInput[]
    bookingId?: IntFilter<"AccessLog"> | number
    logType?: StringFilter<"AccessLog"> | string
    logTime?: DateTimeFilter<"AccessLog"> | Date | string
    verificationMethod?: StringNullableFilter<"AccessLog"> | string | null
    verifiedBy?: StringNullableFilter<"AccessLog"> | string | null
    location?: StringNullableFilter<"AccessLog"> | string | null
    notes?: StringNullableFilter<"AccessLog"> | string | null
    createdAt?: DateTimeFilter<"AccessLog"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
  }, "id">

  export type AccessLogOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    logType?: SortOrder
    logTime?: SortOrder
    verificationMethod?: SortOrderInput | SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AccessLogCountOrderByAggregateInput
    _avg?: AccessLogAvgOrderByAggregateInput
    _max?: AccessLogMaxOrderByAggregateInput
    _min?: AccessLogMinOrderByAggregateInput
    _sum?: AccessLogSumOrderByAggregateInput
  }

  export type AccessLogScalarWhereWithAggregatesInput = {
    AND?: AccessLogScalarWhereWithAggregatesInput | AccessLogScalarWhereWithAggregatesInput[]
    OR?: AccessLogScalarWhereWithAggregatesInput[]
    NOT?: AccessLogScalarWhereWithAggregatesInput | AccessLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AccessLog"> | number
    bookingId?: IntWithAggregatesFilter<"AccessLog"> | number
    logType?: StringWithAggregatesFilter<"AccessLog"> | string
    logTime?: DateTimeWithAggregatesFilter<"AccessLog"> | Date | string
    verificationMethod?: StringNullableWithAggregatesFilter<"AccessLog"> | string | null
    verifiedBy?: StringNullableWithAggregatesFilter<"AccessLog"> | string | null
    location?: StringNullableWithAggregatesFilter<"AccessLog"> | string | null
    notes?: StringNullableWithAggregatesFilter<"AccessLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AccessLog"> | Date | string
  }

  export type BookingExtensionWhereInput = {
    AND?: BookingExtensionWhereInput | BookingExtensionWhereInput[]
    OR?: BookingExtensionWhereInput[]
    NOT?: BookingExtensionWhereInput | BookingExtensionWhereInput[]
    id?: IntFilter<"BookingExtension"> | number
    bookingId?: IntFilter<"BookingExtension"> | number
    originalEndTime?: DateTimeFilter<"BookingExtension"> | Date | string
    newEndTime?: DateTimeFilter<"BookingExtension"> | Date | string
    additionalCharge?: DecimalFilter<"BookingExtension"> | Decimal | DecimalJsLike | number | string
    paymentStatus?: StringFilter<"BookingExtension"> | string
    requestTime?: DateTimeFilter<"BookingExtension"> | Date | string
    createdAt?: DateTimeFilter<"BookingExtension"> | Date | string
    updatedAt?: DateTimeNullableFilter<"BookingExtension"> | Date | string | null
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
  }

  export type BookingExtensionOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    originalEndTime?: SortOrder
    newEndTime?: SortOrder
    additionalCharge?: SortOrder
    paymentStatus?: SortOrder
    requestTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    booking?: BookingOrderByWithRelationInput
  }

  export type BookingExtensionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BookingExtensionWhereInput | BookingExtensionWhereInput[]
    OR?: BookingExtensionWhereInput[]
    NOT?: BookingExtensionWhereInput | BookingExtensionWhereInput[]
    bookingId?: IntFilter<"BookingExtension"> | number
    originalEndTime?: DateTimeFilter<"BookingExtension"> | Date | string
    newEndTime?: DateTimeFilter<"BookingExtension"> | Date | string
    additionalCharge?: DecimalFilter<"BookingExtension"> | Decimal | DecimalJsLike | number | string
    paymentStatus?: StringFilter<"BookingExtension"> | string
    requestTime?: DateTimeFilter<"BookingExtension"> | Date | string
    createdAt?: DateTimeFilter<"BookingExtension"> | Date | string
    updatedAt?: DateTimeNullableFilter<"BookingExtension"> | Date | string | null
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
  }, "id">

  export type BookingExtensionOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    originalEndTime?: SortOrder
    newEndTime?: SortOrder
    additionalCharge?: SortOrder
    paymentStatus?: SortOrder
    requestTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: BookingExtensionCountOrderByAggregateInput
    _avg?: BookingExtensionAvgOrderByAggregateInput
    _max?: BookingExtensionMaxOrderByAggregateInput
    _min?: BookingExtensionMinOrderByAggregateInput
    _sum?: BookingExtensionSumOrderByAggregateInput
  }

  export type BookingExtensionScalarWhereWithAggregatesInput = {
    AND?: BookingExtensionScalarWhereWithAggregatesInput | BookingExtensionScalarWhereWithAggregatesInput[]
    OR?: BookingExtensionScalarWhereWithAggregatesInput[]
    NOT?: BookingExtensionScalarWhereWithAggregatesInput | BookingExtensionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BookingExtension"> | number
    bookingId?: IntWithAggregatesFilter<"BookingExtension"> | number
    originalEndTime?: DateTimeWithAggregatesFilter<"BookingExtension"> | Date | string
    newEndTime?: DateTimeWithAggregatesFilter<"BookingExtension"> | Date | string
    additionalCharge?: DecimalWithAggregatesFilter<"BookingExtension"> | Decimal | DecimalJsLike | number | string
    paymentStatus?: StringWithAggregatesFilter<"BookingExtension"> | string
    requestTime?: DateTimeWithAggregatesFilter<"BookingExtension"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"BookingExtension"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"BookingExtension"> | Date | string | null
  }

  export type NotificationSettingWhereInput = {
    AND?: NotificationSettingWhereInput | NotificationSettingWhereInput[]
    OR?: NotificationSettingWhereInput[]
    NOT?: NotificationSettingWhereInput | NotificationSettingWhereInput[]
    id?: IntFilter<"NotificationSetting"> | number
    userId?: IntFilter<"NotificationSetting"> | number
    emailEnabled?: BoolFilter<"NotificationSetting"> | boolean
    smsEnabled?: BoolFilter<"NotificationSetting"> | boolean
    pushEnabled?: BoolFilter<"NotificationSetting"> | boolean
    bookingConfirmation?: BoolFilter<"NotificationSetting"> | boolean
    paymentNotifications?: BoolFilter<"NotificationSetting"> | boolean
    reminderNotifications?: BoolFilter<"NotificationSetting"> | boolean
    marketingNotifications?: BoolFilter<"NotificationSetting"> | boolean
    createdAt?: DateTimeFilter<"NotificationSetting"> | Date | string
    updatedAt?: DateTimeNullableFilter<"NotificationSetting"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationSettingOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    emailEnabled?: SortOrder
    smsEnabled?: SortOrder
    pushEnabled?: SortOrder
    bookingConfirmation?: SortOrder
    paymentNotifications?: SortOrder
    reminderNotifications?: SortOrder
    marketingNotifications?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationSettingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: NotificationSettingWhereInput | NotificationSettingWhereInput[]
    OR?: NotificationSettingWhereInput[]
    NOT?: NotificationSettingWhereInput | NotificationSettingWhereInput[]
    emailEnabled?: BoolFilter<"NotificationSetting"> | boolean
    smsEnabled?: BoolFilter<"NotificationSetting"> | boolean
    pushEnabled?: BoolFilter<"NotificationSetting"> | boolean
    bookingConfirmation?: BoolFilter<"NotificationSetting"> | boolean
    paymentNotifications?: BoolFilter<"NotificationSetting"> | boolean
    reminderNotifications?: BoolFilter<"NotificationSetting"> | boolean
    marketingNotifications?: BoolFilter<"NotificationSetting"> | boolean
    createdAt?: DateTimeFilter<"NotificationSetting"> | Date | string
    updatedAt?: DateTimeNullableFilter<"NotificationSetting"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type NotificationSettingOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    emailEnabled?: SortOrder
    smsEnabled?: SortOrder
    pushEnabled?: SortOrder
    bookingConfirmation?: SortOrder
    paymentNotifications?: SortOrder
    reminderNotifications?: SortOrder
    marketingNotifications?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: NotificationSettingCountOrderByAggregateInput
    _avg?: NotificationSettingAvgOrderByAggregateInput
    _max?: NotificationSettingMaxOrderByAggregateInput
    _min?: NotificationSettingMinOrderByAggregateInput
    _sum?: NotificationSettingSumOrderByAggregateInput
  }

  export type NotificationSettingScalarWhereWithAggregatesInput = {
    AND?: NotificationSettingScalarWhereWithAggregatesInput | NotificationSettingScalarWhereWithAggregatesInput[]
    OR?: NotificationSettingScalarWhereWithAggregatesInput[]
    NOT?: NotificationSettingScalarWhereWithAggregatesInput | NotificationSettingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"NotificationSetting"> | number
    userId?: IntWithAggregatesFilter<"NotificationSetting"> | number
    emailEnabled?: BoolWithAggregatesFilter<"NotificationSetting"> | boolean
    smsEnabled?: BoolWithAggregatesFilter<"NotificationSetting"> | boolean
    pushEnabled?: BoolWithAggregatesFilter<"NotificationSetting"> | boolean
    bookingConfirmation?: BoolWithAggregatesFilter<"NotificationSetting"> | boolean
    paymentNotifications?: BoolWithAggregatesFilter<"NotificationSetting"> | boolean
    reminderNotifications?: BoolWithAggregatesFilter<"NotificationSetting"> | boolean
    marketingNotifications?: BoolWithAggregatesFilter<"NotificationSetting"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"NotificationSetting"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"NotificationSetting"> | Date | string | null
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: IntFilter<"Notification"> | number
    userId?: IntFilter<"Notification"> | number
    bookingId?: IntNullableFilter<"Notification"> | number | null
    notificationType?: StringFilter<"Notification"> | string
    channel?: StringFilter<"Notification"> | string
    content?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    sentTime?: DateTimeFilter<"Notification"> | Date | string
    readTime?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    booking?: XOR<BookingNullableScalarRelationFilter, BookingWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    bookingId?: SortOrderInput | SortOrder
    notificationType?: SortOrder
    channel?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    sentTime?: SortOrder
    readTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    booking?: BookingOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: IntFilter<"Notification"> | number
    bookingId?: IntNullableFilter<"Notification"> | number | null
    notificationType?: StringFilter<"Notification"> | string
    channel?: StringFilter<"Notification"> | string
    content?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    sentTime?: DateTimeFilter<"Notification"> | Date | string
    readTime?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    booking?: XOR<BookingNullableScalarRelationFilter, BookingWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    bookingId?: SortOrderInput | SortOrder
    notificationType?: SortOrder
    channel?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    sentTime?: SortOrder
    readTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notification"> | number
    userId?: IntWithAggregatesFilter<"Notification"> | number
    bookingId?: IntNullableWithAggregatesFilter<"Notification"> | number | null
    notificationType?: StringWithAggregatesFilter<"Notification"> | string
    channel?: StringWithAggregatesFilter<"Notification"> | string
    content?: StringWithAggregatesFilter<"Notification"> | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    sentTime?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    readTime?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type PlaceRatingWhereInput = {
    AND?: PlaceRatingWhereInput | PlaceRatingWhereInput[]
    OR?: PlaceRatingWhereInput[]
    NOT?: PlaceRatingWhereInput | PlaceRatingWhereInput[]
    id?: IntFilter<"PlaceRating"> | number
    placeId?: IntFilter<"PlaceRating"> | number
    userId?: IntFilter<"PlaceRating"> | number
    bookingId?: IntFilter<"PlaceRating"> | number
    ratingScore?: DecimalFilter<"PlaceRating"> | Decimal | DecimalJsLike | number | string
    reviewComment?: StringNullableFilter<"PlaceRating"> | string | null
    ratingDate?: DateTimeFilter<"PlaceRating"> | Date | string
    isVerified?: BoolFilter<"PlaceRating"> | boolean
    createdAt?: DateTimeFilter<"PlaceRating"> | Date | string
    updatedAt?: DateTimeNullableFilter<"PlaceRating"> | Date | string | null
    place?: XOR<PlaceScalarRelationFilter, PlaceWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
  }

  export type PlaceRatingOrderByWithRelationInput = {
    id?: SortOrder
    placeId?: SortOrder
    userId?: SortOrder
    bookingId?: SortOrder
    ratingScore?: SortOrder
    reviewComment?: SortOrderInput | SortOrder
    ratingDate?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    place?: PlaceOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    booking?: BookingOrderByWithRelationInput
  }

  export type PlaceRatingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PlaceRatingWhereInput | PlaceRatingWhereInput[]
    OR?: PlaceRatingWhereInput[]
    NOT?: PlaceRatingWhereInput | PlaceRatingWhereInput[]
    placeId?: IntFilter<"PlaceRating"> | number
    userId?: IntFilter<"PlaceRating"> | number
    bookingId?: IntFilter<"PlaceRating"> | number
    ratingScore?: DecimalFilter<"PlaceRating"> | Decimal | DecimalJsLike | number | string
    reviewComment?: StringNullableFilter<"PlaceRating"> | string | null
    ratingDate?: DateTimeFilter<"PlaceRating"> | Date | string
    isVerified?: BoolFilter<"PlaceRating"> | boolean
    createdAt?: DateTimeFilter<"PlaceRating"> | Date | string
    updatedAt?: DateTimeNullableFilter<"PlaceRating"> | Date | string | null
    place?: XOR<PlaceScalarRelationFilter, PlaceWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
  }, "id">

  export type PlaceRatingOrderByWithAggregationInput = {
    id?: SortOrder
    placeId?: SortOrder
    userId?: SortOrder
    bookingId?: SortOrder
    ratingScore?: SortOrder
    reviewComment?: SortOrderInput | SortOrder
    ratingDate?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: PlaceRatingCountOrderByAggregateInput
    _avg?: PlaceRatingAvgOrderByAggregateInput
    _max?: PlaceRatingMaxOrderByAggregateInput
    _min?: PlaceRatingMinOrderByAggregateInput
    _sum?: PlaceRatingSumOrderByAggregateInput
  }

  export type PlaceRatingScalarWhereWithAggregatesInput = {
    AND?: PlaceRatingScalarWhereWithAggregatesInput | PlaceRatingScalarWhereWithAggregatesInput[]
    OR?: PlaceRatingScalarWhereWithAggregatesInput[]
    NOT?: PlaceRatingScalarWhereWithAggregatesInput | PlaceRatingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PlaceRating"> | number
    placeId?: IntWithAggregatesFilter<"PlaceRating"> | number
    userId?: IntWithAggregatesFilter<"PlaceRating"> | number
    bookingId?: IntWithAggregatesFilter<"PlaceRating"> | number
    ratingScore?: DecimalWithAggregatesFilter<"PlaceRating"> | Decimal | DecimalJsLike | number | string
    reviewComment?: StringNullableWithAggregatesFilter<"PlaceRating"> | string | null
    ratingDate?: DateTimeWithAggregatesFilter<"PlaceRating"> | Date | string
    isVerified?: BoolWithAggregatesFilter<"PlaceRating"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PlaceRating"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"PlaceRating"> | Date | string | null
  }

  export type OperatingHourWhereInput = {
    AND?: OperatingHourWhereInput | OperatingHourWhereInput[]
    OR?: OperatingHourWhereInput[]
    NOT?: OperatingHourWhereInput | OperatingHourWhereInput[]
    id?: IntFilter<"OperatingHour"> | number
    placeId?: IntFilter<"OperatingHour"> | number
    dayOfWeek?: StringFilter<"OperatingHour"> | string
    openingTime?: DateTimeNullableFilter<"OperatingHour"> | Date | string | null
    closingTime?: DateTimeNullableFilter<"OperatingHour"> | Date | string | null
    is24hours?: BoolFilter<"OperatingHour"> | boolean
    isClosed?: BoolFilter<"OperatingHour"> | boolean
    createdAt?: DateTimeFilter<"OperatingHour"> | Date | string
    updatedAt?: DateTimeNullableFilter<"OperatingHour"> | Date | string | null
    place?: XOR<PlaceScalarRelationFilter, PlaceWhereInput>
  }

  export type OperatingHourOrderByWithRelationInput = {
    id?: SortOrder
    placeId?: SortOrder
    dayOfWeek?: SortOrder
    openingTime?: SortOrderInput | SortOrder
    closingTime?: SortOrderInput | SortOrder
    is24hours?: SortOrder
    isClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    place?: PlaceOrderByWithRelationInput
  }

  export type OperatingHourWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OperatingHourWhereInput | OperatingHourWhereInput[]
    OR?: OperatingHourWhereInput[]
    NOT?: OperatingHourWhereInput | OperatingHourWhereInput[]
    placeId?: IntFilter<"OperatingHour"> | number
    dayOfWeek?: StringFilter<"OperatingHour"> | string
    openingTime?: DateTimeNullableFilter<"OperatingHour"> | Date | string | null
    closingTime?: DateTimeNullableFilter<"OperatingHour"> | Date | string | null
    is24hours?: BoolFilter<"OperatingHour"> | boolean
    isClosed?: BoolFilter<"OperatingHour"> | boolean
    createdAt?: DateTimeFilter<"OperatingHour"> | Date | string
    updatedAt?: DateTimeNullableFilter<"OperatingHour"> | Date | string | null
    place?: XOR<PlaceScalarRelationFilter, PlaceWhereInput>
  }, "id">

  export type OperatingHourOrderByWithAggregationInput = {
    id?: SortOrder
    placeId?: SortOrder
    dayOfWeek?: SortOrder
    openingTime?: SortOrderInput | SortOrder
    closingTime?: SortOrderInput | SortOrder
    is24hours?: SortOrder
    isClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: OperatingHourCountOrderByAggregateInput
    _avg?: OperatingHourAvgOrderByAggregateInput
    _max?: OperatingHourMaxOrderByAggregateInput
    _min?: OperatingHourMinOrderByAggregateInput
    _sum?: OperatingHourSumOrderByAggregateInput
  }

  export type OperatingHourScalarWhereWithAggregatesInput = {
    AND?: OperatingHourScalarWhereWithAggregatesInput | OperatingHourScalarWhereWithAggregatesInput[]
    OR?: OperatingHourScalarWhereWithAggregatesInput[]
    NOT?: OperatingHourScalarWhereWithAggregatesInput | OperatingHourScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OperatingHour"> | number
    placeId?: IntWithAggregatesFilter<"OperatingHour"> | number
    dayOfWeek?: StringWithAggregatesFilter<"OperatingHour"> | string
    openingTime?: DateTimeNullableWithAggregatesFilter<"OperatingHour"> | Date | string | null
    closingTime?: DateTimeNullableWithAggregatesFilter<"OperatingHour"> | Date | string | null
    is24hours?: BoolWithAggregatesFilter<"OperatingHour"> | boolean
    isClosed?: BoolWithAggregatesFilter<"OperatingHour"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"OperatingHour"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"OperatingHour"> | Date | string | null
  }

  export type PlaceAdminWhereInput = {
    AND?: PlaceAdminWhereInput | PlaceAdminWhereInput[]
    OR?: PlaceAdminWhereInput[]
    NOT?: PlaceAdminWhereInput | PlaceAdminWhereInput[]
    id?: IntFilter<"PlaceAdmin"> | number
    placeId?: IntFilter<"PlaceAdmin"> | number
    username?: StringFilter<"PlaceAdmin"> | string
    email?: StringFilter<"PlaceAdmin"> | string
    passwordHash?: StringFilter<"PlaceAdmin"> | string
    fullName?: StringFilter<"PlaceAdmin"> | string
    role?: StringFilter<"PlaceAdmin"> | string
    contactNumber?: StringNullableFilter<"PlaceAdmin"> | string | null
    isActive?: BoolFilter<"PlaceAdmin"> | boolean
    createdAt?: DateTimeFilter<"PlaceAdmin"> | Date | string
    updatedAt?: DateTimeNullableFilter<"PlaceAdmin"> | Date | string | null
    place?: XOR<PlaceScalarRelationFilter, PlaceWhereInput>
  }

  export type PlaceAdminOrderByWithRelationInput = {
    id?: SortOrder
    placeId?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    contactNumber?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    place?: PlaceOrderByWithRelationInput
  }

  export type PlaceAdminWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    email?: string
    AND?: PlaceAdminWhereInput | PlaceAdminWhereInput[]
    OR?: PlaceAdminWhereInput[]
    NOT?: PlaceAdminWhereInput | PlaceAdminWhereInput[]
    placeId?: IntFilter<"PlaceAdmin"> | number
    passwordHash?: StringFilter<"PlaceAdmin"> | string
    fullName?: StringFilter<"PlaceAdmin"> | string
    role?: StringFilter<"PlaceAdmin"> | string
    contactNumber?: StringNullableFilter<"PlaceAdmin"> | string | null
    isActive?: BoolFilter<"PlaceAdmin"> | boolean
    createdAt?: DateTimeFilter<"PlaceAdmin"> | Date | string
    updatedAt?: DateTimeNullableFilter<"PlaceAdmin"> | Date | string | null
    place?: XOR<PlaceScalarRelationFilter, PlaceWhereInput>
  }, "id" | "username" | "email">

  export type PlaceAdminOrderByWithAggregationInput = {
    id?: SortOrder
    placeId?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    contactNumber?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: PlaceAdminCountOrderByAggregateInput
    _avg?: PlaceAdminAvgOrderByAggregateInput
    _max?: PlaceAdminMaxOrderByAggregateInput
    _min?: PlaceAdminMinOrderByAggregateInput
    _sum?: PlaceAdminSumOrderByAggregateInput
  }

  export type PlaceAdminScalarWhereWithAggregatesInput = {
    AND?: PlaceAdminScalarWhereWithAggregatesInput | PlaceAdminScalarWhereWithAggregatesInput[]
    OR?: PlaceAdminScalarWhereWithAggregatesInput[]
    NOT?: PlaceAdminScalarWhereWithAggregatesInput | PlaceAdminScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PlaceAdmin"> | number
    placeId?: IntWithAggregatesFilter<"PlaceAdmin"> | number
    username?: StringWithAggregatesFilter<"PlaceAdmin"> | string
    email?: StringWithAggregatesFilter<"PlaceAdmin"> | string
    passwordHash?: StringWithAggregatesFilter<"PlaceAdmin"> | string
    fullName?: StringWithAggregatesFilter<"PlaceAdmin"> | string
    role?: StringWithAggregatesFilter<"PlaceAdmin"> | string
    contactNumber?: StringNullableWithAggregatesFilter<"PlaceAdmin"> | string | null
    isActive?: BoolWithAggregatesFilter<"PlaceAdmin"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PlaceAdmin"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"PlaceAdmin"> | Date | string | null
  }

  export type SystemLogWhereInput = {
    AND?: SystemLogWhereInput | SystemLogWhereInput[]
    OR?: SystemLogWhereInput[]
    NOT?: SystemLogWhereInput | SystemLogWhereInput[]
    id?: IntFilter<"SystemLog"> | number
    entityType?: StringFilter<"SystemLog"> | string
    entityId?: IntFilter<"SystemLog"> | number
    action?: StringFilter<"SystemLog"> | string
    performedBy?: StringFilter<"SystemLog"> | string
    logLevel?: StringFilter<"SystemLog"> | string
    logDetails?: StringNullableFilter<"SystemLog"> | string | null
    logTime?: DateTimeFilter<"SystemLog"> | Date | string
    createdAt?: DateTimeFilter<"SystemLog"> | Date | string
  }

  export type SystemLogOrderByWithRelationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    performedBy?: SortOrder
    logLevel?: SortOrder
    logDetails?: SortOrderInput | SortOrder
    logTime?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SystemLogWhereInput | SystemLogWhereInput[]
    OR?: SystemLogWhereInput[]
    NOT?: SystemLogWhereInput | SystemLogWhereInput[]
    entityType?: StringFilter<"SystemLog"> | string
    entityId?: IntFilter<"SystemLog"> | number
    action?: StringFilter<"SystemLog"> | string
    performedBy?: StringFilter<"SystemLog"> | string
    logLevel?: StringFilter<"SystemLog"> | string
    logDetails?: StringNullableFilter<"SystemLog"> | string | null
    logTime?: DateTimeFilter<"SystemLog"> | Date | string
    createdAt?: DateTimeFilter<"SystemLog"> | Date | string
  }, "id">

  export type SystemLogOrderByWithAggregationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    performedBy?: SortOrder
    logLevel?: SortOrder
    logDetails?: SortOrderInput | SortOrder
    logTime?: SortOrder
    createdAt?: SortOrder
    _count?: SystemLogCountOrderByAggregateInput
    _avg?: SystemLogAvgOrderByAggregateInput
    _max?: SystemLogMaxOrderByAggregateInput
    _min?: SystemLogMinOrderByAggregateInput
    _sum?: SystemLogSumOrderByAggregateInput
  }

  export type SystemLogScalarWhereWithAggregatesInput = {
    AND?: SystemLogScalarWhereWithAggregatesInput | SystemLogScalarWhereWithAggregatesInput[]
    OR?: SystemLogScalarWhereWithAggregatesInput[]
    NOT?: SystemLogScalarWhereWithAggregatesInput | SystemLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SystemLog"> | number
    entityType?: StringWithAggregatesFilter<"SystemLog"> | string
    entityId?: IntWithAggregatesFilter<"SystemLog"> | number
    action?: StringWithAggregatesFilter<"SystemLog"> | string
    performedBy?: StringWithAggregatesFilter<"SystemLog"> | string
    logLevel?: StringWithAggregatesFilter<"SystemLog"> | string
    logDetails?: StringNullableWithAggregatesFilter<"SystemLog"> | string | null
    logTime?: DateTimeWithAggregatesFilter<"SystemLog"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"SystemLog"> | Date | string
  }

  export type EmailVerificationTokenWhereInput = {
    AND?: EmailVerificationTokenWhereInput | EmailVerificationTokenWhereInput[]
    OR?: EmailVerificationTokenWhereInput[]
    NOT?: EmailVerificationTokenWhereInput | EmailVerificationTokenWhereInput[]
    id?: IntFilter<"EmailVerificationToken"> | number
    userId?: IntFilter<"EmailVerificationToken"> | number
    token?: StringFilter<"EmailVerificationToken"> | string
    expiresAt?: DateTimeFilter<"EmailVerificationToken"> | Date | string
    createdAt?: DateTimeFilter<"EmailVerificationToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type EmailVerificationTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type EmailVerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    token?: string
    AND?: EmailVerificationTokenWhereInput | EmailVerificationTokenWhereInput[]
    OR?: EmailVerificationTokenWhereInput[]
    NOT?: EmailVerificationTokenWhereInput | EmailVerificationTokenWhereInput[]
    userId?: IntFilter<"EmailVerificationToken"> | number
    expiresAt?: DateTimeFilter<"EmailVerificationToken"> | Date | string
    createdAt?: DateTimeFilter<"EmailVerificationToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type EmailVerificationTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: EmailVerificationTokenCountOrderByAggregateInput
    _avg?: EmailVerificationTokenAvgOrderByAggregateInput
    _max?: EmailVerificationTokenMaxOrderByAggregateInput
    _min?: EmailVerificationTokenMinOrderByAggregateInput
    _sum?: EmailVerificationTokenSumOrderByAggregateInput
  }

  export type EmailVerificationTokenScalarWhereWithAggregatesInput = {
    AND?: EmailVerificationTokenScalarWhereWithAggregatesInput | EmailVerificationTokenScalarWhereWithAggregatesInput[]
    OR?: EmailVerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: EmailVerificationTokenScalarWhereWithAggregatesInput | EmailVerificationTokenScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmailVerificationToken"> | number
    userId?: IntWithAggregatesFilter<"EmailVerificationToken"> | number
    token?: StringWithAggregatesFilter<"EmailVerificationToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"EmailVerificationToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"EmailVerificationToken"> | Date | string
  }

  export type PhoneVerificationOtpWhereInput = {
    AND?: PhoneVerificationOtpWhereInput | PhoneVerificationOtpWhereInput[]
    OR?: PhoneVerificationOtpWhereInput[]
    NOT?: PhoneVerificationOtpWhereInput | PhoneVerificationOtpWhereInput[]
    id?: IntFilter<"PhoneVerificationOtp"> | number
    userId?: IntFilter<"PhoneVerificationOtp"> | number
    phoneNumber?: StringFilter<"PhoneVerificationOtp"> | string
    otp?: StringFilter<"PhoneVerificationOtp"> | string
    expiresAt?: DateTimeFilter<"PhoneVerificationOtp"> | Date | string
    createdAt?: DateTimeFilter<"PhoneVerificationOtp"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PhoneVerificationOtpOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    phoneNumber?: SortOrder
    otp?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PhoneVerificationOtpWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PhoneVerificationOtpWhereInput | PhoneVerificationOtpWhereInput[]
    OR?: PhoneVerificationOtpWhereInput[]
    NOT?: PhoneVerificationOtpWhereInput | PhoneVerificationOtpWhereInput[]
    userId?: IntFilter<"PhoneVerificationOtp"> | number
    phoneNumber?: StringFilter<"PhoneVerificationOtp"> | string
    otp?: StringFilter<"PhoneVerificationOtp"> | string
    expiresAt?: DateTimeFilter<"PhoneVerificationOtp"> | Date | string
    createdAt?: DateTimeFilter<"PhoneVerificationOtp"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type PhoneVerificationOtpOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    phoneNumber?: SortOrder
    otp?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: PhoneVerificationOtpCountOrderByAggregateInput
    _avg?: PhoneVerificationOtpAvgOrderByAggregateInput
    _max?: PhoneVerificationOtpMaxOrderByAggregateInput
    _min?: PhoneVerificationOtpMinOrderByAggregateInput
    _sum?: PhoneVerificationOtpSumOrderByAggregateInput
  }

  export type PhoneVerificationOtpScalarWhereWithAggregatesInput = {
    AND?: PhoneVerificationOtpScalarWhereWithAggregatesInput | PhoneVerificationOtpScalarWhereWithAggregatesInput[]
    OR?: PhoneVerificationOtpScalarWhereWithAggregatesInput[]
    NOT?: PhoneVerificationOtpScalarWhereWithAggregatesInput | PhoneVerificationOtpScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PhoneVerificationOtp"> | number
    userId?: IntWithAggregatesFilter<"PhoneVerificationOtp"> | number
    phoneNumber?: StringWithAggregatesFilter<"PhoneVerificationOtp"> | string
    otp?: StringWithAggregatesFilter<"PhoneVerificationOtp"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"PhoneVerificationOtp"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"PhoneVerificationOtp"> | Date | string
  }

  export type PasswordResetTokenWhereInput = {
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    id?: IntFilter<"PasswordResetToken"> | number
    userId?: IntFilter<"PasswordResetToken"> | number
    token?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PasswordResetTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PasswordResetTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    token?: string
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    userId?: IntFilter<"PasswordResetToken"> | number
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type PasswordResetTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: PasswordResetTokenCountOrderByAggregateInput
    _avg?: PasswordResetTokenAvgOrderByAggregateInput
    _max?: PasswordResetTokenMaxOrderByAggregateInput
    _min?: PasswordResetTokenMinOrderByAggregateInput
    _sum?: PasswordResetTokenSumOrderByAggregateInput
  }

  export type PasswordResetTokenScalarWhereWithAggregatesInput = {
    AND?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    OR?: PasswordResetTokenScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PasswordResetToken"> | number
    userId?: IntWithAggregatesFilter<"PasswordResetToken"> | number
    token?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
  }

  export type UserCreateInput = {
    username: string
    email: string
    passwordHash: string
    phoneNumber?: string | null
    accountType: string
    emailVerified?: boolean
    phoneVerified?: boolean
    accountStatus?: string
    googleId?: string | null
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    vehicles?: VehicleCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    userPaymentMethods?: UserPaymentMethodCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    parkingPasses?: ParkingPassCreateNestedManyWithoutUserInput
    placeRatings?: PlaceRatingCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    EmailVerificationToken?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    PhoneVerificationOtp?: PhoneVerificationOtpCreateNestedManyWithoutUserInput
    PasswordResetToken?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    phoneNumber?: string | null
    accountType: string
    emailVerified?: boolean
    phoneVerified?: boolean
    accountStatus?: string
    googleId?: string | null
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    vehicles?: VehicleUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    userPaymentMethods?: UserPaymentMethodUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    parkingPasses?: ParkingPassUncheckedCreateNestedManyWithoutUserInput
    placeRatings?: PlaceRatingUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    EmailVerificationToken?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    PhoneVerificationOtp?: PhoneVerificationOtpUncheckedCreateNestedManyWithoutUserInput
    PasswordResetToken?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    accountStatus?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    vehicles?: VehicleUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    userPaymentMethods?: UserPaymentMethodUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    parkingPasses?: ParkingPassUpdateManyWithoutUserNestedInput
    placeRatings?: PlaceRatingUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    EmailVerificationToken?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    PhoneVerificationOtp?: PhoneVerificationOtpUpdateManyWithoutUserNestedInput
    PasswordResetToken?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    accountStatus?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    vehicles?: VehicleUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    userPaymentMethods?: UserPaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    parkingPasses?: ParkingPassUncheckedUpdateManyWithoutUserNestedInput
    placeRatings?: PlaceRatingUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    EmailVerificationToken?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    PhoneVerificationOtp?: PhoneVerificationOtpUncheckedUpdateManyWithoutUserNestedInput
    PasswordResetToken?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    phoneNumber?: string | null
    accountType: string
    emailVerified?: boolean
    phoneVerified?: boolean
    accountStatus?: string
    googleId?: string | null
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    accountStatus?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    accountStatus?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserSessionCreateInput = {
    token: string
    deviceInfo?: string | null
    ipAddress?: string | null
    lastActivity?: Date | string
    expiryTime: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type UserSessionUncheckedCreateInput = {
    id?: number
    userId: number
    token: string
    deviceInfo?: string | null
    ipAddress?: string | null
    lastActivity?: Date | string
    expiryTime: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type UserSessionUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type UserSessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserSessionCreateManyInput = {
    id?: number
    userId: number
    token: string
    deviceInfo?: string | null
    ipAddress?: string | null
    lastActivity?: Date | string
    expiryTime: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type UserSessionUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserSessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserProfileCreateInput = {
    firstName?: string | null
    lastName?: string | null
    profilePhoto?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutProfileInput
  }

  export type UserProfileUncheckedCreateInput = {
    id?: number
    userId: number
    firstName?: string | null
    lastName?: string | null
    profilePhoto?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type UserProfileUpdateInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
  }

  export type UserProfileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserProfileCreateManyInput = {
    id?: number
    userId: number
    firstName?: string | null
    lastName?: string | null
    profilePhoto?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type UserProfileUpdateManyMutationInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserProfileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VehicleCreateInput = {
    licensePlate: string
    vehicleType: string
    brand?: string | null
    model?: string | null
    color?: string | null
    rfidTag?: string | null
    length?: Decimal | DecimalJsLike | number | string | null
    width?: Decimal | DecimalJsLike | number | string | null
    height?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutVehiclesInput
    bookings?: BookingCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateInput = {
    id?: number
    userId: number
    licensePlate: string
    vehicleType: string
    brand?: string | null
    model?: string | null
    color?: string | null
    rfidTag?: string | null
    length?: Decimal | DecimalJsLike | number | string | null
    width?: Decimal | DecimalJsLike | number | string | null
    height?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    bookings?: BookingUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUpdateInput = {
    licensePlate?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    rfidTag?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    width?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutVehiclesNestedInput
    bookings?: BookingUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    licensePlate?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    rfidTag?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    width?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookings?: BookingUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleCreateManyInput = {
    id?: number
    userId: number
    licensePlate: string
    vehicleType: string
    brand?: string | null
    model?: string | null
    color?: string | null
    rfidTag?: string | null
    length?: Decimal | DecimalJsLike | number | string | null
    width?: Decimal | DecimalJsLike | number | string | null
    height?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type VehicleUpdateManyMutationInput = {
    licensePlate?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    rfidTag?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    width?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VehicleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    licensePlate?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    rfidTag?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    width?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlaceCreateInput = {
    name: string
    image?: string | null
    placeType: string
    address: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    contactNumber?: string | null
    email?: string | null
    description?: string | null
    totalCapacity: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    parkingZones?: ParkingZoneCreateNestedManyWithoutPlaceInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutPlaceInput
    parkingPasses?: ParkingPassCreateNestedManyWithoutPlaceInput
    operatingHours?: OperatingHourCreateNestedManyWithoutPlaceInput
    placeAdmins?: PlaceAdminCreateNestedManyWithoutPlaceInput
    placeRatings?: PlaceRatingCreateNestedManyWithoutPlaceInput
  }

  export type PlaceUncheckedCreateInput = {
    id?: number
    name: string
    image?: string | null
    placeType: string
    address: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    contactNumber?: string | null
    email?: string | null
    description?: string | null
    totalCapacity: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    parkingZones?: ParkingZoneUncheckedCreateNestedManyWithoutPlaceInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutPlaceInput
    parkingPasses?: ParkingPassUncheckedCreateNestedManyWithoutPlaceInput
    operatingHours?: OperatingHourUncheckedCreateNestedManyWithoutPlaceInput
    placeAdmins?: PlaceAdminUncheckedCreateNestedManyWithoutPlaceInput
    placeRatings?: PlaceRatingUncheckedCreateNestedManyWithoutPlaceInput
  }

  export type PlaceUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    placeType?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalCapacity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parkingZones?: ParkingZoneUpdateManyWithoutPlaceNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutPlaceNestedInput
    parkingPasses?: ParkingPassUpdateManyWithoutPlaceNestedInput
    operatingHours?: OperatingHourUpdateManyWithoutPlaceNestedInput
    placeAdmins?: PlaceAdminUpdateManyWithoutPlaceNestedInput
    placeRatings?: PlaceRatingUpdateManyWithoutPlaceNestedInput
  }

  export type PlaceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    placeType?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalCapacity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parkingZones?: ParkingZoneUncheckedUpdateManyWithoutPlaceNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutPlaceNestedInput
    parkingPasses?: ParkingPassUncheckedUpdateManyWithoutPlaceNestedInput
    operatingHours?: OperatingHourUncheckedUpdateManyWithoutPlaceNestedInput
    placeAdmins?: PlaceAdminUncheckedUpdateManyWithoutPlaceNestedInput
    placeRatings?: PlaceRatingUncheckedUpdateManyWithoutPlaceNestedInput
  }

  export type PlaceCreateManyInput = {
    id?: number
    name: string
    image?: string | null
    placeType: string
    address: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    contactNumber?: string | null
    email?: string | null
    description?: string | null
    totalCapacity: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type PlaceUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    placeType?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalCapacity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlaceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    placeType?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalCapacity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ParkingZoneCreateInput = {
    zoneName: string
    floorLevel?: string | null
    zoneType?: string | null
    totalSlots: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    place: PlaceCreateNestedOneWithoutParkingZonesInput
    parkingSlots?: ParkingSlotCreateNestedManyWithoutParkingZoneInput
  }

  export type ParkingZoneUncheckedCreateInput = {
    id?: number
    placeId: number
    zoneName: string
    floorLevel?: string | null
    zoneType?: string | null
    totalSlots: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutParkingZoneInput
  }

  export type ParkingZoneUpdateInput = {
    zoneName?: StringFieldUpdateOperationsInput | string
    floorLevel?: NullableStringFieldUpdateOperationsInput | string | null
    zoneType?: NullableStringFieldUpdateOperationsInput | string | null
    totalSlots?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    place?: PlaceUpdateOneRequiredWithoutParkingZonesNestedInput
    parkingSlots?: ParkingSlotUpdateManyWithoutParkingZoneNestedInput
  }

  export type ParkingZoneUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    placeId?: IntFieldUpdateOperationsInput | number
    zoneName?: StringFieldUpdateOperationsInput | string
    floorLevel?: NullableStringFieldUpdateOperationsInput | string | null
    zoneType?: NullableStringFieldUpdateOperationsInput | string | null
    totalSlots?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutParkingZoneNestedInput
  }

  export type ParkingZoneCreateManyInput = {
    id?: number
    placeId: number
    zoneName: string
    floorLevel?: string | null
    zoneType?: string | null
    totalSlots: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type ParkingZoneUpdateManyMutationInput = {
    zoneName?: StringFieldUpdateOperationsInput | string
    floorLevel?: NullableStringFieldUpdateOperationsInput | string | null
    zoneType?: NullableStringFieldUpdateOperationsInput | string | null
    totalSlots?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ParkingZoneUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    placeId?: IntFieldUpdateOperationsInput | number
    zoneName?: StringFieldUpdateOperationsInput | string
    floorLevel?: NullableStringFieldUpdateOperationsInput | string | null
    zoneType?: NullableStringFieldUpdateOperationsInput | string | null
    totalSlots?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ParkingSlotCreateInput = {
    slotNumber: string
    slotType: string
    isReserved?: boolean
    isOccupied?: boolean
    isDisabledFriendly?: boolean
    hasEvCharger?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    parkingZone: ParkingZoneCreateNestedOneWithoutParkingSlotsInput
    slotAvailability?: SlotAvailabilityCreateNestedManyWithoutParkingSlotInput
    bookings?: BookingCreateNestedManyWithoutParkingSlotInput
  }

  export type ParkingSlotUncheckedCreateInput = {
    id?: number
    zoneId: number
    slotNumber: string
    slotType: string
    isReserved?: boolean
    isOccupied?: boolean
    isDisabledFriendly?: boolean
    hasEvCharger?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    slotAvailability?: SlotAvailabilityUncheckedCreateNestedManyWithoutParkingSlotInput
    bookings?: BookingUncheckedCreateNestedManyWithoutParkingSlotInput
  }

  export type ParkingSlotUpdateInput = {
    slotNumber?: StringFieldUpdateOperationsInput | string
    slotType?: StringFieldUpdateOperationsInput | string
    isReserved?: BoolFieldUpdateOperationsInput | boolean
    isOccupied?: BoolFieldUpdateOperationsInput | boolean
    isDisabledFriendly?: BoolFieldUpdateOperationsInput | boolean
    hasEvCharger?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parkingZone?: ParkingZoneUpdateOneRequiredWithoutParkingSlotsNestedInput
    slotAvailability?: SlotAvailabilityUpdateManyWithoutParkingSlotNestedInput
    bookings?: BookingUpdateManyWithoutParkingSlotNestedInput
  }

  export type ParkingSlotUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    zoneId?: IntFieldUpdateOperationsInput | number
    slotNumber?: StringFieldUpdateOperationsInput | string
    slotType?: StringFieldUpdateOperationsInput | string
    isReserved?: BoolFieldUpdateOperationsInput | boolean
    isOccupied?: BoolFieldUpdateOperationsInput | boolean
    isDisabledFriendly?: BoolFieldUpdateOperationsInput | boolean
    hasEvCharger?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slotAvailability?: SlotAvailabilityUncheckedUpdateManyWithoutParkingSlotNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutParkingSlotNestedInput
  }

  export type ParkingSlotCreateManyInput = {
    id?: number
    zoneId: number
    slotNumber: string
    slotType: string
    isReserved?: boolean
    isOccupied?: boolean
    isDisabledFriendly?: boolean
    hasEvCharger?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type ParkingSlotUpdateManyMutationInput = {
    slotNumber?: StringFieldUpdateOperationsInput | string
    slotType?: StringFieldUpdateOperationsInput | string
    isReserved?: BoolFieldUpdateOperationsInput | boolean
    isOccupied?: BoolFieldUpdateOperationsInput | boolean
    isDisabledFriendly?: BoolFieldUpdateOperationsInput | boolean
    hasEvCharger?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ParkingSlotUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    zoneId?: IntFieldUpdateOperationsInput | number
    slotNumber?: StringFieldUpdateOperationsInput | string
    slotType?: StringFieldUpdateOperationsInput | string
    isReserved?: BoolFieldUpdateOperationsInput | boolean
    isOccupied?: BoolFieldUpdateOperationsInput | boolean
    isDisabledFriendly?: BoolFieldUpdateOperationsInput | boolean
    hasEvCharger?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SlotAvailabilityCreateInput = {
    availableFrom: Date | string
    availableUntil: Date | string
    isBookable?: boolean
    statusReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    parkingSlot: ParkingSlotCreateNestedOneWithoutSlotAvailabilityInput
  }

  export type SlotAvailabilityUncheckedCreateInput = {
    id?: number
    slotId: number
    availableFrom: Date | string
    availableUntil: Date | string
    isBookable?: boolean
    statusReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type SlotAvailabilityUpdateInput = {
    availableFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    availableUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    isBookable?: BoolFieldUpdateOperationsInput | boolean
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parkingSlot?: ParkingSlotUpdateOneRequiredWithoutSlotAvailabilityNestedInput
  }

  export type SlotAvailabilityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    slotId?: IntFieldUpdateOperationsInput | number
    availableFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    availableUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    isBookable?: BoolFieldUpdateOperationsInput | boolean
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SlotAvailabilityCreateManyInput = {
    id?: number
    slotId: number
    availableFrom: Date | string
    availableUntil: Date | string
    isBookable?: boolean
    statusReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type SlotAvailabilityUpdateManyMutationInput = {
    availableFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    availableUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    isBookable?: BoolFieldUpdateOperationsInput | boolean
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SlotAvailabilityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    slotId?: IntFieldUpdateOperationsInput | number
    availableFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    availableUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    isBookable?: BoolFieldUpdateOperationsInput | boolean
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TariffPlanCreateInput = {
    planName: string
    description?: string | null
    effectiveFrom: Date | string
    effectiveUntil?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    place: PlaceCreateNestedOneWithoutTariffPlansInput
    tariffRates?: TariffRateCreateNestedManyWithoutTariffPlanInput
  }

  export type TariffPlanUncheckedCreateInput = {
    id?: number
    placeId: number
    planName: string
    description?: string | null
    effectiveFrom: Date | string
    effectiveUntil?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    tariffRates?: TariffRateUncheckedCreateNestedManyWithoutTariffPlanInput
  }

  export type TariffPlanUpdateInput = {
    planName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    place?: PlaceUpdateOneRequiredWithoutTariffPlansNestedInput
    tariffRates?: TariffRateUpdateManyWithoutTariffPlanNestedInput
  }

  export type TariffPlanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    placeId?: IntFieldUpdateOperationsInput | number
    planName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tariffRates?: TariffRateUncheckedUpdateManyWithoutTariffPlanNestedInput
  }

  export type TariffPlanCreateManyInput = {
    id?: number
    placeId: number
    planName: string
    description?: string | null
    effectiveFrom: Date | string
    effectiveUntil?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type TariffPlanUpdateManyMutationInput = {
    planName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TariffPlanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    placeId?: IntFieldUpdateOperationsInput | number
    planName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TariffRateCreateInput = {
    vehicleType: string
    slotType: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    dayCategory?: string | null
    basePrice: Decimal | DecimalJsLike | number | string
    hourlyRate: Decimal | DecimalJsLike | number | string
    dayRate?: Decimal | DecimalJsLike | number | string | null
    minimumCharge?: Decimal | DecimalJsLike | number | string
    gracePeriodMinutes?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    tariffPlan: TariffPlanCreateNestedOneWithoutTariffRatesInput
  }

  export type TariffRateUncheckedCreateInput = {
    id?: number
    planId: number
    vehicleType: string
    slotType: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    dayCategory?: string | null
    basePrice: Decimal | DecimalJsLike | number | string
    hourlyRate: Decimal | DecimalJsLike | number | string
    dayRate?: Decimal | DecimalJsLike | number | string | null
    minimumCharge?: Decimal | DecimalJsLike | number | string
    gracePeriodMinutes?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type TariffRateUpdateInput = {
    vehicleType?: StringFieldUpdateOperationsInput | string
    slotType?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dayCategory?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hourlyRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dayRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minimumCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gracePeriodMinutes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tariffPlan?: TariffPlanUpdateOneRequiredWithoutTariffRatesNestedInput
  }

  export type TariffRateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    planId?: IntFieldUpdateOperationsInput | number
    vehicleType?: StringFieldUpdateOperationsInput | string
    slotType?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dayCategory?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hourlyRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dayRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minimumCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gracePeriodMinutes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TariffRateCreateManyInput = {
    id?: number
    planId: number
    vehicleType: string
    slotType: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    dayCategory?: string | null
    basePrice: Decimal | DecimalJsLike | number | string
    hourlyRate: Decimal | DecimalJsLike | number | string
    dayRate?: Decimal | DecimalJsLike | number | string | null
    minimumCharge?: Decimal | DecimalJsLike | number | string
    gracePeriodMinutes?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type TariffRateUpdateManyMutationInput = {
    vehicleType?: StringFieldUpdateOperationsInput | string
    slotType?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dayCategory?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hourlyRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dayRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minimumCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gracePeriodMinutes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TariffRateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    planId?: IntFieldUpdateOperationsInput | number
    vehicleType?: StringFieldUpdateOperationsInput | string
    slotType?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dayCategory?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hourlyRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dayRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minimumCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gracePeriodMinutes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BookingCreateInput = {
    bookingReference: string
    bookingTime?: Date | string
    scheduledEntry: Date | string
    scheduledExit: Date | string
    actualEntry?: Date | string | null
    actualExit?: Date | string | null
    qrCode?: string | null
    bookingStatus: string
    estimatedPrice: Decimal | DecimalJsLike | number | string
    finalPrice?: Decimal | DecimalJsLike | number | string | null
    cancellationReason?: string | null
    cancellationTimeMinutes?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutBookingsInput
    vehicle: VehicleCreateNestedOneWithoutBookingsInput
    parkingSlot: ParkingSlotCreateNestedOneWithoutBookingsInput
    promoCode?: PromoCodeCreateNestedOneWithoutBookingsInput
    bookingStatusLogs?: BookingStatusLogCreateNestedManyWithoutBookingInput
    bookingPayment?: BookingPaymentCreateNestedOneWithoutBookingInput
    accessLogs?: AccessLogCreateNestedManyWithoutBookingInput
    bookingExtensions?: BookingExtensionCreateNestedManyWithoutBookingInput
    placeRatings?: PlaceRatingCreateNestedManyWithoutBookingInput
    notifications?: NotificationCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateInput = {
    id?: number
    userId: number
    vehicleId: number
    slotId: number
    promoCodeId?: number | null
    bookingReference: string
    bookingTime?: Date | string
    scheduledEntry: Date | string
    scheduledExit: Date | string
    actualEntry?: Date | string | null
    actualExit?: Date | string | null
    qrCode?: string | null
    bookingStatus: string
    estimatedPrice: Decimal | DecimalJsLike | number | string
    finalPrice?: Decimal | DecimalJsLike | number | string | null
    cancellationReason?: string | null
    cancellationTimeMinutes?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    bookingStatusLogs?: BookingStatusLogUncheckedCreateNestedManyWithoutBookingInput
    bookingPayment?: BookingPaymentUncheckedCreateNestedOneWithoutBookingInput
    accessLogs?: AccessLogUncheckedCreateNestedManyWithoutBookingInput
    bookingExtensions?: BookingExtensionUncheckedCreateNestedManyWithoutBookingInput
    placeRatings?: PlaceRatingUncheckedCreateNestedManyWithoutBookingInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingUpdateInput = {
    bookingReference?: StringFieldUpdateOperationsInput | string
    bookingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledExit?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualExit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    bookingStatus?: StringFieldUpdateOperationsInput | string
    estimatedPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutBookingsNestedInput
    parkingSlot?: ParkingSlotUpdateOneRequiredWithoutBookingsNestedInput
    promoCode?: PromoCodeUpdateOneWithoutBookingsNestedInput
    bookingStatusLogs?: BookingStatusLogUpdateManyWithoutBookingNestedInput
    bookingPayment?: BookingPaymentUpdateOneWithoutBookingNestedInput
    accessLogs?: AccessLogUpdateManyWithoutBookingNestedInput
    bookingExtensions?: BookingExtensionUpdateManyWithoutBookingNestedInput
    placeRatings?: PlaceRatingUpdateManyWithoutBookingNestedInput
    notifications?: NotificationUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    slotId?: IntFieldUpdateOperationsInput | number
    promoCodeId?: NullableIntFieldUpdateOperationsInput | number | null
    bookingReference?: StringFieldUpdateOperationsInput | string
    bookingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledExit?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualExit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    bookingStatus?: StringFieldUpdateOperationsInput | string
    estimatedPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookingStatusLogs?: BookingStatusLogUncheckedUpdateManyWithoutBookingNestedInput
    bookingPayment?: BookingPaymentUncheckedUpdateOneWithoutBookingNestedInput
    accessLogs?: AccessLogUncheckedUpdateManyWithoutBookingNestedInput
    bookingExtensions?: BookingExtensionUncheckedUpdateManyWithoutBookingNestedInput
    placeRatings?: PlaceRatingUncheckedUpdateManyWithoutBookingNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingCreateManyInput = {
    id?: number
    userId: number
    vehicleId: number
    slotId: number
    promoCodeId?: number | null
    bookingReference: string
    bookingTime?: Date | string
    scheduledEntry: Date | string
    scheduledExit: Date | string
    actualEntry?: Date | string | null
    actualExit?: Date | string | null
    qrCode?: string | null
    bookingStatus: string
    estimatedPrice: Decimal | DecimalJsLike | number | string
    finalPrice?: Decimal | DecimalJsLike | number | string | null
    cancellationReason?: string | null
    cancellationTimeMinutes?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type BookingUpdateManyMutationInput = {
    bookingReference?: StringFieldUpdateOperationsInput | string
    bookingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledExit?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualExit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    bookingStatus?: StringFieldUpdateOperationsInput | string
    estimatedPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BookingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    slotId?: IntFieldUpdateOperationsInput | number
    promoCodeId?: NullableIntFieldUpdateOperationsInput | number | null
    bookingReference?: StringFieldUpdateOperationsInput | string
    bookingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledExit?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualExit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    bookingStatus?: StringFieldUpdateOperationsInput | string
    estimatedPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BookingStatusLogCreateInput = {
    previousStatus: string
    newStatus: string
    changedBy: string
    reason?: string | null
    statusTime?: Date | string
    createdAt?: Date | string
    booking: BookingCreateNestedOneWithoutBookingStatusLogsInput
  }

  export type BookingStatusLogUncheckedCreateInput = {
    id?: number
    bookingId: number
    previousStatus: string
    newStatus: string
    changedBy: string
    reason?: string | null
    statusTime?: Date | string
    createdAt?: Date | string
  }

  export type BookingStatusLogUpdateInput = {
    previousStatus?: StringFieldUpdateOperationsInput | string
    newStatus?: StringFieldUpdateOperationsInput | string
    changedBy?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    statusTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutBookingStatusLogsNestedInput
  }

  export type BookingStatusLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    previousStatus?: StringFieldUpdateOperationsInput | string
    newStatus?: StringFieldUpdateOperationsInput | string
    changedBy?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    statusTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingStatusLogCreateManyInput = {
    id?: number
    bookingId: number
    previousStatus: string
    newStatus: string
    changedBy: string
    reason?: string | null
    statusTime?: Date | string
    createdAt?: Date | string
  }

  export type BookingStatusLogUpdateManyMutationInput = {
    previousStatus?: StringFieldUpdateOperationsInput | string
    newStatus?: StringFieldUpdateOperationsInput | string
    changedBy?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    statusTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingStatusLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    previousStatus?: StringFieldUpdateOperationsInput | string
    newStatus?: StringFieldUpdateOperationsInput | string
    changedBy?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    statusTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingPaymentCreateInput = {
    paymentReference?: string | null
    paymentStatus: string
    originalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    surchargeAmount?: Decimal | DecimalJsLike | number | string
    finalAmount: Decimal | DecimalJsLike | number | string
    isPrepaid?: boolean
    isRefunded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    booking: BookingCreateNestedOneWithoutBookingPaymentInput
    paymentTransactions?: PaymentTransactionCreateNestedManyWithoutBookingPaymentInput
    refundTransactions?: RefundTransactionCreateNestedManyWithoutBookingPaymentInput
  }

  export type BookingPaymentUncheckedCreateInput = {
    id?: number
    bookingId: number
    paymentReference?: string | null
    paymentStatus: string
    originalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    surchargeAmount?: Decimal | DecimalJsLike | number | string
    finalAmount: Decimal | DecimalJsLike | number | string
    isPrepaid?: boolean
    isRefunded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    paymentTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutBookingPaymentInput
    refundTransactions?: RefundTransactionUncheckedCreateNestedManyWithoutBookingPaymentInput
  }

  export type BookingPaymentUpdateInput = {
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    originalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    surchargeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPrepaid?: BoolFieldUpdateOperationsInput | boolean
    isRefunded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    booking?: BookingUpdateOneRequiredWithoutBookingPaymentNestedInput
    paymentTransactions?: PaymentTransactionUpdateManyWithoutBookingPaymentNestedInput
    refundTransactions?: RefundTransactionUpdateManyWithoutBookingPaymentNestedInput
  }

  export type BookingPaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    originalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    surchargeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPrepaid?: BoolFieldUpdateOperationsInput | boolean
    isRefunded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentTransactions?: PaymentTransactionUncheckedUpdateManyWithoutBookingPaymentNestedInput
    refundTransactions?: RefundTransactionUncheckedUpdateManyWithoutBookingPaymentNestedInput
  }

  export type BookingPaymentCreateManyInput = {
    id?: number
    bookingId: number
    paymentReference?: string | null
    paymentStatus: string
    originalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    surchargeAmount?: Decimal | DecimalJsLike | number | string
    finalAmount: Decimal | DecimalJsLike | number | string
    isPrepaid?: boolean
    isRefunded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type BookingPaymentUpdateManyMutationInput = {
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    originalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    surchargeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPrepaid?: BoolFieldUpdateOperationsInput | boolean
    isRefunded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BookingPaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    originalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    surchargeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPrepaid?: BoolFieldUpdateOperationsInput | boolean
    isRefunded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentTransactionCreateInput = {
    transactionReference?: string | null
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    transactionStatus: string
    gatewayResponse?: string | null
    transactionData?: string | null
    transactionTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    bookingPayment: BookingPaymentCreateNestedOneWithoutPaymentTransactionsInput
    paymentMethod: PaymentMethodCreateNestedOneWithoutPaymentTransactionsInput
  }

  export type PaymentTransactionUncheckedCreateInput = {
    id?: number
    paymentId: number
    paymentMethodId: number
    transactionReference?: string | null
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    transactionStatus: string
    gatewayResponse?: string | null
    transactionData?: string | null
    transactionTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type PaymentTransactionUpdateInput = {
    transactionReference?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    transactionStatus?: StringFieldUpdateOperationsInput | string
    gatewayResponse?: NullableStringFieldUpdateOperationsInput | string | null
    transactionData?: NullableStringFieldUpdateOperationsInput | string | null
    transactionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookingPayment?: BookingPaymentUpdateOneRequiredWithoutPaymentTransactionsNestedInput
    paymentMethod?: PaymentMethodUpdateOneRequiredWithoutPaymentTransactionsNestedInput
  }

  export type PaymentTransactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    paymentId?: IntFieldUpdateOperationsInput | number
    paymentMethodId?: IntFieldUpdateOperationsInput | number
    transactionReference?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    transactionStatus?: StringFieldUpdateOperationsInput | string
    gatewayResponse?: NullableStringFieldUpdateOperationsInput | string | null
    transactionData?: NullableStringFieldUpdateOperationsInput | string | null
    transactionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentTransactionCreateManyInput = {
    id?: number
    paymentId: number
    paymentMethodId: number
    transactionReference?: string | null
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    transactionStatus: string
    gatewayResponse?: string | null
    transactionData?: string | null
    transactionTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type PaymentTransactionUpdateManyMutationInput = {
    transactionReference?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    transactionStatus?: StringFieldUpdateOperationsInput | string
    gatewayResponse?: NullableStringFieldUpdateOperationsInput | string | null
    transactionData?: NullableStringFieldUpdateOperationsInput | string | null
    transactionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentTransactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    paymentId?: IntFieldUpdateOperationsInput | number
    paymentMethodId?: IntFieldUpdateOperationsInput | number
    transactionReference?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    transactionStatus?: StringFieldUpdateOperationsInput | string
    gatewayResponse?: NullableStringFieldUpdateOperationsInput | string | null
    transactionData?: NullableStringFieldUpdateOperationsInput | string | null
    transactionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefundTransactionCreateInput = {
    refundReference?: string | null
    refundAmount: Decimal | DecimalJsLike | number | string
    refundReason?: string | null
    refundStatus: string
    processorResponse?: string | null
    refundData?: string | null
    refundTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    bookingPayment: BookingPaymentCreateNestedOneWithoutRefundTransactionsInput
  }

  export type RefundTransactionUncheckedCreateInput = {
    id?: number
    paymentId: number
    refundReference?: string | null
    refundAmount: Decimal | DecimalJsLike | number | string
    refundReason?: string | null
    refundStatus: string
    processorResponse?: string | null
    refundData?: string | null
    refundTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type RefundTransactionUpdateInput = {
    refundReference?: NullableStringFieldUpdateOperationsInput | string | null
    refundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null
    refundStatus?: StringFieldUpdateOperationsInput | string
    processorResponse?: NullableStringFieldUpdateOperationsInput | string | null
    refundData?: NullableStringFieldUpdateOperationsInput | string | null
    refundTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookingPayment?: BookingPaymentUpdateOneRequiredWithoutRefundTransactionsNestedInput
  }

  export type RefundTransactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    paymentId?: IntFieldUpdateOperationsInput | number
    refundReference?: NullableStringFieldUpdateOperationsInput | string | null
    refundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null
    refundStatus?: StringFieldUpdateOperationsInput | string
    processorResponse?: NullableStringFieldUpdateOperationsInput | string | null
    refundData?: NullableStringFieldUpdateOperationsInput | string | null
    refundTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefundTransactionCreateManyInput = {
    id?: number
    paymentId: number
    refundReference?: string | null
    refundAmount: Decimal | DecimalJsLike | number | string
    refundReason?: string | null
    refundStatus: string
    processorResponse?: string | null
    refundData?: string | null
    refundTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type RefundTransactionUpdateManyMutationInput = {
    refundReference?: NullableStringFieldUpdateOperationsInput | string | null
    refundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null
    refundStatus?: StringFieldUpdateOperationsInput | string
    processorResponse?: NullableStringFieldUpdateOperationsInput | string | null
    refundData?: NullableStringFieldUpdateOperationsInput | string | null
    refundTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefundTransactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    paymentId?: IntFieldUpdateOperationsInput | number
    refundReference?: NullableStringFieldUpdateOperationsInput | string | null
    refundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null
    refundStatus?: StringFieldUpdateOperationsInput | string
    processorResponse?: NullableStringFieldUpdateOperationsInput | string | null
    refundData?: NullableStringFieldUpdateOperationsInput | string | null
    refundTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentMethodCreateInput = {
    methodName: string
    provider: string
    methodType: string
    description?: string | null
    processingFeePercent?: Decimal | DecimalJsLike | number | string
    fixedFee?: Decimal | DecimalJsLike | number | string
    supportsRefunds?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    paymentTransactions?: PaymentTransactionCreateNestedManyWithoutPaymentMethodInput
    userPaymentMethods?: UserPaymentMethodCreateNestedManyWithoutPaymentMethodInput
    parkingPassPayments?: ParkingPassPaymentCreateNestedManyWithoutPaymentMethodInput
  }

  export type PaymentMethodUncheckedCreateInput = {
    id?: number
    methodName: string
    provider: string
    methodType: string
    description?: string | null
    processingFeePercent?: Decimal | DecimalJsLike | number | string
    fixedFee?: Decimal | DecimalJsLike | number | string
    supportsRefunds?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    paymentTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutPaymentMethodInput
    userPaymentMethods?: UserPaymentMethodUncheckedCreateNestedManyWithoutPaymentMethodInput
    parkingPassPayments?: ParkingPassPaymentUncheckedCreateNestedManyWithoutPaymentMethodInput
  }

  export type PaymentMethodUpdateInput = {
    methodName?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    methodType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    processingFeePercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fixedFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    supportsRefunds?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentTransactions?: PaymentTransactionUpdateManyWithoutPaymentMethodNestedInput
    userPaymentMethods?: UserPaymentMethodUpdateManyWithoutPaymentMethodNestedInput
    parkingPassPayments?: ParkingPassPaymentUpdateManyWithoutPaymentMethodNestedInput
  }

  export type PaymentMethodUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    methodName?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    methodType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    processingFeePercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fixedFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    supportsRefunds?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentTransactions?: PaymentTransactionUncheckedUpdateManyWithoutPaymentMethodNestedInput
    userPaymentMethods?: UserPaymentMethodUncheckedUpdateManyWithoutPaymentMethodNestedInput
    parkingPassPayments?: ParkingPassPaymentUncheckedUpdateManyWithoutPaymentMethodNestedInput
  }

  export type PaymentMethodCreateManyInput = {
    id?: number
    methodName: string
    provider: string
    methodType: string
    description?: string | null
    processingFeePercent?: Decimal | DecimalJsLike | number | string
    fixedFee?: Decimal | DecimalJsLike | number | string
    supportsRefunds?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type PaymentMethodUpdateManyMutationInput = {
    methodName?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    methodType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    processingFeePercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fixedFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    supportsRefunds?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentMethodUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    methodName?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    methodType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    processingFeePercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fixedFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    supportsRefunds?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserPaymentMethodCreateInput = {
    tokenReference: string
    maskedInfo?: string | null
    expiryInfo?: string | null
    isDefault?: boolean
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutUserPaymentMethodsInput
    paymentMethod: PaymentMethodCreateNestedOneWithoutUserPaymentMethodsInput
  }

  export type UserPaymentMethodUncheckedCreateInput = {
    id?: number
    userId: number
    paymentMethodId: number
    tokenReference: string
    maskedInfo?: string | null
    expiryInfo?: string | null
    isDefault?: boolean
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type UserPaymentMethodUpdateInput = {
    tokenReference?: StringFieldUpdateOperationsInput | string
    maskedInfo?: NullableStringFieldUpdateOperationsInput | string | null
    expiryInfo?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutUserPaymentMethodsNestedInput
    paymentMethod?: PaymentMethodUpdateOneRequiredWithoutUserPaymentMethodsNestedInput
  }

  export type UserPaymentMethodUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    paymentMethodId?: IntFieldUpdateOperationsInput | number
    tokenReference?: StringFieldUpdateOperationsInput | string
    maskedInfo?: NullableStringFieldUpdateOperationsInput | string | null
    expiryInfo?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserPaymentMethodCreateManyInput = {
    id?: number
    userId: number
    paymentMethodId: number
    tokenReference: string
    maskedInfo?: string | null
    expiryInfo?: string | null
    isDefault?: boolean
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type UserPaymentMethodUpdateManyMutationInput = {
    tokenReference?: StringFieldUpdateOperationsInput | string
    maskedInfo?: NullableStringFieldUpdateOperationsInput | string | null
    expiryInfo?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserPaymentMethodUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    paymentMethodId?: IntFieldUpdateOperationsInput | number
    tokenReference?: StringFieldUpdateOperationsInput | string
    maskedInfo?: NullableStringFieldUpdateOperationsInput | string | null
    expiryInfo?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PromoCodeCreateInput = {
    code: string
    description?: string | null
    discountType: string
    discountValue: Decimal | DecimalJsLike | number | string
    minimumSpend?: Decimal | DecimalJsLike | number | string
    validFrom: Date | string
    validUntil?: Date | string | null
    usageLimit?: number | null
    usageCount?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    bookings?: BookingCreateNestedManyWithoutPromoCodeInput
  }

  export type PromoCodeUncheckedCreateInput = {
    id?: number
    code: string
    description?: string | null
    discountType: string
    discountValue: Decimal | DecimalJsLike | number | string
    minimumSpend?: Decimal | DecimalJsLike | number | string
    validFrom: Date | string
    validUntil?: Date | string | null
    usageLimit?: number | null
    usageCount?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    bookings?: BookingUncheckedCreateNestedManyWithoutPromoCodeInput
  }

  export type PromoCodeUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minimumSpend?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookings?: BookingUpdateManyWithoutPromoCodeNestedInput
  }

  export type PromoCodeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minimumSpend?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookings?: BookingUncheckedUpdateManyWithoutPromoCodeNestedInput
  }

  export type PromoCodeCreateManyInput = {
    id?: number
    code: string
    description?: string | null
    discountType: string
    discountValue: Decimal | DecimalJsLike | number | string
    minimumSpend?: Decimal | DecimalJsLike | number | string
    validFrom: Date | string
    validUntil?: Date | string | null
    usageLimit?: number | null
    usageCount?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type PromoCodeUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minimumSpend?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PromoCodeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minimumSpend?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ParkingPassCreateInput = {
    passType: string
    passReference?: string | null
    startDate: Date | string
    endDate: Date | string
    price: Decimal | DecimalJsLike | number | string
    status: string
    autoRenew?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutParkingPassesInput
    place: PlaceCreateNestedOneWithoutParkingPassesInput
    parkingPassPayments?: ParkingPassPaymentCreateNestedManyWithoutParkingPassInput
  }

  export type ParkingPassUncheckedCreateInput = {
    id?: number
    userId: number
    placeId: number
    passType: string
    passReference?: string | null
    startDate: Date | string
    endDate: Date | string
    price: Decimal | DecimalJsLike | number | string
    status: string
    autoRenew?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    parkingPassPayments?: ParkingPassPaymentUncheckedCreateNestedManyWithoutParkingPassInput
  }

  export type ParkingPassUpdateInput = {
    passType?: StringFieldUpdateOperationsInput | string
    passReference?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutParkingPassesNestedInput
    place?: PlaceUpdateOneRequiredWithoutParkingPassesNestedInput
    parkingPassPayments?: ParkingPassPaymentUpdateManyWithoutParkingPassNestedInput
  }

  export type ParkingPassUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    placeId?: IntFieldUpdateOperationsInput | number
    passType?: StringFieldUpdateOperationsInput | string
    passReference?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parkingPassPayments?: ParkingPassPaymentUncheckedUpdateManyWithoutParkingPassNestedInput
  }

  export type ParkingPassCreateManyInput = {
    id?: number
    userId: number
    placeId: number
    passType: string
    passReference?: string | null
    startDate: Date | string
    endDate: Date | string
    price: Decimal | DecimalJsLike | number | string
    status: string
    autoRenew?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type ParkingPassUpdateManyMutationInput = {
    passType?: StringFieldUpdateOperationsInput | string
    passReference?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ParkingPassUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    placeId?: IntFieldUpdateOperationsInput | number
    passType?: StringFieldUpdateOperationsInput | string
    passReference?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ParkingPassPaymentCreateInput = {
    amount: Decimal | DecimalJsLike | number | string
    paymentStatus: string
    transactionReference?: string | null
    paymentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    parkingPass: ParkingPassCreateNestedOneWithoutParkingPassPaymentsInput
    paymentMethod: PaymentMethodCreateNestedOneWithoutParkingPassPaymentsInput
  }

  export type ParkingPassPaymentUncheckedCreateInput = {
    id?: number
    passId: number
    paymentMethodId: number
    amount: Decimal | DecimalJsLike | number | string
    paymentStatus: string
    transactionReference?: string | null
    paymentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type ParkingPassPaymentUpdateInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    transactionReference?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parkingPass?: ParkingPassUpdateOneRequiredWithoutParkingPassPaymentsNestedInput
    paymentMethod?: PaymentMethodUpdateOneRequiredWithoutParkingPassPaymentsNestedInput
  }

  export type ParkingPassPaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    passId?: IntFieldUpdateOperationsInput | number
    paymentMethodId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    transactionReference?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ParkingPassPaymentCreateManyInput = {
    id?: number
    passId: number
    paymentMethodId: number
    amount: Decimal | DecimalJsLike | number | string
    paymentStatus: string
    transactionReference?: string | null
    paymentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type ParkingPassPaymentUpdateManyMutationInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    transactionReference?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ParkingPassPaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    passId?: IntFieldUpdateOperationsInput | number
    paymentMethodId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    transactionReference?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccessLogCreateInput = {
    logType: string
    logTime?: Date | string
    verificationMethod?: string | null
    verifiedBy?: string | null
    location?: string | null
    notes?: string | null
    createdAt?: Date | string
    booking: BookingCreateNestedOneWithoutAccessLogsInput
  }

  export type AccessLogUncheckedCreateInput = {
    id?: number
    bookingId: number
    logType: string
    logTime?: Date | string
    verificationMethod?: string | null
    verifiedBy?: string | null
    location?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type AccessLogUpdateInput = {
    logType?: StringFieldUpdateOperationsInput | string
    logTime?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutAccessLogsNestedInput
  }

  export type AccessLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    logType?: StringFieldUpdateOperationsInput | string
    logTime?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessLogCreateManyInput = {
    id?: number
    bookingId: number
    logType: string
    logTime?: Date | string
    verificationMethod?: string | null
    verifiedBy?: string | null
    location?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type AccessLogUpdateManyMutationInput = {
    logType?: StringFieldUpdateOperationsInput | string
    logTime?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    logType?: StringFieldUpdateOperationsInput | string
    logTime?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingExtensionCreateInput = {
    originalEndTime: Date | string
    newEndTime: Date | string
    additionalCharge: Decimal | DecimalJsLike | number | string
    paymentStatus: string
    requestTime?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    booking: BookingCreateNestedOneWithoutBookingExtensionsInput
  }

  export type BookingExtensionUncheckedCreateInput = {
    id?: number
    bookingId: number
    originalEndTime: Date | string
    newEndTime: Date | string
    additionalCharge: Decimal | DecimalJsLike | number | string
    paymentStatus: string
    requestTime?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type BookingExtensionUpdateInput = {
    originalEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    newEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    additionalCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    requestTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    booking?: BookingUpdateOneRequiredWithoutBookingExtensionsNestedInput
  }

  export type BookingExtensionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    originalEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    newEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    additionalCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    requestTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BookingExtensionCreateManyInput = {
    id?: number
    bookingId: number
    originalEndTime: Date | string
    newEndTime: Date | string
    additionalCharge: Decimal | DecimalJsLike | number | string
    paymentStatus: string
    requestTime?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type BookingExtensionUpdateManyMutationInput = {
    originalEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    newEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    additionalCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    requestTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BookingExtensionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    originalEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    newEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    additionalCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    requestTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationSettingCreateInput = {
    emailEnabled?: boolean
    smsEnabled?: boolean
    pushEnabled?: boolean
    bookingConfirmation?: boolean
    paymentNotifications?: boolean
    reminderNotifications?: boolean
    marketingNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutNotificationSettingsInput
  }

  export type NotificationSettingUncheckedCreateInput = {
    id?: number
    userId: number
    emailEnabled?: boolean
    smsEnabled?: boolean
    pushEnabled?: boolean
    bookingConfirmation?: boolean
    paymentNotifications?: boolean
    reminderNotifications?: boolean
    marketingNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type NotificationSettingUpdateInput = {
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    smsEnabled?: BoolFieldUpdateOperationsInput | boolean
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingConfirmation?: BoolFieldUpdateOperationsInput | boolean
    paymentNotifications?: BoolFieldUpdateOperationsInput | boolean
    reminderNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutNotificationSettingsNestedInput
  }

  export type NotificationSettingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    smsEnabled?: BoolFieldUpdateOperationsInput | boolean
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingConfirmation?: BoolFieldUpdateOperationsInput | boolean
    paymentNotifications?: BoolFieldUpdateOperationsInput | boolean
    reminderNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationSettingCreateManyInput = {
    id?: number
    userId: number
    emailEnabled?: boolean
    smsEnabled?: boolean
    pushEnabled?: boolean
    bookingConfirmation?: boolean
    paymentNotifications?: boolean
    reminderNotifications?: boolean
    marketingNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type NotificationSettingUpdateManyMutationInput = {
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    smsEnabled?: BoolFieldUpdateOperationsInput | boolean
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingConfirmation?: BoolFieldUpdateOperationsInput | boolean
    paymentNotifications?: BoolFieldUpdateOperationsInput | boolean
    reminderNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationSettingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    smsEnabled?: BoolFieldUpdateOperationsInput | boolean
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingConfirmation?: BoolFieldUpdateOperationsInput | boolean
    paymentNotifications?: BoolFieldUpdateOperationsInput | boolean
    reminderNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationCreateInput = {
    notificationType: string
    channel: string
    content: string
    isRead?: boolean
    sentTime?: Date | string
    readTime?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
    booking?: BookingCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: number
    userId: number
    bookingId?: number | null
    notificationType: string
    channel: string
    content: string
    isRead?: boolean
    sentTime?: Date | string
    readTime?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    notificationType?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    readTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
    booking?: BookingUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    bookingId?: NullableIntFieldUpdateOperationsInput | number | null
    notificationType?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    readTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: number
    userId: number
    bookingId?: number | null
    notificationType: string
    channel: string
    content: string
    isRead?: boolean
    sentTime?: Date | string
    readTime?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    notificationType?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    readTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    bookingId?: NullableIntFieldUpdateOperationsInput | number | null
    notificationType?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    readTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaceRatingCreateInput = {
    ratingScore: Decimal | DecimalJsLike | number | string
    reviewComment?: string | null
    ratingDate?: Date | string
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    place: PlaceCreateNestedOneWithoutPlaceRatingsInput
    user: UserCreateNestedOneWithoutPlaceRatingsInput
    booking: BookingCreateNestedOneWithoutPlaceRatingsInput
  }

  export type PlaceRatingUncheckedCreateInput = {
    id?: number
    placeId: number
    userId: number
    bookingId: number
    ratingScore: Decimal | DecimalJsLike | number | string
    reviewComment?: string | null
    ratingDate?: Date | string
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type PlaceRatingUpdateInput = {
    ratingScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    ratingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    place?: PlaceUpdateOneRequiredWithoutPlaceRatingsNestedInput
    user?: UserUpdateOneRequiredWithoutPlaceRatingsNestedInput
    booking?: BookingUpdateOneRequiredWithoutPlaceRatingsNestedInput
  }

  export type PlaceRatingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    placeId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    ratingScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    ratingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlaceRatingCreateManyInput = {
    id?: number
    placeId: number
    userId: number
    bookingId: number
    ratingScore: Decimal | DecimalJsLike | number | string
    reviewComment?: string | null
    ratingDate?: Date | string
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type PlaceRatingUpdateManyMutationInput = {
    ratingScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    ratingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlaceRatingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    placeId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    ratingScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    ratingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OperatingHourCreateInput = {
    dayOfWeek: string
    openingTime?: Date | string | null
    closingTime?: Date | string | null
    is24hours?: boolean
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    place: PlaceCreateNestedOneWithoutOperatingHoursInput
  }

  export type OperatingHourUncheckedCreateInput = {
    id?: number
    placeId: number
    dayOfWeek: string
    openingTime?: Date | string | null
    closingTime?: Date | string | null
    is24hours?: boolean
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type OperatingHourUpdateInput = {
    dayOfWeek?: StringFieldUpdateOperationsInput | string
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is24hours?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    place?: PlaceUpdateOneRequiredWithoutOperatingHoursNestedInput
  }

  export type OperatingHourUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    placeId?: IntFieldUpdateOperationsInput | number
    dayOfWeek?: StringFieldUpdateOperationsInput | string
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is24hours?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OperatingHourCreateManyInput = {
    id?: number
    placeId: number
    dayOfWeek: string
    openingTime?: Date | string | null
    closingTime?: Date | string | null
    is24hours?: boolean
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type OperatingHourUpdateManyMutationInput = {
    dayOfWeek?: StringFieldUpdateOperationsInput | string
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is24hours?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OperatingHourUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    placeId?: IntFieldUpdateOperationsInput | number
    dayOfWeek?: StringFieldUpdateOperationsInput | string
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is24hours?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlaceAdminCreateInput = {
    username: string
    email: string
    passwordHash: string
    fullName: string
    role: string
    contactNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    place: PlaceCreateNestedOneWithoutPlaceAdminsInput
  }

  export type PlaceAdminUncheckedCreateInput = {
    id?: number
    placeId: number
    username: string
    email: string
    passwordHash: string
    fullName: string
    role: string
    contactNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type PlaceAdminUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    place?: PlaceUpdateOneRequiredWithoutPlaceAdminsNestedInput
  }

  export type PlaceAdminUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    placeId?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlaceAdminCreateManyInput = {
    id?: number
    placeId: number
    username: string
    email: string
    passwordHash: string
    fullName: string
    role: string
    contactNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type PlaceAdminUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlaceAdminUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    placeId?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SystemLogCreateInput = {
    entityType: string
    entityId: number
    action: string
    performedBy: string
    logLevel: string
    logDetails?: string | null
    logTime?: Date | string
    createdAt?: Date | string
  }

  export type SystemLogUncheckedCreateInput = {
    id?: number
    entityType: string
    entityId: number
    action: string
    performedBy: string
    logLevel: string
    logDetails?: string | null
    logTime?: Date | string
    createdAt?: Date | string
  }

  export type SystemLogUpdateInput = {
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    performedBy?: StringFieldUpdateOperationsInput | string
    logLevel?: StringFieldUpdateOperationsInput | string
    logDetails?: NullableStringFieldUpdateOperationsInput | string | null
    logTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    performedBy?: StringFieldUpdateOperationsInput | string
    logLevel?: StringFieldUpdateOperationsInput | string
    logDetails?: NullableStringFieldUpdateOperationsInput | string | null
    logTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemLogCreateManyInput = {
    id?: number
    entityType: string
    entityId: number
    action: string
    performedBy: string
    logLevel: string
    logDetails?: string | null
    logTime?: Date | string
    createdAt?: Date | string
  }

  export type SystemLogUpdateManyMutationInput = {
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    performedBy?: StringFieldUpdateOperationsInput | string
    logLevel?: StringFieldUpdateOperationsInput | string
    logDetails?: NullableStringFieldUpdateOperationsInput | string | null
    logTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    performedBy?: StringFieldUpdateOperationsInput | string
    logLevel?: StringFieldUpdateOperationsInput | string
    logDetails?: NullableStringFieldUpdateOperationsInput | string | null
    logTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailVerificationTokenCreateInput = {
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutEmailVerificationTokenInput
  }

  export type EmailVerificationTokenUncheckedCreateInput = {
    id?: number
    userId: number
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type EmailVerificationTokenUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmailVerificationTokenNestedInput
  }

  export type EmailVerificationTokenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailVerificationTokenCreateManyInput = {
    id?: number
    userId: number
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type EmailVerificationTokenUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailVerificationTokenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhoneVerificationOtpCreateInput = {
    phoneNumber: string
    otp: string
    expiresAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPhoneVerificationOtpInput
  }

  export type PhoneVerificationOtpUncheckedCreateInput = {
    id?: number
    userId: number
    phoneNumber: string
    otp: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type PhoneVerificationOtpUpdateInput = {
    phoneNumber?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPhoneVerificationOtpNestedInput
  }

  export type PhoneVerificationOtpUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhoneVerificationOtpCreateManyInput = {
    id?: number
    userId: number
    phoneNumber: string
    otp: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type PhoneVerificationOtpUpdateManyMutationInput = {
    phoneNumber?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhoneVerificationOtpUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateInput = {
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPasswordResetTokenInput
  }

  export type PasswordResetTokenUncheckedCreateInput = {
    id?: number
    userId: number
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type PasswordResetTokenUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPasswordResetTokenNestedInput
  }

  export type PasswordResetTokenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateManyInput = {
    id?: number
    userId: number
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type PasswordResetTokenUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserProfileNullableScalarRelationFilter = {
    is?: UserProfileWhereInput | null
    isNot?: UserProfileWhereInput | null
  }

  export type VehicleListRelationFilter = {
    every?: VehicleWhereInput
    some?: VehicleWhereInput
    none?: VehicleWhereInput
  }

  export type BookingListRelationFilter = {
    every?: BookingWhereInput
    some?: BookingWhereInput
    none?: BookingWhereInput
  }

  export type UserPaymentMethodListRelationFilter = {
    every?: UserPaymentMethodWhereInput
    some?: UserPaymentMethodWhereInput
    none?: UserPaymentMethodWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type ParkingPassListRelationFilter = {
    every?: ParkingPassWhereInput
    some?: ParkingPassWhereInput
    none?: ParkingPassWhereInput
  }

  export type PlaceRatingListRelationFilter = {
    every?: PlaceRatingWhereInput
    some?: PlaceRatingWhereInput
    none?: PlaceRatingWhereInput
  }

  export type NotificationSettingNullableScalarRelationFilter = {
    is?: NotificationSettingWhereInput | null
    isNot?: NotificationSettingWhereInput | null
  }

  export type UserSessionListRelationFilter = {
    every?: UserSessionWhereInput
    some?: UserSessionWhereInput
    none?: UserSessionWhereInput
  }

  export type EmailVerificationTokenListRelationFilter = {
    every?: EmailVerificationTokenWhereInput
    some?: EmailVerificationTokenWhereInput
    none?: EmailVerificationTokenWhereInput
  }

  export type PhoneVerificationOtpListRelationFilter = {
    every?: PhoneVerificationOtpWhereInput
    some?: PhoneVerificationOtpWhereInput
    none?: PhoneVerificationOtpWhereInput
  }

  export type PasswordResetTokenListRelationFilter = {
    every?: PasswordResetTokenWhereInput
    some?: PasswordResetTokenWhereInput
    none?: PasswordResetTokenWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type VehicleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserPaymentMethodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ParkingPassOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlaceRatingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailVerificationTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PhoneVerificationOtpOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PasswordResetTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    phoneNumber?: SortOrder
    accountType?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    accountStatus?: SortOrder
    googleId?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    phoneNumber?: SortOrder
    accountType?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    accountStatus?: SortOrder
    googleId?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    phoneNumber?: SortOrder
    accountType?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    accountStatus?: SortOrder
    googleId?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    deviceInfo?: SortOrder
    ipAddress?: SortOrder
    lastActivity?: SortOrder
    expiryTime?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSessionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    deviceInfo?: SortOrder
    ipAddress?: SortOrder
    lastActivity?: SortOrder
    expiryTime?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    deviceInfo?: SortOrder
    ipAddress?: SortOrder
    lastActivity?: SortOrder
    expiryTime?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSessionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    profilePhoto?: SortOrder
    gender?: SortOrder
    dateOfBirth?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProfileAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    profilePhoto?: SortOrder
    gender?: SortOrder
    dateOfBirth?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    profilePhoto?: SortOrder
    gender?: SortOrder
    dateOfBirth?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProfileSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type VehicleCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    licensePlate?: SortOrder
    vehicleType?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    color?: SortOrder
    rfidTag?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VehicleAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
  }

  export type VehicleMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    licensePlate?: SortOrder
    vehicleType?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    color?: SortOrder
    rfidTag?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VehicleMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    licensePlate?: SortOrder
    vehicleType?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    color?: SortOrder
    rfidTag?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VehicleSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type ParkingZoneListRelationFilter = {
    every?: ParkingZoneWhereInput
    some?: ParkingZoneWhereInput
    none?: ParkingZoneWhereInput
  }

  export type TariffPlanListRelationFilter = {
    every?: TariffPlanWhereInput
    some?: TariffPlanWhereInput
    none?: TariffPlanWhereInput
  }

  export type OperatingHourListRelationFilter = {
    every?: OperatingHourWhereInput
    some?: OperatingHourWhereInput
    none?: OperatingHourWhereInput
  }

  export type PlaceAdminListRelationFilter = {
    every?: PlaceAdminWhereInput
    some?: PlaceAdminWhereInput
    none?: PlaceAdminWhereInput
  }

  export type ParkingZoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TariffPlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OperatingHourOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlaceAdminOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlaceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    placeType?: SortOrder
    address?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    contactNumber?: SortOrder
    email?: SortOrder
    description?: SortOrder
    totalCapacity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlaceAvgOrderByAggregateInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    totalCapacity?: SortOrder
  }

  export type PlaceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    placeType?: SortOrder
    address?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    contactNumber?: SortOrder
    email?: SortOrder
    description?: SortOrder
    totalCapacity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlaceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    placeType?: SortOrder
    address?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    contactNumber?: SortOrder
    email?: SortOrder
    description?: SortOrder
    totalCapacity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlaceSumOrderByAggregateInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    totalCapacity?: SortOrder
  }

  export type PlaceScalarRelationFilter = {
    is?: PlaceWhereInput
    isNot?: PlaceWhereInput
  }

  export type ParkingSlotListRelationFilter = {
    every?: ParkingSlotWhereInput
    some?: ParkingSlotWhereInput
    none?: ParkingSlotWhereInput
  }

  export type ParkingSlotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ParkingZoneCountOrderByAggregateInput = {
    id?: SortOrder
    placeId?: SortOrder
    zoneName?: SortOrder
    floorLevel?: SortOrder
    zoneType?: SortOrder
    totalSlots?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParkingZoneAvgOrderByAggregateInput = {
    id?: SortOrder
    placeId?: SortOrder
    totalSlots?: SortOrder
  }

  export type ParkingZoneMaxOrderByAggregateInput = {
    id?: SortOrder
    placeId?: SortOrder
    zoneName?: SortOrder
    floorLevel?: SortOrder
    zoneType?: SortOrder
    totalSlots?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParkingZoneMinOrderByAggregateInput = {
    id?: SortOrder
    placeId?: SortOrder
    zoneName?: SortOrder
    floorLevel?: SortOrder
    zoneType?: SortOrder
    totalSlots?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParkingZoneSumOrderByAggregateInput = {
    id?: SortOrder
    placeId?: SortOrder
    totalSlots?: SortOrder
  }

  export type ParkingZoneScalarRelationFilter = {
    is?: ParkingZoneWhereInput
    isNot?: ParkingZoneWhereInput
  }

  export type SlotAvailabilityListRelationFilter = {
    every?: SlotAvailabilityWhereInput
    some?: SlotAvailabilityWhereInput
    none?: SlotAvailabilityWhereInput
  }

  export type SlotAvailabilityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ParkingSlotCountOrderByAggregateInput = {
    id?: SortOrder
    zoneId?: SortOrder
    slotNumber?: SortOrder
    slotType?: SortOrder
    isReserved?: SortOrder
    isOccupied?: SortOrder
    isDisabledFriendly?: SortOrder
    hasEvCharger?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParkingSlotAvgOrderByAggregateInput = {
    id?: SortOrder
    zoneId?: SortOrder
  }

  export type ParkingSlotMaxOrderByAggregateInput = {
    id?: SortOrder
    zoneId?: SortOrder
    slotNumber?: SortOrder
    slotType?: SortOrder
    isReserved?: SortOrder
    isOccupied?: SortOrder
    isDisabledFriendly?: SortOrder
    hasEvCharger?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParkingSlotMinOrderByAggregateInput = {
    id?: SortOrder
    zoneId?: SortOrder
    slotNumber?: SortOrder
    slotType?: SortOrder
    isReserved?: SortOrder
    isOccupied?: SortOrder
    isDisabledFriendly?: SortOrder
    hasEvCharger?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParkingSlotSumOrderByAggregateInput = {
    id?: SortOrder
    zoneId?: SortOrder
  }

  export type ParkingSlotScalarRelationFilter = {
    is?: ParkingSlotWhereInput
    isNot?: ParkingSlotWhereInput
  }

  export type SlotAvailabilityCountOrderByAggregateInput = {
    id?: SortOrder
    slotId?: SortOrder
    availableFrom?: SortOrder
    availableUntil?: SortOrder
    isBookable?: SortOrder
    statusReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SlotAvailabilityAvgOrderByAggregateInput = {
    id?: SortOrder
    slotId?: SortOrder
  }

  export type SlotAvailabilityMaxOrderByAggregateInput = {
    id?: SortOrder
    slotId?: SortOrder
    availableFrom?: SortOrder
    availableUntil?: SortOrder
    isBookable?: SortOrder
    statusReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SlotAvailabilityMinOrderByAggregateInput = {
    id?: SortOrder
    slotId?: SortOrder
    availableFrom?: SortOrder
    availableUntil?: SortOrder
    isBookable?: SortOrder
    statusReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SlotAvailabilitySumOrderByAggregateInput = {
    id?: SortOrder
    slotId?: SortOrder
  }

  export type TariffRateListRelationFilter = {
    every?: TariffRateWhereInput
    some?: TariffRateWhereInput
    none?: TariffRateWhereInput
  }

  export type TariffRateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TariffPlanCountOrderByAggregateInput = {
    id?: SortOrder
    placeId?: SortOrder
    planName?: SortOrder
    description?: SortOrder
    effectiveFrom?: SortOrder
    effectiveUntil?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TariffPlanAvgOrderByAggregateInput = {
    id?: SortOrder
    placeId?: SortOrder
  }

  export type TariffPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    placeId?: SortOrder
    planName?: SortOrder
    description?: SortOrder
    effectiveFrom?: SortOrder
    effectiveUntil?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TariffPlanMinOrderByAggregateInput = {
    id?: SortOrder
    placeId?: SortOrder
    planName?: SortOrder
    description?: SortOrder
    effectiveFrom?: SortOrder
    effectiveUntil?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TariffPlanSumOrderByAggregateInput = {
    id?: SortOrder
    placeId?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type TariffPlanScalarRelationFilter = {
    is?: TariffPlanWhereInput
    isNot?: TariffPlanWhereInput
  }

  export type TariffRateCountOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    vehicleType?: SortOrder
    slotType?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    dayCategory?: SortOrder
    basePrice?: SortOrder
    hourlyRate?: SortOrder
    dayRate?: SortOrder
    minimumCharge?: SortOrder
    gracePeriodMinutes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TariffRateAvgOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    basePrice?: SortOrder
    hourlyRate?: SortOrder
    dayRate?: SortOrder
    minimumCharge?: SortOrder
    gracePeriodMinutes?: SortOrder
  }

  export type TariffRateMaxOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    vehicleType?: SortOrder
    slotType?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    dayCategory?: SortOrder
    basePrice?: SortOrder
    hourlyRate?: SortOrder
    dayRate?: SortOrder
    minimumCharge?: SortOrder
    gracePeriodMinutes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TariffRateMinOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    vehicleType?: SortOrder
    slotType?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    dayCategory?: SortOrder
    basePrice?: SortOrder
    hourlyRate?: SortOrder
    dayRate?: SortOrder
    minimumCharge?: SortOrder
    gracePeriodMinutes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TariffRateSumOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    basePrice?: SortOrder
    hourlyRate?: SortOrder
    dayRate?: SortOrder
    minimumCharge?: SortOrder
    gracePeriodMinutes?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type VehicleScalarRelationFilter = {
    is?: VehicleWhereInput
    isNot?: VehicleWhereInput
  }

  export type PromoCodeNullableScalarRelationFilter = {
    is?: PromoCodeWhereInput | null
    isNot?: PromoCodeWhereInput | null
  }

  export type BookingStatusLogListRelationFilter = {
    every?: BookingStatusLogWhereInput
    some?: BookingStatusLogWhereInput
    none?: BookingStatusLogWhereInput
  }

  export type BookingPaymentNullableScalarRelationFilter = {
    is?: BookingPaymentWhereInput | null
    isNot?: BookingPaymentWhereInput | null
  }

  export type AccessLogListRelationFilter = {
    every?: AccessLogWhereInput
    some?: AccessLogWhereInput
    none?: AccessLogWhereInput
  }

  export type BookingExtensionListRelationFilter = {
    every?: BookingExtensionWhereInput
    some?: BookingExtensionWhereInput
    none?: BookingExtensionWhereInput
  }

  export type BookingStatusLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccessLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingExtensionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vehicleId?: SortOrder
    slotId?: SortOrder
    promoCodeId?: SortOrder
    bookingReference?: SortOrder
    bookingTime?: SortOrder
    scheduledEntry?: SortOrder
    scheduledExit?: SortOrder
    actualEntry?: SortOrder
    actualExit?: SortOrder
    qrCode?: SortOrder
    bookingStatus?: SortOrder
    estimatedPrice?: SortOrder
    finalPrice?: SortOrder
    cancellationReason?: SortOrder
    cancellationTimeMinutes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vehicleId?: SortOrder
    slotId?: SortOrder
    promoCodeId?: SortOrder
    estimatedPrice?: SortOrder
    finalPrice?: SortOrder
    cancellationTimeMinutes?: SortOrder
  }

  export type BookingMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vehicleId?: SortOrder
    slotId?: SortOrder
    promoCodeId?: SortOrder
    bookingReference?: SortOrder
    bookingTime?: SortOrder
    scheduledEntry?: SortOrder
    scheduledExit?: SortOrder
    actualEntry?: SortOrder
    actualExit?: SortOrder
    qrCode?: SortOrder
    bookingStatus?: SortOrder
    estimatedPrice?: SortOrder
    finalPrice?: SortOrder
    cancellationReason?: SortOrder
    cancellationTimeMinutes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vehicleId?: SortOrder
    slotId?: SortOrder
    promoCodeId?: SortOrder
    bookingReference?: SortOrder
    bookingTime?: SortOrder
    scheduledEntry?: SortOrder
    scheduledExit?: SortOrder
    actualEntry?: SortOrder
    actualExit?: SortOrder
    qrCode?: SortOrder
    bookingStatus?: SortOrder
    estimatedPrice?: SortOrder
    finalPrice?: SortOrder
    cancellationReason?: SortOrder
    cancellationTimeMinutes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vehicleId?: SortOrder
    slotId?: SortOrder
    promoCodeId?: SortOrder
    estimatedPrice?: SortOrder
    finalPrice?: SortOrder
    cancellationTimeMinutes?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BookingScalarRelationFilter = {
    is?: BookingWhereInput
    isNot?: BookingWhereInput
  }

  export type BookingStatusLogCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    previousStatus?: SortOrder
    newStatus?: SortOrder
    changedBy?: SortOrder
    reason?: SortOrder
    statusTime?: SortOrder
    createdAt?: SortOrder
  }

  export type BookingStatusLogAvgOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
  }

  export type BookingStatusLogMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    previousStatus?: SortOrder
    newStatus?: SortOrder
    changedBy?: SortOrder
    reason?: SortOrder
    statusTime?: SortOrder
    createdAt?: SortOrder
  }

  export type BookingStatusLogMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    previousStatus?: SortOrder
    newStatus?: SortOrder
    changedBy?: SortOrder
    reason?: SortOrder
    statusTime?: SortOrder
    createdAt?: SortOrder
  }

  export type BookingStatusLogSumOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
  }

  export type PaymentTransactionListRelationFilter = {
    every?: PaymentTransactionWhereInput
    some?: PaymentTransactionWhereInput
    none?: PaymentTransactionWhereInput
  }

  export type RefundTransactionListRelationFilter = {
    every?: RefundTransactionWhereInput
    some?: RefundTransactionWhereInput
    none?: RefundTransactionWhereInput
  }

  export type PaymentTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RefundTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    paymentReference?: SortOrder
    paymentStatus?: SortOrder
    originalAmount?: SortOrder
    discountAmount?: SortOrder
    taxAmount?: SortOrder
    surchargeAmount?: SortOrder
    finalAmount?: SortOrder
    isPrepaid?: SortOrder
    isRefunded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingPaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    originalAmount?: SortOrder
    discountAmount?: SortOrder
    taxAmount?: SortOrder
    surchargeAmount?: SortOrder
    finalAmount?: SortOrder
  }

  export type BookingPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    paymentReference?: SortOrder
    paymentStatus?: SortOrder
    originalAmount?: SortOrder
    discountAmount?: SortOrder
    taxAmount?: SortOrder
    surchargeAmount?: SortOrder
    finalAmount?: SortOrder
    isPrepaid?: SortOrder
    isRefunded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    paymentReference?: SortOrder
    paymentStatus?: SortOrder
    originalAmount?: SortOrder
    discountAmount?: SortOrder
    taxAmount?: SortOrder
    surchargeAmount?: SortOrder
    finalAmount?: SortOrder
    isPrepaid?: SortOrder
    isRefunded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingPaymentSumOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    originalAmount?: SortOrder
    discountAmount?: SortOrder
    taxAmount?: SortOrder
    surchargeAmount?: SortOrder
    finalAmount?: SortOrder
  }

  export type BookingPaymentScalarRelationFilter = {
    is?: BookingPaymentWhereInput
    isNot?: BookingPaymentWhereInput
  }

  export type PaymentMethodScalarRelationFilter = {
    is?: PaymentMethodWhereInput
    isNot?: PaymentMethodWhereInput
  }

  export type PaymentTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    paymentMethodId?: SortOrder
    transactionReference?: SortOrder
    transactionType?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    transactionStatus?: SortOrder
    gatewayResponse?: SortOrder
    transactionData?: SortOrder
    transactionTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentTransactionAvgOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    paymentMethodId?: SortOrder
    amount?: SortOrder
  }

  export type PaymentTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    paymentMethodId?: SortOrder
    transactionReference?: SortOrder
    transactionType?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    transactionStatus?: SortOrder
    gatewayResponse?: SortOrder
    transactionData?: SortOrder
    transactionTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    paymentMethodId?: SortOrder
    transactionReference?: SortOrder
    transactionType?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    transactionStatus?: SortOrder
    gatewayResponse?: SortOrder
    transactionData?: SortOrder
    transactionTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentTransactionSumOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    paymentMethodId?: SortOrder
    amount?: SortOrder
  }

  export type RefundTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    refundReference?: SortOrder
    refundAmount?: SortOrder
    refundReason?: SortOrder
    refundStatus?: SortOrder
    processorResponse?: SortOrder
    refundData?: SortOrder
    refundTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RefundTransactionAvgOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    refundAmount?: SortOrder
  }

  export type RefundTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    refundReference?: SortOrder
    refundAmount?: SortOrder
    refundReason?: SortOrder
    refundStatus?: SortOrder
    processorResponse?: SortOrder
    refundData?: SortOrder
    refundTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RefundTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    refundReference?: SortOrder
    refundAmount?: SortOrder
    refundReason?: SortOrder
    refundStatus?: SortOrder
    processorResponse?: SortOrder
    refundData?: SortOrder
    refundTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RefundTransactionSumOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    refundAmount?: SortOrder
  }

  export type ParkingPassPaymentListRelationFilter = {
    every?: ParkingPassPaymentWhereInput
    some?: ParkingPassPaymentWhereInput
    none?: ParkingPassPaymentWhereInput
  }

  export type ParkingPassPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentMethodCountOrderByAggregateInput = {
    id?: SortOrder
    methodName?: SortOrder
    provider?: SortOrder
    methodType?: SortOrder
    description?: SortOrder
    processingFeePercent?: SortOrder
    fixedFee?: SortOrder
    supportsRefunds?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodAvgOrderByAggregateInput = {
    id?: SortOrder
    processingFeePercent?: SortOrder
    fixedFee?: SortOrder
  }

  export type PaymentMethodMaxOrderByAggregateInput = {
    id?: SortOrder
    methodName?: SortOrder
    provider?: SortOrder
    methodType?: SortOrder
    description?: SortOrder
    processingFeePercent?: SortOrder
    fixedFee?: SortOrder
    supportsRefunds?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodMinOrderByAggregateInput = {
    id?: SortOrder
    methodName?: SortOrder
    provider?: SortOrder
    methodType?: SortOrder
    description?: SortOrder
    processingFeePercent?: SortOrder
    fixedFee?: SortOrder
    supportsRefunds?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodSumOrderByAggregateInput = {
    id?: SortOrder
    processingFeePercent?: SortOrder
    fixedFee?: SortOrder
  }

  export type UserPaymentMethodCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    paymentMethodId?: SortOrder
    tokenReference?: SortOrder
    maskedInfo?: SortOrder
    expiryInfo?: SortOrder
    isDefault?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPaymentMethodAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    paymentMethodId?: SortOrder
  }

  export type UserPaymentMethodMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    paymentMethodId?: SortOrder
    tokenReference?: SortOrder
    maskedInfo?: SortOrder
    expiryInfo?: SortOrder
    isDefault?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPaymentMethodMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    paymentMethodId?: SortOrder
    tokenReference?: SortOrder
    maskedInfo?: SortOrder
    expiryInfo?: SortOrder
    isDefault?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPaymentMethodSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    paymentMethodId?: SortOrder
  }

  export type PromoCodeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    minimumSpend?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    usageLimit?: SortOrder
    usageCount?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromoCodeAvgOrderByAggregateInput = {
    id?: SortOrder
    discountValue?: SortOrder
    minimumSpend?: SortOrder
    usageLimit?: SortOrder
    usageCount?: SortOrder
  }

  export type PromoCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    minimumSpend?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    usageLimit?: SortOrder
    usageCount?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromoCodeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    minimumSpend?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    usageLimit?: SortOrder
    usageCount?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromoCodeSumOrderByAggregateInput = {
    id?: SortOrder
    discountValue?: SortOrder
    minimumSpend?: SortOrder
    usageLimit?: SortOrder
    usageCount?: SortOrder
  }

  export type ParkingPassCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    placeId?: SortOrder
    passType?: SortOrder
    passReference?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    price?: SortOrder
    status?: SortOrder
    autoRenew?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParkingPassAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    placeId?: SortOrder
    price?: SortOrder
  }

  export type ParkingPassMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    placeId?: SortOrder
    passType?: SortOrder
    passReference?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    price?: SortOrder
    status?: SortOrder
    autoRenew?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParkingPassMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    placeId?: SortOrder
    passType?: SortOrder
    passReference?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    price?: SortOrder
    status?: SortOrder
    autoRenew?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParkingPassSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    placeId?: SortOrder
    price?: SortOrder
  }

  export type ParkingPassScalarRelationFilter = {
    is?: ParkingPassWhereInput
    isNot?: ParkingPassWhereInput
  }

  export type ParkingPassPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    passId?: SortOrder
    paymentMethodId?: SortOrder
    amount?: SortOrder
    paymentStatus?: SortOrder
    transactionReference?: SortOrder
    paymentDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParkingPassPaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    passId?: SortOrder
    paymentMethodId?: SortOrder
    amount?: SortOrder
  }

  export type ParkingPassPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    passId?: SortOrder
    paymentMethodId?: SortOrder
    amount?: SortOrder
    paymentStatus?: SortOrder
    transactionReference?: SortOrder
    paymentDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParkingPassPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    passId?: SortOrder
    paymentMethodId?: SortOrder
    amount?: SortOrder
    paymentStatus?: SortOrder
    transactionReference?: SortOrder
    paymentDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParkingPassPaymentSumOrderByAggregateInput = {
    id?: SortOrder
    passId?: SortOrder
    paymentMethodId?: SortOrder
    amount?: SortOrder
  }

  export type AccessLogCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    logType?: SortOrder
    logTime?: SortOrder
    verificationMethod?: SortOrder
    verifiedBy?: SortOrder
    location?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type AccessLogAvgOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
  }

  export type AccessLogMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    logType?: SortOrder
    logTime?: SortOrder
    verificationMethod?: SortOrder
    verifiedBy?: SortOrder
    location?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type AccessLogMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    logType?: SortOrder
    logTime?: SortOrder
    verificationMethod?: SortOrder
    verifiedBy?: SortOrder
    location?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type AccessLogSumOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
  }

  export type BookingExtensionCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    originalEndTime?: SortOrder
    newEndTime?: SortOrder
    additionalCharge?: SortOrder
    paymentStatus?: SortOrder
    requestTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingExtensionAvgOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    additionalCharge?: SortOrder
  }

  export type BookingExtensionMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    originalEndTime?: SortOrder
    newEndTime?: SortOrder
    additionalCharge?: SortOrder
    paymentStatus?: SortOrder
    requestTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingExtensionMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    originalEndTime?: SortOrder
    newEndTime?: SortOrder
    additionalCharge?: SortOrder
    paymentStatus?: SortOrder
    requestTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingExtensionSumOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    additionalCharge?: SortOrder
  }

  export type NotificationSettingCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    emailEnabled?: SortOrder
    smsEnabled?: SortOrder
    pushEnabled?: SortOrder
    bookingConfirmation?: SortOrder
    paymentNotifications?: SortOrder
    reminderNotifications?: SortOrder
    marketingNotifications?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationSettingAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type NotificationSettingMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    emailEnabled?: SortOrder
    smsEnabled?: SortOrder
    pushEnabled?: SortOrder
    bookingConfirmation?: SortOrder
    paymentNotifications?: SortOrder
    reminderNotifications?: SortOrder
    marketingNotifications?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationSettingMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    emailEnabled?: SortOrder
    smsEnabled?: SortOrder
    pushEnabled?: SortOrder
    bookingConfirmation?: SortOrder
    paymentNotifications?: SortOrder
    reminderNotifications?: SortOrder
    marketingNotifications?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationSettingSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type BookingNullableScalarRelationFilter = {
    is?: BookingWhereInput | null
    isNot?: BookingWhereInput | null
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bookingId?: SortOrder
    notificationType?: SortOrder
    channel?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    sentTime?: SortOrder
    readTime?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bookingId?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bookingId?: SortOrder
    notificationType?: SortOrder
    channel?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    sentTime?: SortOrder
    readTime?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bookingId?: SortOrder
    notificationType?: SortOrder
    channel?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    sentTime?: SortOrder
    readTime?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bookingId?: SortOrder
  }

  export type PlaceRatingCountOrderByAggregateInput = {
    id?: SortOrder
    placeId?: SortOrder
    userId?: SortOrder
    bookingId?: SortOrder
    ratingScore?: SortOrder
    reviewComment?: SortOrder
    ratingDate?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlaceRatingAvgOrderByAggregateInput = {
    id?: SortOrder
    placeId?: SortOrder
    userId?: SortOrder
    bookingId?: SortOrder
    ratingScore?: SortOrder
  }

  export type PlaceRatingMaxOrderByAggregateInput = {
    id?: SortOrder
    placeId?: SortOrder
    userId?: SortOrder
    bookingId?: SortOrder
    ratingScore?: SortOrder
    reviewComment?: SortOrder
    ratingDate?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlaceRatingMinOrderByAggregateInput = {
    id?: SortOrder
    placeId?: SortOrder
    userId?: SortOrder
    bookingId?: SortOrder
    ratingScore?: SortOrder
    reviewComment?: SortOrder
    ratingDate?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlaceRatingSumOrderByAggregateInput = {
    id?: SortOrder
    placeId?: SortOrder
    userId?: SortOrder
    bookingId?: SortOrder
    ratingScore?: SortOrder
  }

  export type OperatingHourCountOrderByAggregateInput = {
    id?: SortOrder
    placeId?: SortOrder
    dayOfWeek?: SortOrder
    openingTime?: SortOrder
    closingTime?: SortOrder
    is24hours?: SortOrder
    isClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OperatingHourAvgOrderByAggregateInput = {
    id?: SortOrder
    placeId?: SortOrder
  }

  export type OperatingHourMaxOrderByAggregateInput = {
    id?: SortOrder
    placeId?: SortOrder
    dayOfWeek?: SortOrder
    openingTime?: SortOrder
    closingTime?: SortOrder
    is24hours?: SortOrder
    isClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OperatingHourMinOrderByAggregateInput = {
    id?: SortOrder
    placeId?: SortOrder
    dayOfWeek?: SortOrder
    openingTime?: SortOrder
    closingTime?: SortOrder
    is24hours?: SortOrder
    isClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OperatingHourSumOrderByAggregateInput = {
    id?: SortOrder
    placeId?: SortOrder
  }

  export type PlaceAdminCountOrderByAggregateInput = {
    id?: SortOrder
    placeId?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    contactNumber?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlaceAdminAvgOrderByAggregateInput = {
    id?: SortOrder
    placeId?: SortOrder
  }

  export type PlaceAdminMaxOrderByAggregateInput = {
    id?: SortOrder
    placeId?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    contactNumber?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlaceAdminMinOrderByAggregateInput = {
    id?: SortOrder
    placeId?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    contactNumber?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlaceAdminSumOrderByAggregateInput = {
    id?: SortOrder
    placeId?: SortOrder
  }

  export type SystemLogCountOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    performedBy?: SortOrder
    logLevel?: SortOrder
    logDetails?: SortOrder
    logTime?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemLogAvgOrderByAggregateInput = {
    id?: SortOrder
    entityId?: SortOrder
  }

  export type SystemLogMaxOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    performedBy?: SortOrder
    logLevel?: SortOrder
    logDetails?: SortOrder
    logTime?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemLogMinOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    performedBy?: SortOrder
    logLevel?: SortOrder
    logDetails?: SortOrder
    logTime?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemLogSumOrderByAggregateInput = {
    id?: SortOrder
    entityId?: SortOrder
  }

  export type EmailVerificationTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailVerificationTokenAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EmailVerificationTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailVerificationTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailVerificationTokenSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type PhoneVerificationOtpCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    phoneNumber?: SortOrder
    otp?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PhoneVerificationOtpAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type PhoneVerificationOtpMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    phoneNumber?: SortOrder
    otp?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PhoneVerificationOtpMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    phoneNumber?: SortOrder
    otp?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PhoneVerificationOtpSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type PasswordResetTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type PasswordResetTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    connect?: UserProfileWhereUniqueInput
  }

  export type VehicleCreateNestedManyWithoutUserInput = {
    create?: XOR<VehicleCreateWithoutUserInput, VehicleUncheckedCreateWithoutUserInput> | VehicleCreateWithoutUserInput[] | VehicleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutUserInput | VehicleCreateOrConnectWithoutUserInput[]
    createMany?: VehicleCreateManyUserInputEnvelope
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutUserInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type UserPaymentMethodCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPaymentMethodCreateWithoutUserInput, UserPaymentMethodUncheckedCreateWithoutUserInput> | UserPaymentMethodCreateWithoutUserInput[] | UserPaymentMethodUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPaymentMethodCreateOrConnectWithoutUserInput | UserPaymentMethodCreateOrConnectWithoutUserInput[]
    createMany?: UserPaymentMethodCreateManyUserInputEnvelope
    connect?: UserPaymentMethodWhereUniqueInput | UserPaymentMethodWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ParkingPassCreateNestedManyWithoutUserInput = {
    create?: XOR<ParkingPassCreateWithoutUserInput, ParkingPassUncheckedCreateWithoutUserInput> | ParkingPassCreateWithoutUserInput[] | ParkingPassUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ParkingPassCreateOrConnectWithoutUserInput | ParkingPassCreateOrConnectWithoutUserInput[]
    createMany?: ParkingPassCreateManyUserInputEnvelope
    connect?: ParkingPassWhereUniqueInput | ParkingPassWhereUniqueInput[]
  }

  export type PlaceRatingCreateNestedManyWithoutUserInput = {
    create?: XOR<PlaceRatingCreateWithoutUserInput, PlaceRatingUncheckedCreateWithoutUserInput> | PlaceRatingCreateWithoutUserInput[] | PlaceRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlaceRatingCreateOrConnectWithoutUserInput | PlaceRatingCreateOrConnectWithoutUserInput[]
    createMany?: PlaceRatingCreateManyUserInputEnvelope
    connect?: PlaceRatingWhereUniqueInput | PlaceRatingWhereUniqueInput[]
  }

  export type NotificationSettingCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationSettingCreateWithoutUserInput, NotificationSettingUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationSettingCreateOrConnectWithoutUserInput
    connect?: NotificationSettingWhereUniqueInput
  }

  export type UserSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type EmailVerificationTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<EmailVerificationTokenCreateWithoutUserInput, EmailVerificationTokenUncheckedCreateWithoutUserInput> | EmailVerificationTokenCreateWithoutUserInput[] | EmailVerificationTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailVerificationTokenCreateOrConnectWithoutUserInput | EmailVerificationTokenCreateOrConnectWithoutUserInput[]
    createMany?: EmailVerificationTokenCreateManyUserInputEnvelope
    connect?: EmailVerificationTokenWhereUniqueInput | EmailVerificationTokenWhereUniqueInput[]
  }

  export type PhoneVerificationOtpCreateNestedManyWithoutUserInput = {
    create?: XOR<PhoneVerificationOtpCreateWithoutUserInput, PhoneVerificationOtpUncheckedCreateWithoutUserInput> | PhoneVerificationOtpCreateWithoutUserInput[] | PhoneVerificationOtpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PhoneVerificationOtpCreateOrConnectWithoutUserInput | PhoneVerificationOtpCreateOrConnectWithoutUserInput[]
    createMany?: PhoneVerificationOtpCreateManyUserInputEnvelope
    connect?: PhoneVerificationOtpWhereUniqueInput | PhoneVerificationOtpWhereUniqueInput[]
  }

  export type PasswordResetTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
  }

  export type UserProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    connect?: UserProfileWhereUniqueInput
  }

  export type VehicleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<VehicleCreateWithoutUserInput, VehicleUncheckedCreateWithoutUserInput> | VehicleCreateWithoutUserInput[] | VehicleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutUserInput | VehicleCreateOrConnectWithoutUserInput[]
    createMany?: VehicleCreateManyUserInputEnvelope
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type UserPaymentMethodUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPaymentMethodCreateWithoutUserInput, UserPaymentMethodUncheckedCreateWithoutUserInput> | UserPaymentMethodCreateWithoutUserInput[] | UserPaymentMethodUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPaymentMethodCreateOrConnectWithoutUserInput | UserPaymentMethodCreateOrConnectWithoutUserInput[]
    createMany?: UserPaymentMethodCreateManyUserInputEnvelope
    connect?: UserPaymentMethodWhereUniqueInput | UserPaymentMethodWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ParkingPassUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ParkingPassCreateWithoutUserInput, ParkingPassUncheckedCreateWithoutUserInput> | ParkingPassCreateWithoutUserInput[] | ParkingPassUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ParkingPassCreateOrConnectWithoutUserInput | ParkingPassCreateOrConnectWithoutUserInput[]
    createMany?: ParkingPassCreateManyUserInputEnvelope
    connect?: ParkingPassWhereUniqueInput | ParkingPassWhereUniqueInput[]
  }

  export type PlaceRatingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PlaceRatingCreateWithoutUserInput, PlaceRatingUncheckedCreateWithoutUserInput> | PlaceRatingCreateWithoutUserInput[] | PlaceRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlaceRatingCreateOrConnectWithoutUserInput | PlaceRatingCreateOrConnectWithoutUserInput[]
    createMany?: PlaceRatingCreateManyUserInputEnvelope
    connect?: PlaceRatingWhereUniqueInput | PlaceRatingWhereUniqueInput[]
  }

  export type NotificationSettingUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationSettingCreateWithoutUserInput, NotificationSettingUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationSettingCreateOrConnectWithoutUserInput
    connect?: NotificationSettingWhereUniqueInput
  }

  export type UserSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EmailVerificationTokenCreateWithoutUserInput, EmailVerificationTokenUncheckedCreateWithoutUserInput> | EmailVerificationTokenCreateWithoutUserInput[] | EmailVerificationTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailVerificationTokenCreateOrConnectWithoutUserInput | EmailVerificationTokenCreateOrConnectWithoutUserInput[]
    createMany?: EmailVerificationTokenCreateManyUserInputEnvelope
    connect?: EmailVerificationTokenWhereUniqueInput | EmailVerificationTokenWhereUniqueInput[]
  }

  export type PhoneVerificationOtpUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PhoneVerificationOtpCreateWithoutUserInput, PhoneVerificationOtpUncheckedCreateWithoutUserInput> | PhoneVerificationOtpCreateWithoutUserInput[] | PhoneVerificationOtpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PhoneVerificationOtpCreateOrConnectWithoutUserInput | PhoneVerificationOtpCreateOrConnectWithoutUserInput[]
    createMany?: PhoneVerificationOtpCreateManyUserInputEnvelope
    connect?: PhoneVerificationOtpWhereUniqueInput | PhoneVerificationOtpWhereUniqueInput[]
  }

  export type PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    upsert?: UserProfileUpsertWithoutUserInput
    disconnect?: UserProfileWhereInput | boolean
    delete?: UserProfileWhereInput | boolean
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutUserInput, UserProfileUpdateWithoutUserInput>, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type VehicleUpdateManyWithoutUserNestedInput = {
    create?: XOR<VehicleCreateWithoutUserInput, VehicleUncheckedCreateWithoutUserInput> | VehicleCreateWithoutUserInput[] | VehicleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutUserInput | VehicleCreateOrConnectWithoutUserInput[]
    upsert?: VehicleUpsertWithWhereUniqueWithoutUserInput | VehicleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VehicleCreateManyUserInputEnvelope
    set?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    disconnect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    delete?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    update?: VehicleUpdateWithWhereUniqueWithoutUserInput | VehicleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VehicleUpdateManyWithWhereWithoutUserInput | VehicleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VehicleScalarWhereInput | VehicleScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutUserInput | BookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutUserInput | BookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutUserInput | BookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type UserPaymentMethodUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPaymentMethodCreateWithoutUserInput, UserPaymentMethodUncheckedCreateWithoutUserInput> | UserPaymentMethodCreateWithoutUserInput[] | UserPaymentMethodUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPaymentMethodCreateOrConnectWithoutUserInput | UserPaymentMethodCreateOrConnectWithoutUserInput[]
    upsert?: UserPaymentMethodUpsertWithWhereUniqueWithoutUserInput | UserPaymentMethodUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPaymentMethodCreateManyUserInputEnvelope
    set?: UserPaymentMethodWhereUniqueInput | UserPaymentMethodWhereUniqueInput[]
    disconnect?: UserPaymentMethodWhereUniqueInput | UserPaymentMethodWhereUniqueInput[]
    delete?: UserPaymentMethodWhereUniqueInput | UserPaymentMethodWhereUniqueInput[]
    connect?: UserPaymentMethodWhereUniqueInput | UserPaymentMethodWhereUniqueInput[]
    update?: UserPaymentMethodUpdateWithWhereUniqueWithoutUserInput | UserPaymentMethodUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPaymentMethodUpdateManyWithWhereWithoutUserInput | UserPaymentMethodUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPaymentMethodScalarWhereInput | UserPaymentMethodScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ParkingPassUpdateManyWithoutUserNestedInput = {
    create?: XOR<ParkingPassCreateWithoutUserInput, ParkingPassUncheckedCreateWithoutUserInput> | ParkingPassCreateWithoutUserInput[] | ParkingPassUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ParkingPassCreateOrConnectWithoutUserInput | ParkingPassCreateOrConnectWithoutUserInput[]
    upsert?: ParkingPassUpsertWithWhereUniqueWithoutUserInput | ParkingPassUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ParkingPassCreateManyUserInputEnvelope
    set?: ParkingPassWhereUniqueInput | ParkingPassWhereUniqueInput[]
    disconnect?: ParkingPassWhereUniqueInput | ParkingPassWhereUniqueInput[]
    delete?: ParkingPassWhereUniqueInput | ParkingPassWhereUniqueInput[]
    connect?: ParkingPassWhereUniqueInput | ParkingPassWhereUniqueInput[]
    update?: ParkingPassUpdateWithWhereUniqueWithoutUserInput | ParkingPassUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ParkingPassUpdateManyWithWhereWithoutUserInput | ParkingPassUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ParkingPassScalarWhereInput | ParkingPassScalarWhereInput[]
  }

  export type PlaceRatingUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlaceRatingCreateWithoutUserInput, PlaceRatingUncheckedCreateWithoutUserInput> | PlaceRatingCreateWithoutUserInput[] | PlaceRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlaceRatingCreateOrConnectWithoutUserInput | PlaceRatingCreateOrConnectWithoutUserInput[]
    upsert?: PlaceRatingUpsertWithWhereUniqueWithoutUserInput | PlaceRatingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlaceRatingCreateManyUserInputEnvelope
    set?: PlaceRatingWhereUniqueInput | PlaceRatingWhereUniqueInput[]
    disconnect?: PlaceRatingWhereUniqueInput | PlaceRatingWhereUniqueInput[]
    delete?: PlaceRatingWhereUniqueInput | PlaceRatingWhereUniqueInput[]
    connect?: PlaceRatingWhereUniqueInput | PlaceRatingWhereUniqueInput[]
    update?: PlaceRatingUpdateWithWhereUniqueWithoutUserInput | PlaceRatingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlaceRatingUpdateManyWithWhereWithoutUserInput | PlaceRatingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlaceRatingScalarWhereInput | PlaceRatingScalarWhereInput[]
  }

  export type NotificationSettingUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationSettingCreateWithoutUserInput, NotificationSettingUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationSettingCreateOrConnectWithoutUserInput
    upsert?: NotificationSettingUpsertWithoutUserInput
    disconnect?: NotificationSettingWhereInput | boolean
    delete?: NotificationSettingWhereInput | boolean
    connect?: NotificationSettingWhereUniqueInput
    update?: XOR<XOR<NotificationSettingUpdateToOneWithWhereWithoutUserInput, NotificationSettingUpdateWithoutUserInput>, NotificationSettingUncheckedUpdateWithoutUserInput>
  }

  export type UserSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type EmailVerificationTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmailVerificationTokenCreateWithoutUserInput, EmailVerificationTokenUncheckedCreateWithoutUserInput> | EmailVerificationTokenCreateWithoutUserInput[] | EmailVerificationTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailVerificationTokenCreateOrConnectWithoutUserInput | EmailVerificationTokenCreateOrConnectWithoutUserInput[]
    upsert?: EmailVerificationTokenUpsertWithWhereUniqueWithoutUserInput | EmailVerificationTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmailVerificationTokenCreateManyUserInputEnvelope
    set?: EmailVerificationTokenWhereUniqueInput | EmailVerificationTokenWhereUniqueInput[]
    disconnect?: EmailVerificationTokenWhereUniqueInput | EmailVerificationTokenWhereUniqueInput[]
    delete?: EmailVerificationTokenWhereUniqueInput | EmailVerificationTokenWhereUniqueInput[]
    connect?: EmailVerificationTokenWhereUniqueInput | EmailVerificationTokenWhereUniqueInput[]
    update?: EmailVerificationTokenUpdateWithWhereUniqueWithoutUserInput | EmailVerificationTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmailVerificationTokenUpdateManyWithWhereWithoutUserInput | EmailVerificationTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmailVerificationTokenScalarWhereInput | EmailVerificationTokenScalarWhereInput[]
  }

  export type PhoneVerificationOtpUpdateManyWithoutUserNestedInput = {
    create?: XOR<PhoneVerificationOtpCreateWithoutUserInput, PhoneVerificationOtpUncheckedCreateWithoutUserInput> | PhoneVerificationOtpCreateWithoutUserInput[] | PhoneVerificationOtpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PhoneVerificationOtpCreateOrConnectWithoutUserInput | PhoneVerificationOtpCreateOrConnectWithoutUserInput[]
    upsert?: PhoneVerificationOtpUpsertWithWhereUniqueWithoutUserInput | PhoneVerificationOtpUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PhoneVerificationOtpCreateManyUserInputEnvelope
    set?: PhoneVerificationOtpWhereUniqueInput | PhoneVerificationOtpWhereUniqueInput[]
    disconnect?: PhoneVerificationOtpWhereUniqueInput | PhoneVerificationOtpWhereUniqueInput[]
    delete?: PhoneVerificationOtpWhereUniqueInput | PhoneVerificationOtpWhereUniqueInput[]
    connect?: PhoneVerificationOtpWhereUniqueInput | PhoneVerificationOtpWhereUniqueInput[]
    update?: PhoneVerificationOtpUpdateWithWhereUniqueWithoutUserInput | PhoneVerificationOtpUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PhoneVerificationOtpUpdateManyWithWhereWithoutUserInput | PhoneVerificationOtpUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PhoneVerificationOtpScalarWhereInput | PhoneVerificationOtpScalarWhereInput[]
  }

  export type PasswordResetTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    set?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    disconnect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    delete?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    update?: PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetTokenUpdateManyWithWhereWithoutUserInput | PasswordResetTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    upsert?: UserProfileUpsertWithoutUserInput
    disconnect?: UserProfileWhereInput | boolean
    delete?: UserProfileWhereInput | boolean
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutUserInput, UserProfileUpdateWithoutUserInput>, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type VehicleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<VehicleCreateWithoutUserInput, VehicleUncheckedCreateWithoutUserInput> | VehicleCreateWithoutUserInput[] | VehicleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutUserInput | VehicleCreateOrConnectWithoutUserInput[]
    upsert?: VehicleUpsertWithWhereUniqueWithoutUserInput | VehicleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VehicleCreateManyUserInputEnvelope
    set?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    disconnect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    delete?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    update?: VehicleUpdateWithWhereUniqueWithoutUserInput | VehicleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VehicleUpdateManyWithWhereWithoutUserInput | VehicleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VehicleScalarWhereInput | VehicleScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutUserInput | BookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutUserInput | BookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutUserInput | BookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type UserPaymentMethodUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPaymentMethodCreateWithoutUserInput, UserPaymentMethodUncheckedCreateWithoutUserInput> | UserPaymentMethodCreateWithoutUserInput[] | UserPaymentMethodUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPaymentMethodCreateOrConnectWithoutUserInput | UserPaymentMethodCreateOrConnectWithoutUserInput[]
    upsert?: UserPaymentMethodUpsertWithWhereUniqueWithoutUserInput | UserPaymentMethodUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPaymentMethodCreateManyUserInputEnvelope
    set?: UserPaymentMethodWhereUniqueInput | UserPaymentMethodWhereUniqueInput[]
    disconnect?: UserPaymentMethodWhereUniqueInput | UserPaymentMethodWhereUniqueInput[]
    delete?: UserPaymentMethodWhereUniqueInput | UserPaymentMethodWhereUniqueInput[]
    connect?: UserPaymentMethodWhereUniqueInput | UserPaymentMethodWhereUniqueInput[]
    update?: UserPaymentMethodUpdateWithWhereUniqueWithoutUserInput | UserPaymentMethodUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPaymentMethodUpdateManyWithWhereWithoutUserInput | UserPaymentMethodUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPaymentMethodScalarWhereInput | UserPaymentMethodScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ParkingPassUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ParkingPassCreateWithoutUserInput, ParkingPassUncheckedCreateWithoutUserInput> | ParkingPassCreateWithoutUserInput[] | ParkingPassUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ParkingPassCreateOrConnectWithoutUserInput | ParkingPassCreateOrConnectWithoutUserInput[]
    upsert?: ParkingPassUpsertWithWhereUniqueWithoutUserInput | ParkingPassUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ParkingPassCreateManyUserInputEnvelope
    set?: ParkingPassWhereUniqueInput | ParkingPassWhereUniqueInput[]
    disconnect?: ParkingPassWhereUniqueInput | ParkingPassWhereUniqueInput[]
    delete?: ParkingPassWhereUniqueInput | ParkingPassWhereUniqueInput[]
    connect?: ParkingPassWhereUniqueInput | ParkingPassWhereUniqueInput[]
    update?: ParkingPassUpdateWithWhereUniqueWithoutUserInput | ParkingPassUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ParkingPassUpdateManyWithWhereWithoutUserInput | ParkingPassUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ParkingPassScalarWhereInput | ParkingPassScalarWhereInput[]
  }

  export type PlaceRatingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlaceRatingCreateWithoutUserInput, PlaceRatingUncheckedCreateWithoutUserInput> | PlaceRatingCreateWithoutUserInput[] | PlaceRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlaceRatingCreateOrConnectWithoutUserInput | PlaceRatingCreateOrConnectWithoutUserInput[]
    upsert?: PlaceRatingUpsertWithWhereUniqueWithoutUserInput | PlaceRatingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlaceRatingCreateManyUserInputEnvelope
    set?: PlaceRatingWhereUniqueInput | PlaceRatingWhereUniqueInput[]
    disconnect?: PlaceRatingWhereUniqueInput | PlaceRatingWhereUniqueInput[]
    delete?: PlaceRatingWhereUniqueInput | PlaceRatingWhereUniqueInput[]
    connect?: PlaceRatingWhereUniqueInput | PlaceRatingWhereUniqueInput[]
    update?: PlaceRatingUpdateWithWhereUniqueWithoutUserInput | PlaceRatingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlaceRatingUpdateManyWithWhereWithoutUserInput | PlaceRatingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlaceRatingScalarWhereInput | PlaceRatingScalarWhereInput[]
  }

  export type NotificationSettingUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationSettingCreateWithoutUserInput, NotificationSettingUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationSettingCreateOrConnectWithoutUserInput
    upsert?: NotificationSettingUpsertWithoutUserInput
    disconnect?: NotificationSettingWhereInput | boolean
    delete?: NotificationSettingWhereInput | boolean
    connect?: NotificationSettingWhereUniqueInput
    update?: XOR<XOR<NotificationSettingUpdateToOneWithWhereWithoutUserInput, NotificationSettingUpdateWithoutUserInput>, NotificationSettingUncheckedUpdateWithoutUserInput>
  }

  export type UserSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmailVerificationTokenCreateWithoutUserInput, EmailVerificationTokenUncheckedCreateWithoutUserInput> | EmailVerificationTokenCreateWithoutUserInput[] | EmailVerificationTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailVerificationTokenCreateOrConnectWithoutUserInput | EmailVerificationTokenCreateOrConnectWithoutUserInput[]
    upsert?: EmailVerificationTokenUpsertWithWhereUniqueWithoutUserInput | EmailVerificationTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmailVerificationTokenCreateManyUserInputEnvelope
    set?: EmailVerificationTokenWhereUniqueInput | EmailVerificationTokenWhereUniqueInput[]
    disconnect?: EmailVerificationTokenWhereUniqueInput | EmailVerificationTokenWhereUniqueInput[]
    delete?: EmailVerificationTokenWhereUniqueInput | EmailVerificationTokenWhereUniqueInput[]
    connect?: EmailVerificationTokenWhereUniqueInput | EmailVerificationTokenWhereUniqueInput[]
    update?: EmailVerificationTokenUpdateWithWhereUniqueWithoutUserInput | EmailVerificationTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmailVerificationTokenUpdateManyWithWhereWithoutUserInput | EmailVerificationTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmailVerificationTokenScalarWhereInput | EmailVerificationTokenScalarWhereInput[]
  }

  export type PhoneVerificationOtpUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PhoneVerificationOtpCreateWithoutUserInput, PhoneVerificationOtpUncheckedCreateWithoutUserInput> | PhoneVerificationOtpCreateWithoutUserInput[] | PhoneVerificationOtpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PhoneVerificationOtpCreateOrConnectWithoutUserInput | PhoneVerificationOtpCreateOrConnectWithoutUserInput[]
    upsert?: PhoneVerificationOtpUpsertWithWhereUniqueWithoutUserInput | PhoneVerificationOtpUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PhoneVerificationOtpCreateManyUserInputEnvelope
    set?: PhoneVerificationOtpWhereUniqueInput | PhoneVerificationOtpWhereUniqueInput[]
    disconnect?: PhoneVerificationOtpWhereUniqueInput | PhoneVerificationOtpWhereUniqueInput[]
    delete?: PhoneVerificationOtpWhereUniqueInput | PhoneVerificationOtpWhereUniqueInput[]
    connect?: PhoneVerificationOtpWhereUniqueInput | PhoneVerificationOtpWhereUniqueInput[]
    update?: PhoneVerificationOtpUpdateWithWhereUniqueWithoutUserInput | PhoneVerificationOtpUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PhoneVerificationOtpUpdateManyWithWhereWithoutUserInput | PhoneVerificationOtpUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PhoneVerificationOtpScalarWhereInput | PhoneVerificationOtpScalarWhereInput[]
  }

  export type PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    set?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    disconnect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    delete?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    update?: PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetTokenUpdateManyWithWhereWithoutUserInput | PasswordResetTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    upsert?: UserUpsertWithoutProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfileInput, UserUpdateWithoutProfileInput>, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserCreateNestedOneWithoutVehiclesInput = {
    create?: XOR<UserCreateWithoutVehiclesInput, UserUncheckedCreateWithoutVehiclesInput>
    connectOrCreate?: UserCreateOrConnectWithoutVehiclesInput
    connect?: UserWhereUniqueInput
  }

  export type BookingCreateNestedManyWithoutVehicleInput = {
    create?: XOR<BookingCreateWithoutVehicleInput, BookingUncheckedCreateWithoutVehicleInput> | BookingCreateWithoutVehicleInput[] | BookingUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutVehicleInput | BookingCreateOrConnectWithoutVehicleInput[]
    createMany?: BookingCreateManyVehicleInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<BookingCreateWithoutVehicleInput, BookingUncheckedCreateWithoutVehicleInput> | BookingCreateWithoutVehicleInput[] | BookingUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutVehicleInput | BookingCreateOrConnectWithoutVehicleInput[]
    createMany?: BookingCreateManyVehicleInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneRequiredWithoutVehiclesNestedInput = {
    create?: XOR<UserCreateWithoutVehiclesInput, UserUncheckedCreateWithoutVehiclesInput>
    connectOrCreate?: UserCreateOrConnectWithoutVehiclesInput
    upsert?: UserUpsertWithoutVehiclesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVehiclesInput, UserUpdateWithoutVehiclesInput>, UserUncheckedUpdateWithoutVehiclesInput>
  }

  export type BookingUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<BookingCreateWithoutVehicleInput, BookingUncheckedCreateWithoutVehicleInput> | BookingCreateWithoutVehicleInput[] | BookingUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutVehicleInput | BookingCreateOrConnectWithoutVehicleInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutVehicleInput | BookingUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: BookingCreateManyVehicleInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutVehicleInput | BookingUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutVehicleInput | BookingUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<BookingCreateWithoutVehicleInput, BookingUncheckedCreateWithoutVehicleInput> | BookingCreateWithoutVehicleInput[] | BookingUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutVehicleInput | BookingCreateOrConnectWithoutVehicleInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutVehicleInput | BookingUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: BookingCreateManyVehicleInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutVehicleInput | BookingUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutVehicleInput | BookingUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ParkingZoneCreateNestedManyWithoutPlaceInput = {
    create?: XOR<ParkingZoneCreateWithoutPlaceInput, ParkingZoneUncheckedCreateWithoutPlaceInput> | ParkingZoneCreateWithoutPlaceInput[] | ParkingZoneUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: ParkingZoneCreateOrConnectWithoutPlaceInput | ParkingZoneCreateOrConnectWithoutPlaceInput[]
    createMany?: ParkingZoneCreateManyPlaceInputEnvelope
    connect?: ParkingZoneWhereUniqueInput | ParkingZoneWhereUniqueInput[]
  }

  export type TariffPlanCreateNestedManyWithoutPlaceInput = {
    create?: XOR<TariffPlanCreateWithoutPlaceInput, TariffPlanUncheckedCreateWithoutPlaceInput> | TariffPlanCreateWithoutPlaceInput[] | TariffPlanUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: TariffPlanCreateOrConnectWithoutPlaceInput | TariffPlanCreateOrConnectWithoutPlaceInput[]
    createMany?: TariffPlanCreateManyPlaceInputEnvelope
    connect?: TariffPlanWhereUniqueInput | TariffPlanWhereUniqueInput[]
  }

  export type ParkingPassCreateNestedManyWithoutPlaceInput = {
    create?: XOR<ParkingPassCreateWithoutPlaceInput, ParkingPassUncheckedCreateWithoutPlaceInput> | ParkingPassCreateWithoutPlaceInput[] | ParkingPassUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: ParkingPassCreateOrConnectWithoutPlaceInput | ParkingPassCreateOrConnectWithoutPlaceInput[]
    createMany?: ParkingPassCreateManyPlaceInputEnvelope
    connect?: ParkingPassWhereUniqueInput | ParkingPassWhereUniqueInput[]
  }

  export type OperatingHourCreateNestedManyWithoutPlaceInput = {
    create?: XOR<OperatingHourCreateWithoutPlaceInput, OperatingHourUncheckedCreateWithoutPlaceInput> | OperatingHourCreateWithoutPlaceInput[] | OperatingHourUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: OperatingHourCreateOrConnectWithoutPlaceInput | OperatingHourCreateOrConnectWithoutPlaceInput[]
    createMany?: OperatingHourCreateManyPlaceInputEnvelope
    connect?: OperatingHourWhereUniqueInput | OperatingHourWhereUniqueInput[]
  }

  export type PlaceAdminCreateNestedManyWithoutPlaceInput = {
    create?: XOR<PlaceAdminCreateWithoutPlaceInput, PlaceAdminUncheckedCreateWithoutPlaceInput> | PlaceAdminCreateWithoutPlaceInput[] | PlaceAdminUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: PlaceAdminCreateOrConnectWithoutPlaceInput | PlaceAdminCreateOrConnectWithoutPlaceInput[]
    createMany?: PlaceAdminCreateManyPlaceInputEnvelope
    connect?: PlaceAdminWhereUniqueInput | PlaceAdminWhereUniqueInput[]
  }

  export type PlaceRatingCreateNestedManyWithoutPlaceInput = {
    create?: XOR<PlaceRatingCreateWithoutPlaceInput, PlaceRatingUncheckedCreateWithoutPlaceInput> | PlaceRatingCreateWithoutPlaceInput[] | PlaceRatingUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: PlaceRatingCreateOrConnectWithoutPlaceInput | PlaceRatingCreateOrConnectWithoutPlaceInput[]
    createMany?: PlaceRatingCreateManyPlaceInputEnvelope
    connect?: PlaceRatingWhereUniqueInput | PlaceRatingWhereUniqueInput[]
  }

  export type ParkingZoneUncheckedCreateNestedManyWithoutPlaceInput = {
    create?: XOR<ParkingZoneCreateWithoutPlaceInput, ParkingZoneUncheckedCreateWithoutPlaceInput> | ParkingZoneCreateWithoutPlaceInput[] | ParkingZoneUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: ParkingZoneCreateOrConnectWithoutPlaceInput | ParkingZoneCreateOrConnectWithoutPlaceInput[]
    createMany?: ParkingZoneCreateManyPlaceInputEnvelope
    connect?: ParkingZoneWhereUniqueInput | ParkingZoneWhereUniqueInput[]
  }

  export type TariffPlanUncheckedCreateNestedManyWithoutPlaceInput = {
    create?: XOR<TariffPlanCreateWithoutPlaceInput, TariffPlanUncheckedCreateWithoutPlaceInput> | TariffPlanCreateWithoutPlaceInput[] | TariffPlanUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: TariffPlanCreateOrConnectWithoutPlaceInput | TariffPlanCreateOrConnectWithoutPlaceInput[]
    createMany?: TariffPlanCreateManyPlaceInputEnvelope
    connect?: TariffPlanWhereUniqueInput | TariffPlanWhereUniqueInput[]
  }

  export type ParkingPassUncheckedCreateNestedManyWithoutPlaceInput = {
    create?: XOR<ParkingPassCreateWithoutPlaceInput, ParkingPassUncheckedCreateWithoutPlaceInput> | ParkingPassCreateWithoutPlaceInput[] | ParkingPassUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: ParkingPassCreateOrConnectWithoutPlaceInput | ParkingPassCreateOrConnectWithoutPlaceInput[]
    createMany?: ParkingPassCreateManyPlaceInputEnvelope
    connect?: ParkingPassWhereUniqueInput | ParkingPassWhereUniqueInput[]
  }

  export type OperatingHourUncheckedCreateNestedManyWithoutPlaceInput = {
    create?: XOR<OperatingHourCreateWithoutPlaceInput, OperatingHourUncheckedCreateWithoutPlaceInput> | OperatingHourCreateWithoutPlaceInput[] | OperatingHourUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: OperatingHourCreateOrConnectWithoutPlaceInput | OperatingHourCreateOrConnectWithoutPlaceInput[]
    createMany?: OperatingHourCreateManyPlaceInputEnvelope
    connect?: OperatingHourWhereUniqueInput | OperatingHourWhereUniqueInput[]
  }

  export type PlaceAdminUncheckedCreateNestedManyWithoutPlaceInput = {
    create?: XOR<PlaceAdminCreateWithoutPlaceInput, PlaceAdminUncheckedCreateWithoutPlaceInput> | PlaceAdminCreateWithoutPlaceInput[] | PlaceAdminUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: PlaceAdminCreateOrConnectWithoutPlaceInput | PlaceAdminCreateOrConnectWithoutPlaceInput[]
    createMany?: PlaceAdminCreateManyPlaceInputEnvelope
    connect?: PlaceAdminWhereUniqueInput | PlaceAdminWhereUniqueInput[]
  }

  export type PlaceRatingUncheckedCreateNestedManyWithoutPlaceInput = {
    create?: XOR<PlaceRatingCreateWithoutPlaceInput, PlaceRatingUncheckedCreateWithoutPlaceInput> | PlaceRatingCreateWithoutPlaceInput[] | PlaceRatingUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: PlaceRatingCreateOrConnectWithoutPlaceInput | PlaceRatingCreateOrConnectWithoutPlaceInput[]
    createMany?: PlaceRatingCreateManyPlaceInputEnvelope
    connect?: PlaceRatingWhereUniqueInput | PlaceRatingWhereUniqueInput[]
  }

  export type ParkingZoneUpdateManyWithoutPlaceNestedInput = {
    create?: XOR<ParkingZoneCreateWithoutPlaceInput, ParkingZoneUncheckedCreateWithoutPlaceInput> | ParkingZoneCreateWithoutPlaceInput[] | ParkingZoneUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: ParkingZoneCreateOrConnectWithoutPlaceInput | ParkingZoneCreateOrConnectWithoutPlaceInput[]
    upsert?: ParkingZoneUpsertWithWhereUniqueWithoutPlaceInput | ParkingZoneUpsertWithWhereUniqueWithoutPlaceInput[]
    createMany?: ParkingZoneCreateManyPlaceInputEnvelope
    set?: ParkingZoneWhereUniqueInput | ParkingZoneWhereUniqueInput[]
    disconnect?: ParkingZoneWhereUniqueInput | ParkingZoneWhereUniqueInput[]
    delete?: ParkingZoneWhereUniqueInput | ParkingZoneWhereUniqueInput[]
    connect?: ParkingZoneWhereUniqueInput | ParkingZoneWhereUniqueInput[]
    update?: ParkingZoneUpdateWithWhereUniqueWithoutPlaceInput | ParkingZoneUpdateWithWhereUniqueWithoutPlaceInput[]
    updateMany?: ParkingZoneUpdateManyWithWhereWithoutPlaceInput | ParkingZoneUpdateManyWithWhereWithoutPlaceInput[]
    deleteMany?: ParkingZoneScalarWhereInput | ParkingZoneScalarWhereInput[]
  }

  export type TariffPlanUpdateManyWithoutPlaceNestedInput = {
    create?: XOR<TariffPlanCreateWithoutPlaceInput, TariffPlanUncheckedCreateWithoutPlaceInput> | TariffPlanCreateWithoutPlaceInput[] | TariffPlanUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: TariffPlanCreateOrConnectWithoutPlaceInput | TariffPlanCreateOrConnectWithoutPlaceInput[]
    upsert?: TariffPlanUpsertWithWhereUniqueWithoutPlaceInput | TariffPlanUpsertWithWhereUniqueWithoutPlaceInput[]
    createMany?: TariffPlanCreateManyPlaceInputEnvelope
    set?: TariffPlanWhereUniqueInput | TariffPlanWhereUniqueInput[]
    disconnect?: TariffPlanWhereUniqueInput | TariffPlanWhereUniqueInput[]
    delete?: TariffPlanWhereUniqueInput | TariffPlanWhereUniqueInput[]
    connect?: TariffPlanWhereUniqueInput | TariffPlanWhereUniqueInput[]
    update?: TariffPlanUpdateWithWhereUniqueWithoutPlaceInput | TariffPlanUpdateWithWhereUniqueWithoutPlaceInput[]
    updateMany?: TariffPlanUpdateManyWithWhereWithoutPlaceInput | TariffPlanUpdateManyWithWhereWithoutPlaceInput[]
    deleteMany?: TariffPlanScalarWhereInput | TariffPlanScalarWhereInput[]
  }

  export type ParkingPassUpdateManyWithoutPlaceNestedInput = {
    create?: XOR<ParkingPassCreateWithoutPlaceInput, ParkingPassUncheckedCreateWithoutPlaceInput> | ParkingPassCreateWithoutPlaceInput[] | ParkingPassUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: ParkingPassCreateOrConnectWithoutPlaceInput | ParkingPassCreateOrConnectWithoutPlaceInput[]
    upsert?: ParkingPassUpsertWithWhereUniqueWithoutPlaceInput | ParkingPassUpsertWithWhereUniqueWithoutPlaceInput[]
    createMany?: ParkingPassCreateManyPlaceInputEnvelope
    set?: ParkingPassWhereUniqueInput | ParkingPassWhereUniqueInput[]
    disconnect?: ParkingPassWhereUniqueInput | ParkingPassWhereUniqueInput[]
    delete?: ParkingPassWhereUniqueInput | ParkingPassWhereUniqueInput[]
    connect?: ParkingPassWhereUniqueInput | ParkingPassWhereUniqueInput[]
    update?: ParkingPassUpdateWithWhereUniqueWithoutPlaceInput | ParkingPassUpdateWithWhereUniqueWithoutPlaceInput[]
    updateMany?: ParkingPassUpdateManyWithWhereWithoutPlaceInput | ParkingPassUpdateManyWithWhereWithoutPlaceInput[]
    deleteMany?: ParkingPassScalarWhereInput | ParkingPassScalarWhereInput[]
  }

  export type OperatingHourUpdateManyWithoutPlaceNestedInput = {
    create?: XOR<OperatingHourCreateWithoutPlaceInput, OperatingHourUncheckedCreateWithoutPlaceInput> | OperatingHourCreateWithoutPlaceInput[] | OperatingHourUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: OperatingHourCreateOrConnectWithoutPlaceInput | OperatingHourCreateOrConnectWithoutPlaceInput[]
    upsert?: OperatingHourUpsertWithWhereUniqueWithoutPlaceInput | OperatingHourUpsertWithWhereUniqueWithoutPlaceInput[]
    createMany?: OperatingHourCreateManyPlaceInputEnvelope
    set?: OperatingHourWhereUniqueInput | OperatingHourWhereUniqueInput[]
    disconnect?: OperatingHourWhereUniqueInput | OperatingHourWhereUniqueInput[]
    delete?: OperatingHourWhereUniqueInput | OperatingHourWhereUniqueInput[]
    connect?: OperatingHourWhereUniqueInput | OperatingHourWhereUniqueInput[]
    update?: OperatingHourUpdateWithWhereUniqueWithoutPlaceInput | OperatingHourUpdateWithWhereUniqueWithoutPlaceInput[]
    updateMany?: OperatingHourUpdateManyWithWhereWithoutPlaceInput | OperatingHourUpdateManyWithWhereWithoutPlaceInput[]
    deleteMany?: OperatingHourScalarWhereInput | OperatingHourScalarWhereInput[]
  }

  export type PlaceAdminUpdateManyWithoutPlaceNestedInput = {
    create?: XOR<PlaceAdminCreateWithoutPlaceInput, PlaceAdminUncheckedCreateWithoutPlaceInput> | PlaceAdminCreateWithoutPlaceInput[] | PlaceAdminUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: PlaceAdminCreateOrConnectWithoutPlaceInput | PlaceAdminCreateOrConnectWithoutPlaceInput[]
    upsert?: PlaceAdminUpsertWithWhereUniqueWithoutPlaceInput | PlaceAdminUpsertWithWhereUniqueWithoutPlaceInput[]
    createMany?: PlaceAdminCreateManyPlaceInputEnvelope
    set?: PlaceAdminWhereUniqueInput | PlaceAdminWhereUniqueInput[]
    disconnect?: PlaceAdminWhereUniqueInput | PlaceAdminWhereUniqueInput[]
    delete?: PlaceAdminWhereUniqueInput | PlaceAdminWhereUniqueInput[]
    connect?: PlaceAdminWhereUniqueInput | PlaceAdminWhereUniqueInput[]
    update?: PlaceAdminUpdateWithWhereUniqueWithoutPlaceInput | PlaceAdminUpdateWithWhereUniqueWithoutPlaceInput[]
    updateMany?: PlaceAdminUpdateManyWithWhereWithoutPlaceInput | PlaceAdminUpdateManyWithWhereWithoutPlaceInput[]
    deleteMany?: PlaceAdminScalarWhereInput | PlaceAdminScalarWhereInput[]
  }

  export type PlaceRatingUpdateManyWithoutPlaceNestedInput = {
    create?: XOR<PlaceRatingCreateWithoutPlaceInput, PlaceRatingUncheckedCreateWithoutPlaceInput> | PlaceRatingCreateWithoutPlaceInput[] | PlaceRatingUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: PlaceRatingCreateOrConnectWithoutPlaceInput | PlaceRatingCreateOrConnectWithoutPlaceInput[]
    upsert?: PlaceRatingUpsertWithWhereUniqueWithoutPlaceInput | PlaceRatingUpsertWithWhereUniqueWithoutPlaceInput[]
    createMany?: PlaceRatingCreateManyPlaceInputEnvelope
    set?: PlaceRatingWhereUniqueInput | PlaceRatingWhereUniqueInput[]
    disconnect?: PlaceRatingWhereUniqueInput | PlaceRatingWhereUniqueInput[]
    delete?: PlaceRatingWhereUniqueInput | PlaceRatingWhereUniqueInput[]
    connect?: PlaceRatingWhereUniqueInput | PlaceRatingWhereUniqueInput[]
    update?: PlaceRatingUpdateWithWhereUniqueWithoutPlaceInput | PlaceRatingUpdateWithWhereUniqueWithoutPlaceInput[]
    updateMany?: PlaceRatingUpdateManyWithWhereWithoutPlaceInput | PlaceRatingUpdateManyWithWhereWithoutPlaceInput[]
    deleteMany?: PlaceRatingScalarWhereInput | PlaceRatingScalarWhereInput[]
  }

  export type ParkingZoneUncheckedUpdateManyWithoutPlaceNestedInput = {
    create?: XOR<ParkingZoneCreateWithoutPlaceInput, ParkingZoneUncheckedCreateWithoutPlaceInput> | ParkingZoneCreateWithoutPlaceInput[] | ParkingZoneUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: ParkingZoneCreateOrConnectWithoutPlaceInput | ParkingZoneCreateOrConnectWithoutPlaceInput[]
    upsert?: ParkingZoneUpsertWithWhereUniqueWithoutPlaceInput | ParkingZoneUpsertWithWhereUniqueWithoutPlaceInput[]
    createMany?: ParkingZoneCreateManyPlaceInputEnvelope
    set?: ParkingZoneWhereUniqueInput | ParkingZoneWhereUniqueInput[]
    disconnect?: ParkingZoneWhereUniqueInput | ParkingZoneWhereUniqueInput[]
    delete?: ParkingZoneWhereUniqueInput | ParkingZoneWhereUniqueInput[]
    connect?: ParkingZoneWhereUniqueInput | ParkingZoneWhereUniqueInput[]
    update?: ParkingZoneUpdateWithWhereUniqueWithoutPlaceInput | ParkingZoneUpdateWithWhereUniqueWithoutPlaceInput[]
    updateMany?: ParkingZoneUpdateManyWithWhereWithoutPlaceInput | ParkingZoneUpdateManyWithWhereWithoutPlaceInput[]
    deleteMany?: ParkingZoneScalarWhereInput | ParkingZoneScalarWhereInput[]
  }

  export type TariffPlanUncheckedUpdateManyWithoutPlaceNestedInput = {
    create?: XOR<TariffPlanCreateWithoutPlaceInput, TariffPlanUncheckedCreateWithoutPlaceInput> | TariffPlanCreateWithoutPlaceInput[] | TariffPlanUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: TariffPlanCreateOrConnectWithoutPlaceInput | TariffPlanCreateOrConnectWithoutPlaceInput[]
    upsert?: TariffPlanUpsertWithWhereUniqueWithoutPlaceInput | TariffPlanUpsertWithWhereUniqueWithoutPlaceInput[]
    createMany?: TariffPlanCreateManyPlaceInputEnvelope
    set?: TariffPlanWhereUniqueInput | TariffPlanWhereUniqueInput[]
    disconnect?: TariffPlanWhereUniqueInput | TariffPlanWhereUniqueInput[]
    delete?: TariffPlanWhereUniqueInput | TariffPlanWhereUniqueInput[]
    connect?: TariffPlanWhereUniqueInput | TariffPlanWhereUniqueInput[]
    update?: TariffPlanUpdateWithWhereUniqueWithoutPlaceInput | TariffPlanUpdateWithWhereUniqueWithoutPlaceInput[]
    updateMany?: TariffPlanUpdateManyWithWhereWithoutPlaceInput | TariffPlanUpdateManyWithWhereWithoutPlaceInput[]
    deleteMany?: TariffPlanScalarWhereInput | TariffPlanScalarWhereInput[]
  }

  export type ParkingPassUncheckedUpdateManyWithoutPlaceNestedInput = {
    create?: XOR<ParkingPassCreateWithoutPlaceInput, ParkingPassUncheckedCreateWithoutPlaceInput> | ParkingPassCreateWithoutPlaceInput[] | ParkingPassUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: ParkingPassCreateOrConnectWithoutPlaceInput | ParkingPassCreateOrConnectWithoutPlaceInput[]
    upsert?: ParkingPassUpsertWithWhereUniqueWithoutPlaceInput | ParkingPassUpsertWithWhereUniqueWithoutPlaceInput[]
    createMany?: ParkingPassCreateManyPlaceInputEnvelope
    set?: ParkingPassWhereUniqueInput | ParkingPassWhereUniqueInput[]
    disconnect?: ParkingPassWhereUniqueInput | ParkingPassWhereUniqueInput[]
    delete?: ParkingPassWhereUniqueInput | ParkingPassWhereUniqueInput[]
    connect?: ParkingPassWhereUniqueInput | ParkingPassWhereUniqueInput[]
    update?: ParkingPassUpdateWithWhereUniqueWithoutPlaceInput | ParkingPassUpdateWithWhereUniqueWithoutPlaceInput[]
    updateMany?: ParkingPassUpdateManyWithWhereWithoutPlaceInput | ParkingPassUpdateManyWithWhereWithoutPlaceInput[]
    deleteMany?: ParkingPassScalarWhereInput | ParkingPassScalarWhereInput[]
  }

  export type OperatingHourUncheckedUpdateManyWithoutPlaceNestedInput = {
    create?: XOR<OperatingHourCreateWithoutPlaceInput, OperatingHourUncheckedCreateWithoutPlaceInput> | OperatingHourCreateWithoutPlaceInput[] | OperatingHourUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: OperatingHourCreateOrConnectWithoutPlaceInput | OperatingHourCreateOrConnectWithoutPlaceInput[]
    upsert?: OperatingHourUpsertWithWhereUniqueWithoutPlaceInput | OperatingHourUpsertWithWhereUniqueWithoutPlaceInput[]
    createMany?: OperatingHourCreateManyPlaceInputEnvelope
    set?: OperatingHourWhereUniqueInput | OperatingHourWhereUniqueInput[]
    disconnect?: OperatingHourWhereUniqueInput | OperatingHourWhereUniqueInput[]
    delete?: OperatingHourWhereUniqueInput | OperatingHourWhereUniqueInput[]
    connect?: OperatingHourWhereUniqueInput | OperatingHourWhereUniqueInput[]
    update?: OperatingHourUpdateWithWhereUniqueWithoutPlaceInput | OperatingHourUpdateWithWhereUniqueWithoutPlaceInput[]
    updateMany?: OperatingHourUpdateManyWithWhereWithoutPlaceInput | OperatingHourUpdateManyWithWhereWithoutPlaceInput[]
    deleteMany?: OperatingHourScalarWhereInput | OperatingHourScalarWhereInput[]
  }

  export type PlaceAdminUncheckedUpdateManyWithoutPlaceNestedInput = {
    create?: XOR<PlaceAdminCreateWithoutPlaceInput, PlaceAdminUncheckedCreateWithoutPlaceInput> | PlaceAdminCreateWithoutPlaceInput[] | PlaceAdminUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: PlaceAdminCreateOrConnectWithoutPlaceInput | PlaceAdminCreateOrConnectWithoutPlaceInput[]
    upsert?: PlaceAdminUpsertWithWhereUniqueWithoutPlaceInput | PlaceAdminUpsertWithWhereUniqueWithoutPlaceInput[]
    createMany?: PlaceAdminCreateManyPlaceInputEnvelope
    set?: PlaceAdminWhereUniqueInput | PlaceAdminWhereUniqueInput[]
    disconnect?: PlaceAdminWhereUniqueInput | PlaceAdminWhereUniqueInput[]
    delete?: PlaceAdminWhereUniqueInput | PlaceAdminWhereUniqueInput[]
    connect?: PlaceAdminWhereUniqueInput | PlaceAdminWhereUniqueInput[]
    update?: PlaceAdminUpdateWithWhereUniqueWithoutPlaceInput | PlaceAdminUpdateWithWhereUniqueWithoutPlaceInput[]
    updateMany?: PlaceAdminUpdateManyWithWhereWithoutPlaceInput | PlaceAdminUpdateManyWithWhereWithoutPlaceInput[]
    deleteMany?: PlaceAdminScalarWhereInput | PlaceAdminScalarWhereInput[]
  }

  export type PlaceRatingUncheckedUpdateManyWithoutPlaceNestedInput = {
    create?: XOR<PlaceRatingCreateWithoutPlaceInput, PlaceRatingUncheckedCreateWithoutPlaceInput> | PlaceRatingCreateWithoutPlaceInput[] | PlaceRatingUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: PlaceRatingCreateOrConnectWithoutPlaceInput | PlaceRatingCreateOrConnectWithoutPlaceInput[]
    upsert?: PlaceRatingUpsertWithWhereUniqueWithoutPlaceInput | PlaceRatingUpsertWithWhereUniqueWithoutPlaceInput[]
    createMany?: PlaceRatingCreateManyPlaceInputEnvelope
    set?: PlaceRatingWhereUniqueInput | PlaceRatingWhereUniqueInput[]
    disconnect?: PlaceRatingWhereUniqueInput | PlaceRatingWhereUniqueInput[]
    delete?: PlaceRatingWhereUniqueInput | PlaceRatingWhereUniqueInput[]
    connect?: PlaceRatingWhereUniqueInput | PlaceRatingWhereUniqueInput[]
    update?: PlaceRatingUpdateWithWhereUniqueWithoutPlaceInput | PlaceRatingUpdateWithWhereUniqueWithoutPlaceInput[]
    updateMany?: PlaceRatingUpdateManyWithWhereWithoutPlaceInput | PlaceRatingUpdateManyWithWhereWithoutPlaceInput[]
    deleteMany?: PlaceRatingScalarWhereInput | PlaceRatingScalarWhereInput[]
  }

  export type PlaceCreateNestedOneWithoutParkingZonesInput = {
    create?: XOR<PlaceCreateWithoutParkingZonesInput, PlaceUncheckedCreateWithoutParkingZonesInput>
    connectOrCreate?: PlaceCreateOrConnectWithoutParkingZonesInput
    connect?: PlaceWhereUniqueInput
  }

  export type ParkingSlotCreateNestedManyWithoutParkingZoneInput = {
    create?: XOR<ParkingSlotCreateWithoutParkingZoneInput, ParkingSlotUncheckedCreateWithoutParkingZoneInput> | ParkingSlotCreateWithoutParkingZoneInput[] | ParkingSlotUncheckedCreateWithoutParkingZoneInput[]
    connectOrCreate?: ParkingSlotCreateOrConnectWithoutParkingZoneInput | ParkingSlotCreateOrConnectWithoutParkingZoneInput[]
    createMany?: ParkingSlotCreateManyParkingZoneInputEnvelope
    connect?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
  }

  export type ParkingSlotUncheckedCreateNestedManyWithoutParkingZoneInput = {
    create?: XOR<ParkingSlotCreateWithoutParkingZoneInput, ParkingSlotUncheckedCreateWithoutParkingZoneInput> | ParkingSlotCreateWithoutParkingZoneInput[] | ParkingSlotUncheckedCreateWithoutParkingZoneInput[]
    connectOrCreate?: ParkingSlotCreateOrConnectWithoutParkingZoneInput | ParkingSlotCreateOrConnectWithoutParkingZoneInput[]
    createMany?: ParkingSlotCreateManyParkingZoneInputEnvelope
    connect?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
  }

  export type PlaceUpdateOneRequiredWithoutParkingZonesNestedInput = {
    create?: XOR<PlaceCreateWithoutParkingZonesInput, PlaceUncheckedCreateWithoutParkingZonesInput>
    connectOrCreate?: PlaceCreateOrConnectWithoutParkingZonesInput
    upsert?: PlaceUpsertWithoutParkingZonesInput
    connect?: PlaceWhereUniqueInput
    update?: XOR<XOR<PlaceUpdateToOneWithWhereWithoutParkingZonesInput, PlaceUpdateWithoutParkingZonesInput>, PlaceUncheckedUpdateWithoutParkingZonesInput>
  }

  export type ParkingSlotUpdateManyWithoutParkingZoneNestedInput = {
    create?: XOR<ParkingSlotCreateWithoutParkingZoneInput, ParkingSlotUncheckedCreateWithoutParkingZoneInput> | ParkingSlotCreateWithoutParkingZoneInput[] | ParkingSlotUncheckedCreateWithoutParkingZoneInput[]
    connectOrCreate?: ParkingSlotCreateOrConnectWithoutParkingZoneInput | ParkingSlotCreateOrConnectWithoutParkingZoneInput[]
    upsert?: ParkingSlotUpsertWithWhereUniqueWithoutParkingZoneInput | ParkingSlotUpsertWithWhereUniqueWithoutParkingZoneInput[]
    createMany?: ParkingSlotCreateManyParkingZoneInputEnvelope
    set?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    disconnect?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    delete?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    connect?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    update?: ParkingSlotUpdateWithWhereUniqueWithoutParkingZoneInput | ParkingSlotUpdateWithWhereUniqueWithoutParkingZoneInput[]
    updateMany?: ParkingSlotUpdateManyWithWhereWithoutParkingZoneInput | ParkingSlotUpdateManyWithWhereWithoutParkingZoneInput[]
    deleteMany?: ParkingSlotScalarWhereInput | ParkingSlotScalarWhereInput[]
  }

  export type ParkingSlotUncheckedUpdateManyWithoutParkingZoneNestedInput = {
    create?: XOR<ParkingSlotCreateWithoutParkingZoneInput, ParkingSlotUncheckedCreateWithoutParkingZoneInput> | ParkingSlotCreateWithoutParkingZoneInput[] | ParkingSlotUncheckedCreateWithoutParkingZoneInput[]
    connectOrCreate?: ParkingSlotCreateOrConnectWithoutParkingZoneInput | ParkingSlotCreateOrConnectWithoutParkingZoneInput[]
    upsert?: ParkingSlotUpsertWithWhereUniqueWithoutParkingZoneInput | ParkingSlotUpsertWithWhereUniqueWithoutParkingZoneInput[]
    createMany?: ParkingSlotCreateManyParkingZoneInputEnvelope
    set?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    disconnect?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    delete?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    connect?: ParkingSlotWhereUniqueInput | ParkingSlotWhereUniqueInput[]
    update?: ParkingSlotUpdateWithWhereUniqueWithoutParkingZoneInput | ParkingSlotUpdateWithWhereUniqueWithoutParkingZoneInput[]
    updateMany?: ParkingSlotUpdateManyWithWhereWithoutParkingZoneInput | ParkingSlotUpdateManyWithWhereWithoutParkingZoneInput[]
    deleteMany?: ParkingSlotScalarWhereInput | ParkingSlotScalarWhereInput[]
  }

  export type ParkingZoneCreateNestedOneWithoutParkingSlotsInput = {
    create?: XOR<ParkingZoneCreateWithoutParkingSlotsInput, ParkingZoneUncheckedCreateWithoutParkingSlotsInput>
    connectOrCreate?: ParkingZoneCreateOrConnectWithoutParkingSlotsInput
    connect?: ParkingZoneWhereUniqueInput
  }

  export type SlotAvailabilityCreateNestedManyWithoutParkingSlotInput = {
    create?: XOR<SlotAvailabilityCreateWithoutParkingSlotInput, SlotAvailabilityUncheckedCreateWithoutParkingSlotInput> | SlotAvailabilityCreateWithoutParkingSlotInput[] | SlotAvailabilityUncheckedCreateWithoutParkingSlotInput[]
    connectOrCreate?: SlotAvailabilityCreateOrConnectWithoutParkingSlotInput | SlotAvailabilityCreateOrConnectWithoutParkingSlotInput[]
    createMany?: SlotAvailabilityCreateManyParkingSlotInputEnvelope
    connect?: SlotAvailabilityWhereUniqueInput | SlotAvailabilityWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutParkingSlotInput = {
    create?: XOR<BookingCreateWithoutParkingSlotInput, BookingUncheckedCreateWithoutParkingSlotInput> | BookingCreateWithoutParkingSlotInput[] | BookingUncheckedCreateWithoutParkingSlotInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutParkingSlotInput | BookingCreateOrConnectWithoutParkingSlotInput[]
    createMany?: BookingCreateManyParkingSlotInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type SlotAvailabilityUncheckedCreateNestedManyWithoutParkingSlotInput = {
    create?: XOR<SlotAvailabilityCreateWithoutParkingSlotInput, SlotAvailabilityUncheckedCreateWithoutParkingSlotInput> | SlotAvailabilityCreateWithoutParkingSlotInput[] | SlotAvailabilityUncheckedCreateWithoutParkingSlotInput[]
    connectOrCreate?: SlotAvailabilityCreateOrConnectWithoutParkingSlotInput | SlotAvailabilityCreateOrConnectWithoutParkingSlotInput[]
    createMany?: SlotAvailabilityCreateManyParkingSlotInputEnvelope
    connect?: SlotAvailabilityWhereUniqueInput | SlotAvailabilityWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutParkingSlotInput = {
    create?: XOR<BookingCreateWithoutParkingSlotInput, BookingUncheckedCreateWithoutParkingSlotInput> | BookingCreateWithoutParkingSlotInput[] | BookingUncheckedCreateWithoutParkingSlotInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutParkingSlotInput | BookingCreateOrConnectWithoutParkingSlotInput[]
    createMany?: BookingCreateManyParkingSlotInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ParkingZoneUpdateOneRequiredWithoutParkingSlotsNestedInput = {
    create?: XOR<ParkingZoneCreateWithoutParkingSlotsInput, ParkingZoneUncheckedCreateWithoutParkingSlotsInput>
    connectOrCreate?: ParkingZoneCreateOrConnectWithoutParkingSlotsInput
    upsert?: ParkingZoneUpsertWithoutParkingSlotsInput
    connect?: ParkingZoneWhereUniqueInput
    update?: XOR<XOR<ParkingZoneUpdateToOneWithWhereWithoutParkingSlotsInput, ParkingZoneUpdateWithoutParkingSlotsInput>, ParkingZoneUncheckedUpdateWithoutParkingSlotsInput>
  }

  export type SlotAvailabilityUpdateManyWithoutParkingSlotNestedInput = {
    create?: XOR<SlotAvailabilityCreateWithoutParkingSlotInput, SlotAvailabilityUncheckedCreateWithoutParkingSlotInput> | SlotAvailabilityCreateWithoutParkingSlotInput[] | SlotAvailabilityUncheckedCreateWithoutParkingSlotInput[]
    connectOrCreate?: SlotAvailabilityCreateOrConnectWithoutParkingSlotInput | SlotAvailabilityCreateOrConnectWithoutParkingSlotInput[]
    upsert?: SlotAvailabilityUpsertWithWhereUniqueWithoutParkingSlotInput | SlotAvailabilityUpsertWithWhereUniqueWithoutParkingSlotInput[]
    createMany?: SlotAvailabilityCreateManyParkingSlotInputEnvelope
    set?: SlotAvailabilityWhereUniqueInput | SlotAvailabilityWhereUniqueInput[]
    disconnect?: SlotAvailabilityWhereUniqueInput | SlotAvailabilityWhereUniqueInput[]
    delete?: SlotAvailabilityWhereUniqueInput | SlotAvailabilityWhereUniqueInput[]
    connect?: SlotAvailabilityWhereUniqueInput | SlotAvailabilityWhereUniqueInput[]
    update?: SlotAvailabilityUpdateWithWhereUniqueWithoutParkingSlotInput | SlotAvailabilityUpdateWithWhereUniqueWithoutParkingSlotInput[]
    updateMany?: SlotAvailabilityUpdateManyWithWhereWithoutParkingSlotInput | SlotAvailabilityUpdateManyWithWhereWithoutParkingSlotInput[]
    deleteMany?: SlotAvailabilityScalarWhereInput | SlotAvailabilityScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutParkingSlotNestedInput = {
    create?: XOR<BookingCreateWithoutParkingSlotInput, BookingUncheckedCreateWithoutParkingSlotInput> | BookingCreateWithoutParkingSlotInput[] | BookingUncheckedCreateWithoutParkingSlotInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutParkingSlotInput | BookingCreateOrConnectWithoutParkingSlotInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutParkingSlotInput | BookingUpsertWithWhereUniqueWithoutParkingSlotInput[]
    createMany?: BookingCreateManyParkingSlotInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutParkingSlotInput | BookingUpdateWithWhereUniqueWithoutParkingSlotInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutParkingSlotInput | BookingUpdateManyWithWhereWithoutParkingSlotInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type SlotAvailabilityUncheckedUpdateManyWithoutParkingSlotNestedInput = {
    create?: XOR<SlotAvailabilityCreateWithoutParkingSlotInput, SlotAvailabilityUncheckedCreateWithoutParkingSlotInput> | SlotAvailabilityCreateWithoutParkingSlotInput[] | SlotAvailabilityUncheckedCreateWithoutParkingSlotInput[]
    connectOrCreate?: SlotAvailabilityCreateOrConnectWithoutParkingSlotInput | SlotAvailabilityCreateOrConnectWithoutParkingSlotInput[]
    upsert?: SlotAvailabilityUpsertWithWhereUniqueWithoutParkingSlotInput | SlotAvailabilityUpsertWithWhereUniqueWithoutParkingSlotInput[]
    createMany?: SlotAvailabilityCreateManyParkingSlotInputEnvelope
    set?: SlotAvailabilityWhereUniqueInput | SlotAvailabilityWhereUniqueInput[]
    disconnect?: SlotAvailabilityWhereUniqueInput | SlotAvailabilityWhereUniqueInput[]
    delete?: SlotAvailabilityWhereUniqueInput | SlotAvailabilityWhereUniqueInput[]
    connect?: SlotAvailabilityWhereUniqueInput | SlotAvailabilityWhereUniqueInput[]
    update?: SlotAvailabilityUpdateWithWhereUniqueWithoutParkingSlotInput | SlotAvailabilityUpdateWithWhereUniqueWithoutParkingSlotInput[]
    updateMany?: SlotAvailabilityUpdateManyWithWhereWithoutParkingSlotInput | SlotAvailabilityUpdateManyWithWhereWithoutParkingSlotInput[]
    deleteMany?: SlotAvailabilityScalarWhereInput | SlotAvailabilityScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutParkingSlotNestedInput = {
    create?: XOR<BookingCreateWithoutParkingSlotInput, BookingUncheckedCreateWithoutParkingSlotInput> | BookingCreateWithoutParkingSlotInput[] | BookingUncheckedCreateWithoutParkingSlotInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutParkingSlotInput | BookingCreateOrConnectWithoutParkingSlotInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutParkingSlotInput | BookingUpsertWithWhereUniqueWithoutParkingSlotInput[]
    createMany?: BookingCreateManyParkingSlotInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutParkingSlotInput | BookingUpdateWithWhereUniqueWithoutParkingSlotInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutParkingSlotInput | BookingUpdateManyWithWhereWithoutParkingSlotInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ParkingSlotCreateNestedOneWithoutSlotAvailabilityInput = {
    create?: XOR<ParkingSlotCreateWithoutSlotAvailabilityInput, ParkingSlotUncheckedCreateWithoutSlotAvailabilityInput>
    connectOrCreate?: ParkingSlotCreateOrConnectWithoutSlotAvailabilityInput
    connect?: ParkingSlotWhereUniqueInput
  }

  export type ParkingSlotUpdateOneRequiredWithoutSlotAvailabilityNestedInput = {
    create?: XOR<ParkingSlotCreateWithoutSlotAvailabilityInput, ParkingSlotUncheckedCreateWithoutSlotAvailabilityInput>
    connectOrCreate?: ParkingSlotCreateOrConnectWithoutSlotAvailabilityInput
    upsert?: ParkingSlotUpsertWithoutSlotAvailabilityInput
    connect?: ParkingSlotWhereUniqueInput
    update?: XOR<XOR<ParkingSlotUpdateToOneWithWhereWithoutSlotAvailabilityInput, ParkingSlotUpdateWithoutSlotAvailabilityInput>, ParkingSlotUncheckedUpdateWithoutSlotAvailabilityInput>
  }

  export type PlaceCreateNestedOneWithoutTariffPlansInput = {
    create?: XOR<PlaceCreateWithoutTariffPlansInput, PlaceUncheckedCreateWithoutTariffPlansInput>
    connectOrCreate?: PlaceCreateOrConnectWithoutTariffPlansInput
    connect?: PlaceWhereUniqueInput
  }

  export type TariffRateCreateNestedManyWithoutTariffPlanInput = {
    create?: XOR<TariffRateCreateWithoutTariffPlanInput, TariffRateUncheckedCreateWithoutTariffPlanInput> | TariffRateCreateWithoutTariffPlanInput[] | TariffRateUncheckedCreateWithoutTariffPlanInput[]
    connectOrCreate?: TariffRateCreateOrConnectWithoutTariffPlanInput | TariffRateCreateOrConnectWithoutTariffPlanInput[]
    createMany?: TariffRateCreateManyTariffPlanInputEnvelope
    connect?: TariffRateWhereUniqueInput | TariffRateWhereUniqueInput[]
  }

  export type TariffRateUncheckedCreateNestedManyWithoutTariffPlanInput = {
    create?: XOR<TariffRateCreateWithoutTariffPlanInput, TariffRateUncheckedCreateWithoutTariffPlanInput> | TariffRateCreateWithoutTariffPlanInput[] | TariffRateUncheckedCreateWithoutTariffPlanInput[]
    connectOrCreate?: TariffRateCreateOrConnectWithoutTariffPlanInput | TariffRateCreateOrConnectWithoutTariffPlanInput[]
    createMany?: TariffRateCreateManyTariffPlanInputEnvelope
    connect?: TariffRateWhereUniqueInput | TariffRateWhereUniqueInput[]
  }

  export type PlaceUpdateOneRequiredWithoutTariffPlansNestedInput = {
    create?: XOR<PlaceCreateWithoutTariffPlansInput, PlaceUncheckedCreateWithoutTariffPlansInput>
    connectOrCreate?: PlaceCreateOrConnectWithoutTariffPlansInput
    upsert?: PlaceUpsertWithoutTariffPlansInput
    connect?: PlaceWhereUniqueInput
    update?: XOR<XOR<PlaceUpdateToOneWithWhereWithoutTariffPlansInput, PlaceUpdateWithoutTariffPlansInput>, PlaceUncheckedUpdateWithoutTariffPlansInput>
  }

  export type TariffRateUpdateManyWithoutTariffPlanNestedInput = {
    create?: XOR<TariffRateCreateWithoutTariffPlanInput, TariffRateUncheckedCreateWithoutTariffPlanInput> | TariffRateCreateWithoutTariffPlanInput[] | TariffRateUncheckedCreateWithoutTariffPlanInput[]
    connectOrCreate?: TariffRateCreateOrConnectWithoutTariffPlanInput | TariffRateCreateOrConnectWithoutTariffPlanInput[]
    upsert?: TariffRateUpsertWithWhereUniqueWithoutTariffPlanInput | TariffRateUpsertWithWhereUniqueWithoutTariffPlanInput[]
    createMany?: TariffRateCreateManyTariffPlanInputEnvelope
    set?: TariffRateWhereUniqueInput | TariffRateWhereUniqueInput[]
    disconnect?: TariffRateWhereUniqueInput | TariffRateWhereUniqueInput[]
    delete?: TariffRateWhereUniqueInput | TariffRateWhereUniqueInput[]
    connect?: TariffRateWhereUniqueInput | TariffRateWhereUniqueInput[]
    update?: TariffRateUpdateWithWhereUniqueWithoutTariffPlanInput | TariffRateUpdateWithWhereUniqueWithoutTariffPlanInput[]
    updateMany?: TariffRateUpdateManyWithWhereWithoutTariffPlanInput | TariffRateUpdateManyWithWhereWithoutTariffPlanInput[]
    deleteMany?: TariffRateScalarWhereInput | TariffRateScalarWhereInput[]
  }

  export type TariffRateUncheckedUpdateManyWithoutTariffPlanNestedInput = {
    create?: XOR<TariffRateCreateWithoutTariffPlanInput, TariffRateUncheckedCreateWithoutTariffPlanInput> | TariffRateCreateWithoutTariffPlanInput[] | TariffRateUncheckedCreateWithoutTariffPlanInput[]
    connectOrCreate?: TariffRateCreateOrConnectWithoutTariffPlanInput | TariffRateCreateOrConnectWithoutTariffPlanInput[]
    upsert?: TariffRateUpsertWithWhereUniqueWithoutTariffPlanInput | TariffRateUpsertWithWhereUniqueWithoutTariffPlanInput[]
    createMany?: TariffRateCreateManyTariffPlanInputEnvelope
    set?: TariffRateWhereUniqueInput | TariffRateWhereUniqueInput[]
    disconnect?: TariffRateWhereUniqueInput | TariffRateWhereUniqueInput[]
    delete?: TariffRateWhereUniqueInput | TariffRateWhereUniqueInput[]
    connect?: TariffRateWhereUniqueInput | TariffRateWhereUniqueInput[]
    update?: TariffRateUpdateWithWhereUniqueWithoutTariffPlanInput | TariffRateUpdateWithWhereUniqueWithoutTariffPlanInput[]
    updateMany?: TariffRateUpdateManyWithWhereWithoutTariffPlanInput | TariffRateUpdateManyWithWhereWithoutTariffPlanInput[]
    deleteMany?: TariffRateScalarWhereInput | TariffRateScalarWhereInput[]
  }

  export type TariffPlanCreateNestedOneWithoutTariffRatesInput = {
    create?: XOR<TariffPlanCreateWithoutTariffRatesInput, TariffPlanUncheckedCreateWithoutTariffRatesInput>
    connectOrCreate?: TariffPlanCreateOrConnectWithoutTariffRatesInput
    connect?: TariffPlanWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type TariffPlanUpdateOneRequiredWithoutTariffRatesNestedInput = {
    create?: XOR<TariffPlanCreateWithoutTariffRatesInput, TariffPlanUncheckedCreateWithoutTariffRatesInput>
    connectOrCreate?: TariffPlanCreateOrConnectWithoutTariffRatesInput
    upsert?: TariffPlanUpsertWithoutTariffRatesInput
    connect?: TariffPlanWhereUniqueInput
    update?: XOR<XOR<TariffPlanUpdateToOneWithWhereWithoutTariffRatesInput, TariffPlanUpdateWithoutTariffRatesInput>, TariffPlanUncheckedUpdateWithoutTariffRatesInput>
  }

  export type UserCreateNestedOneWithoutBookingsInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    connect?: UserWhereUniqueInput
  }

  export type VehicleCreateNestedOneWithoutBookingsInput = {
    create?: XOR<VehicleCreateWithoutBookingsInput, VehicleUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutBookingsInput
    connect?: VehicleWhereUniqueInput
  }

  export type ParkingSlotCreateNestedOneWithoutBookingsInput = {
    create?: XOR<ParkingSlotCreateWithoutBookingsInput, ParkingSlotUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ParkingSlotCreateOrConnectWithoutBookingsInput
    connect?: ParkingSlotWhereUniqueInput
  }

  export type PromoCodeCreateNestedOneWithoutBookingsInput = {
    create?: XOR<PromoCodeCreateWithoutBookingsInput, PromoCodeUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: PromoCodeCreateOrConnectWithoutBookingsInput
    connect?: PromoCodeWhereUniqueInput
  }

  export type BookingStatusLogCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingStatusLogCreateWithoutBookingInput, BookingStatusLogUncheckedCreateWithoutBookingInput> | BookingStatusLogCreateWithoutBookingInput[] | BookingStatusLogUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingStatusLogCreateOrConnectWithoutBookingInput | BookingStatusLogCreateOrConnectWithoutBookingInput[]
    createMany?: BookingStatusLogCreateManyBookingInputEnvelope
    connect?: BookingStatusLogWhereUniqueInput | BookingStatusLogWhereUniqueInput[]
  }

  export type BookingPaymentCreateNestedOneWithoutBookingInput = {
    create?: XOR<BookingPaymentCreateWithoutBookingInput, BookingPaymentUncheckedCreateWithoutBookingInput>
    connectOrCreate?: BookingPaymentCreateOrConnectWithoutBookingInput
    connect?: BookingPaymentWhereUniqueInput
  }

  export type AccessLogCreateNestedManyWithoutBookingInput = {
    create?: XOR<AccessLogCreateWithoutBookingInput, AccessLogUncheckedCreateWithoutBookingInput> | AccessLogCreateWithoutBookingInput[] | AccessLogUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: AccessLogCreateOrConnectWithoutBookingInput | AccessLogCreateOrConnectWithoutBookingInput[]
    createMany?: AccessLogCreateManyBookingInputEnvelope
    connect?: AccessLogWhereUniqueInput | AccessLogWhereUniqueInput[]
  }

  export type BookingExtensionCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingExtensionCreateWithoutBookingInput, BookingExtensionUncheckedCreateWithoutBookingInput> | BookingExtensionCreateWithoutBookingInput[] | BookingExtensionUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingExtensionCreateOrConnectWithoutBookingInput | BookingExtensionCreateOrConnectWithoutBookingInput[]
    createMany?: BookingExtensionCreateManyBookingInputEnvelope
    connect?: BookingExtensionWhereUniqueInput | BookingExtensionWhereUniqueInput[]
  }

  export type PlaceRatingCreateNestedManyWithoutBookingInput = {
    create?: XOR<PlaceRatingCreateWithoutBookingInput, PlaceRatingUncheckedCreateWithoutBookingInput> | PlaceRatingCreateWithoutBookingInput[] | PlaceRatingUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PlaceRatingCreateOrConnectWithoutBookingInput | PlaceRatingCreateOrConnectWithoutBookingInput[]
    createMany?: PlaceRatingCreateManyBookingInputEnvelope
    connect?: PlaceRatingWhereUniqueInput | PlaceRatingWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutBookingInput = {
    create?: XOR<NotificationCreateWithoutBookingInput, NotificationUncheckedCreateWithoutBookingInput> | NotificationCreateWithoutBookingInput[] | NotificationUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutBookingInput | NotificationCreateOrConnectWithoutBookingInput[]
    createMany?: NotificationCreateManyBookingInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type BookingStatusLogUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingStatusLogCreateWithoutBookingInput, BookingStatusLogUncheckedCreateWithoutBookingInput> | BookingStatusLogCreateWithoutBookingInput[] | BookingStatusLogUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingStatusLogCreateOrConnectWithoutBookingInput | BookingStatusLogCreateOrConnectWithoutBookingInput[]
    createMany?: BookingStatusLogCreateManyBookingInputEnvelope
    connect?: BookingStatusLogWhereUniqueInput | BookingStatusLogWhereUniqueInput[]
  }

  export type BookingPaymentUncheckedCreateNestedOneWithoutBookingInput = {
    create?: XOR<BookingPaymentCreateWithoutBookingInput, BookingPaymentUncheckedCreateWithoutBookingInput>
    connectOrCreate?: BookingPaymentCreateOrConnectWithoutBookingInput
    connect?: BookingPaymentWhereUniqueInput
  }

  export type AccessLogUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<AccessLogCreateWithoutBookingInput, AccessLogUncheckedCreateWithoutBookingInput> | AccessLogCreateWithoutBookingInput[] | AccessLogUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: AccessLogCreateOrConnectWithoutBookingInput | AccessLogCreateOrConnectWithoutBookingInput[]
    createMany?: AccessLogCreateManyBookingInputEnvelope
    connect?: AccessLogWhereUniqueInput | AccessLogWhereUniqueInput[]
  }

  export type BookingExtensionUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingExtensionCreateWithoutBookingInput, BookingExtensionUncheckedCreateWithoutBookingInput> | BookingExtensionCreateWithoutBookingInput[] | BookingExtensionUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingExtensionCreateOrConnectWithoutBookingInput | BookingExtensionCreateOrConnectWithoutBookingInput[]
    createMany?: BookingExtensionCreateManyBookingInputEnvelope
    connect?: BookingExtensionWhereUniqueInput | BookingExtensionWhereUniqueInput[]
  }

  export type PlaceRatingUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<PlaceRatingCreateWithoutBookingInput, PlaceRatingUncheckedCreateWithoutBookingInput> | PlaceRatingCreateWithoutBookingInput[] | PlaceRatingUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PlaceRatingCreateOrConnectWithoutBookingInput | PlaceRatingCreateOrConnectWithoutBookingInput[]
    createMany?: PlaceRatingCreateManyBookingInputEnvelope
    connect?: PlaceRatingWhereUniqueInput | PlaceRatingWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<NotificationCreateWithoutBookingInput, NotificationUncheckedCreateWithoutBookingInput> | NotificationCreateWithoutBookingInput[] | NotificationUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutBookingInput | NotificationCreateOrConnectWithoutBookingInput[]
    createMany?: NotificationCreateManyBookingInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    upsert?: UserUpsertWithoutBookingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBookingsInput, UserUpdateWithoutBookingsInput>, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type VehicleUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<VehicleCreateWithoutBookingsInput, VehicleUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutBookingsInput
    upsert?: VehicleUpsertWithoutBookingsInput
    connect?: VehicleWhereUniqueInput
    update?: XOR<XOR<VehicleUpdateToOneWithWhereWithoutBookingsInput, VehicleUpdateWithoutBookingsInput>, VehicleUncheckedUpdateWithoutBookingsInput>
  }

  export type ParkingSlotUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<ParkingSlotCreateWithoutBookingsInput, ParkingSlotUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ParkingSlotCreateOrConnectWithoutBookingsInput
    upsert?: ParkingSlotUpsertWithoutBookingsInput
    connect?: ParkingSlotWhereUniqueInput
    update?: XOR<XOR<ParkingSlotUpdateToOneWithWhereWithoutBookingsInput, ParkingSlotUpdateWithoutBookingsInput>, ParkingSlotUncheckedUpdateWithoutBookingsInput>
  }

  export type PromoCodeUpdateOneWithoutBookingsNestedInput = {
    create?: XOR<PromoCodeCreateWithoutBookingsInput, PromoCodeUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: PromoCodeCreateOrConnectWithoutBookingsInput
    upsert?: PromoCodeUpsertWithoutBookingsInput
    disconnect?: PromoCodeWhereInput | boolean
    delete?: PromoCodeWhereInput | boolean
    connect?: PromoCodeWhereUniqueInput
    update?: XOR<XOR<PromoCodeUpdateToOneWithWhereWithoutBookingsInput, PromoCodeUpdateWithoutBookingsInput>, PromoCodeUncheckedUpdateWithoutBookingsInput>
  }

  export type BookingStatusLogUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingStatusLogCreateWithoutBookingInput, BookingStatusLogUncheckedCreateWithoutBookingInput> | BookingStatusLogCreateWithoutBookingInput[] | BookingStatusLogUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingStatusLogCreateOrConnectWithoutBookingInput | BookingStatusLogCreateOrConnectWithoutBookingInput[]
    upsert?: BookingStatusLogUpsertWithWhereUniqueWithoutBookingInput | BookingStatusLogUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingStatusLogCreateManyBookingInputEnvelope
    set?: BookingStatusLogWhereUniqueInput | BookingStatusLogWhereUniqueInput[]
    disconnect?: BookingStatusLogWhereUniqueInput | BookingStatusLogWhereUniqueInput[]
    delete?: BookingStatusLogWhereUniqueInput | BookingStatusLogWhereUniqueInput[]
    connect?: BookingStatusLogWhereUniqueInput | BookingStatusLogWhereUniqueInput[]
    update?: BookingStatusLogUpdateWithWhereUniqueWithoutBookingInput | BookingStatusLogUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingStatusLogUpdateManyWithWhereWithoutBookingInput | BookingStatusLogUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingStatusLogScalarWhereInput | BookingStatusLogScalarWhereInput[]
  }

  export type BookingPaymentUpdateOneWithoutBookingNestedInput = {
    create?: XOR<BookingPaymentCreateWithoutBookingInput, BookingPaymentUncheckedCreateWithoutBookingInput>
    connectOrCreate?: BookingPaymentCreateOrConnectWithoutBookingInput
    upsert?: BookingPaymentUpsertWithoutBookingInput
    disconnect?: BookingPaymentWhereInput | boolean
    delete?: BookingPaymentWhereInput | boolean
    connect?: BookingPaymentWhereUniqueInput
    update?: XOR<XOR<BookingPaymentUpdateToOneWithWhereWithoutBookingInput, BookingPaymentUpdateWithoutBookingInput>, BookingPaymentUncheckedUpdateWithoutBookingInput>
  }

  export type AccessLogUpdateManyWithoutBookingNestedInput = {
    create?: XOR<AccessLogCreateWithoutBookingInput, AccessLogUncheckedCreateWithoutBookingInput> | AccessLogCreateWithoutBookingInput[] | AccessLogUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: AccessLogCreateOrConnectWithoutBookingInput | AccessLogCreateOrConnectWithoutBookingInput[]
    upsert?: AccessLogUpsertWithWhereUniqueWithoutBookingInput | AccessLogUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: AccessLogCreateManyBookingInputEnvelope
    set?: AccessLogWhereUniqueInput | AccessLogWhereUniqueInput[]
    disconnect?: AccessLogWhereUniqueInput | AccessLogWhereUniqueInput[]
    delete?: AccessLogWhereUniqueInput | AccessLogWhereUniqueInput[]
    connect?: AccessLogWhereUniqueInput | AccessLogWhereUniqueInput[]
    update?: AccessLogUpdateWithWhereUniqueWithoutBookingInput | AccessLogUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: AccessLogUpdateManyWithWhereWithoutBookingInput | AccessLogUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: AccessLogScalarWhereInput | AccessLogScalarWhereInput[]
  }

  export type BookingExtensionUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingExtensionCreateWithoutBookingInput, BookingExtensionUncheckedCreateWithoutBookingInput> | BookingExtensionCreateWithoutBookingInput[] | BookingExtensionUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingExtensionCreateOrConnectWithoutBookingInput | BookingExtensionCreateOrConnectWithoutBookingInput[]
    upsert?: BookingExtensionUpsertWithWhereUniqueWithoutBookingInput | BookingExtensionUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingExtensionCreateManyBookingInputEnvelope
    set?: BookingExtensionWhereUniqueInput | BookingExtensionWhereUniqueInput[]
    disconnect?: BookingExtensionWhereUniqueInput | BookingExtensionWhereUniqueInput[]
    delete?: BookingExtensionWhereUniqueInput | BookingExtensionWhereUniqueInput[]
    connect?: BookingExtensionWhereUniqueInput | BookingExtensionWhereUniqueInput[]
    update?: BookingExtensionUpdateWithWhereUniqueWithoutBookingInput | BookingExtensionUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingExtensionUpdateManyWithWhereWithoutBookingInput | BookingExtensionUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingExtensionScalarWhereInput | BookingExtensionScalarWhereInput[]
  }

  export type PlaceRatingUpdateManyWithoutBookingNestedInput = {
    create?: XOR<PlaceRatingCreateWithoutBookingInput, PlaceRatingUncheckedCreateWithoutBookingInput> | PlaceRatingCreateWithoutBookingInput[] | PlaceRatingUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PlaceRatingCreateOrConnectWithoutBookingInput | PlaceRatingCreateOrConnectWithoutBookingInput[]
    upsert?: PlaceRatingUpsertWithWhereUniqueWithoutBookingInput | PlaceRatingUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: PlaceRatingCreateManyBookingInputEnvelope
    set?: PlaceRatingWhereUniqueInput | PlaceRatingWhereUniqueInput[]
    disconnect?: PlaceRatingWhereUniqueInput | PlaceRatingWhereUniqueInput[]
    delete?: PlaceRatingWhereUniqueInput | PlaceRatingWhereUniqueInput[]
    connect?: PlaceRatingWhereUniqueInput | PlaceRatingWhereUniqueInput[]
    update?: PlaceRatingUpdateWithWhereUniqueWithoutBookingInput | PlaceRatingUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: PlaceRatingUpdateManyWithWhereWithoutBookingInput | PlaceRatingUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: PlaceRatingScalarWhereInput | PlaceRatingScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutBookingNestedInput = {
    create?: XOR<NotificationCreateWithoutBookingInput, NotificationUncheckedCreateWithoutBookingInput> | NotificationCreateWithoutBookingInput[] | NotificationUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutBookingInput | NotificationCreateOrConnectWithoutBookingInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutBookingInput | NotificationUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: NotificationCreateManyBookingInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutBookingInput | NotificationUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutBookingInput | NotificationUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type BookingStatusLogUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingStatusLogCreateWithoutBookingInput, BookingStatusLogUncheckedCreateWithoutBookingInput> | BookingStatusLogCreateWithoutBookingInput[] | BookingStatusLogUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingStatusLogCreateOrConnectWithoutBookingInput | BookingStatusLogCreateOrConnectWithoutBookingInput[]
    upsert?: BookingStatusLogUpsertWithWhereUniqueWithoutBookingInput | BookingStatusLogUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingStatusLogCreateManyBookingInputEnvelope
    set?: BookingStatusLogWhereUniqueInput | BookingStatusLogWhereUniqueInput[]
    disconnect?: BookingStatusLogWhereUniqueInput | BookingStatusLogWhereUniqueInput[]
    delete?: BookingStatusLogWhereUniqueInput | BookingStatusLogWhereUniqueInput[]
    connect?: BookingStatusLogWhereUniqueInput | BookingStatusLogWhereUniqueInput[]
    update?: BookingStatusLogUpdateWithWhereUniqueWithoutBookingInput | BookingStatusLogUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingStatusLogUpdateManyWithWhereWithoutBookingInput | BookingStatusLogUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingStatusLogScalarWhereInput | BookingStatusLogScalarWhereInput[]
  }

  export type BookingPaymentUncheckedUpdateOneWithoutBookingNestedInput = {
    create?: XOR<BookingPaymentCreateWithoutBookingInput, BookingPaymentUncheckedCreateWithoutBookingInput>
    connectOrCreate?: BookingPaymentCreateOrConnectWithoutBookingInput
    upsert?: BookingPaymentUpsertWithoutBookingInput
    disconnect?: BookingPaymentWhereInput | boolean
    delete?: BookingPaymentWhereInput | boolean
    connect?: BookingPaymentWhereUniqueInput
    update?: XOR<XOR<BookingPaymentUpdateToOneWithWhereWithoutBookingInput, BookingPaymentUpdateWithoutBookingInput>, BookingPaymentUncheckedUpdateWithoutBookingInput>
  }

  export type AccessLogUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<AccessLogCreateWithoutBookingInput, AccessLogUncheckedCreateWithoutBookingInput> | AccessLogCreateWithoutBookingInput[] | AccessLogUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: AccessLogCreateOrConnectWithoutBookingInput | AccessLogCreateOrConnectWithoutBookingInput[]
    upsert?: AccessLogUpsertWithWhereUniqueWithoutBookingInput | AccessLogUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: AccessLogCreateManyBookingInputEnvelope
    set?: AccessLogWhereUniqueInput | AccessLogWhereUniqueInput[]
    disconnect?: AccessLogWhereUniqueInput | AccessLogWhereUniqueInput[]
    delete?: AccessLogWhereUniqueInput | AccessLogWhereUniqueInput[]
    connect?: AccessLogWhereUniqueInput | AccessLogWhereUniqueInput[]
    update?: AccessLogUpdateWithWhereUniqueWithoutBookingInput | AccessLogUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: AccessLogUpdateManyWithWhereWithoutBookingInput | AccessLogUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: AccessLogScalarWhereInput | AccessLogScalarWhereInput[]
  }

  export type BookingExtensionUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingExtensionCreateWithoutBookingInput, BookingExtensionUncheckedCreateWithoutBookingInput> | BookingExtensionCreateWithoutBookingInput[] | BookingExtensionUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingExtensionCreateOrConnectWithoutBookingInput | BookingExtensionCreateOrConnectWithoutBookingInput[]
    upsert?: BookingExtensionUpsertWithWhereUniqueWithoutBookingInput | BookingExtensionUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingExtensionCreateManyBookingInputEnvelope
    set?: BookingExtensionWhereUniqueInput | BookingExtensionWhereUniqueInput[]
    disconnect?: BookingExtensionWhereUniqueInput | BookingExtensionWhereUniqueInput[]
    delete?: BookingExtensionWhereUniqueInput | BookingExtensionWhereUniqueInput[]
    connect?: BookingExtensionWhereUniqueInput | BookingExtensionWhereUniqueInput[]
    update?: BookingExtensionUpdateWithWhereUniqueWithoutBookingInput | BookingExtensionUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingExtensionUpdateManyWithWhereWithoutBookingInput | BookingExtensionUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingExtensionScalarWhereInput | BookingExtensionScalarWhereInput[]
  }

  export type PlaceRatingUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<PlaceRatingCreateWithoutBookingInput, PlaceRatingUncheckedCreateWithoutBookingInput> | PlaceRatingCreateWithoutBookingInput[] | PlaceRatingUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PlaceRatingCreateOrConnectWithoutBookingInput | PlaceRatingCreateOrConnectWithoutBookingInput[]
    upsert?: PlaceRatingUpsertWithWhereUniqueWithoutBookingInput | PlaceRatingUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: PlaceRatingCreateManyBookingInputEnvelope
    set?: PlaceRatingWhereUniqueInput | PlaceRatingWhereUniqueInput[]
    disconnect?: PlaceRatingWhereUniqueInput | PlaceRatingWhereUniqueInput[]
    delete?: PlaceRatingWhereUniqueInput | PlaceRatingWhereUniqueInput[]
    connect?: PlaceRatingWhereUniqueInput | PlaceRatingWhereUniqueInput[]
    update?: PlaceRatingUpdateWithWhereUniqueWithoutBookingInput | PlaceRatingUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: PlaceRatingUpdateManyWithWhereWithoutBookingInput | PlaceRatingUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: PlaceRatingScalarWhereInput | PlaceRatingScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<NotificationCreateWithoutBookingInput, NotificationUncheckedCreateWithoutBookingInput> | NotificationCreateWithoutBookingInput[] | NotificationUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutBookingInput | NotificationCreateOrConnectWithoutBookingInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutBookingInput | NotificationUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: NotificationCreateManyBookingInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutBookingInput | NotificationUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutBookingInput | NotificationUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type BookingCreateNestedOneWithoutBookingStatusLogsInput = {
    create?: XOR<BookingCreateWithoutBookingStatusLogsInput, BookingUncheckedCreateWithoutBookingStatusLogsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutBookingStatusLogsInput
    connect?: BookingWhereUniqueInput
  }

  export type BookingUpdateOneRequiredWithoutBookingStatusLogsNestedInput = {
    create?: XOR<BookingCreateWithoutBookingStatusLogsInput, BookingUncheckedCreateWithoutBookingStatusLogsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutBookingStatusLogsInput
    upsert?: BookingUpsertWithoutBookingStatusLogsInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutBookingStatusLogsInput, BookingUpdateWithoutBookingStatusLogsInput>, BookingUncheckedUpdateWithoutBookingStatusLogsInput>
  }

  export type BookingCreateNestedOneWithoutBookingPaymentInput = {
    create?: XOR<BookingCreateWithoutBookingPaymentInput, BookingUncheckedCreateWithoutBookingPaymentInput>
    connectOrCreate?: BookingCreateOrConnectWithoutBookingPaymentInput
    connect?: BookingWhereUniqueInput
  }

  export type PaymentTransactionCreateNestedManyWithoutBookingPaymentInput = {
    create?: XOR<PaymentTransactionCreateWithoutBookingPaymentInput, PaymentTransactionUncheckedCreateWithoutBookingPaymentInput> | PaymentTransactionCreateWithoutBookingPaymentInput[] | PaymentTransactionUncheckedCreateWithoutBookingPaymentInput[]
    connectOrCreate?: PaymentTransactionCreateOrConnectWithoutBookingPaymentInput | PaymentTransactionCreateOrConnectWithoutBookingPaymentInput[]
    createMany?: PaymentTransactionCreateManyBookingPaymentInputEnvelope
    connect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
  }

  export type RefundTransactionCreateNestedManyWithoutBookingPaymentInput = {
    create?: XOR<RefundTransactionCreateWithoutBookingPaymentInput, RefundTransactionUncheckedCreateWithoutBookingPaymentInput> | RefundTransactionCreateWithoutBookingPaymentInput[] | RefundTransactionUncheckedCreateWithoutBookingPaymentInput[]
    connectOrCreate?: RefundTransactionCreateOrConnectWithoutBookingPaymentInput | RefundTransactionCreateOrConnectWithoutBookingPaymentInput[]
    createMany?: RefundTransactionCreateManyBookingPaymentInputEnvelope
    connect?: RefundTransactionWhereUniqueInput | RefundTransactionWhereUniqueInput[]
  }

  export type PaymentTransactionUncheckedCreateNestedManyWithoutBookingPaymentInput = {
    create?: XOR<PaymentTransactionCreateWithoutBookingPaymentInput, PaymentTransactionUncheckedCreateWithoutBookingPaymentInput> | PaymentTransactionCreateWithoutBookingPaymentInput[] | PaymentTransactionUncheckedCreateWithoutBookingPaymentInput[]
    connectOrCreate?: PaymentTransactionCreateOrConnectWithoutBookingPaymentInput | PaymentTransactionCreateOrConnectWithoutBookingPaymentInput[]
    createMany?: PaymentTransactionCreateManyBookingPaymentInputEnvelope
    connect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
  }

  export type RefundTransactionUncheckedCreateNestedManyWithoutBookingPaymentInput = {
    create?: XOR<RefundTransactionCreateWithoutBookingPaymentInput, RefundTransactionUncheckedCreateWithoutBookingPaymentInput> | RefundTransactionCreateWithoutBookingPaymentInput[] | RefundTransactionUncheckedCreateWithoutBookingPaymentInput[]
    connectOrCreate?: RefundTransactionCreateOrConnectWithoutBookingPaymentInput | RefundTransactionCreateOrConnectWithoutBookingPaymentInput[]
    createMany?: RefundTransactionCreateManyBookingPaymentInputEnvelope
    connect?: RefundTransactionWhereUniqueInput | RefundTransactionWhereUniqueInput[]
  }

  export type BookingUpdateOneRequiredWithoutBookingPaymentNestedInput = {
    create?: XOR<BookingCreateWithoutBookingPaymentInput, BookingUncheckedCreateWithoutBookingPaymentInput>
    connectOrCreate?: BookingCreateOrConnectWithoutBookingPaymentInput
    upsert?: BookingUpsertWithoutBookingPaymentInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutBookingPaymentInput, BookingUpdateWithoutBookingPaymentInput>, BookingUncheckedUpdateWithoutBookingPaymentInput>
  }

  export type PaymentTransactionUpdateManyWithoutBookingPaymentNestedInput = {
    create?: XOR<PaymentTransactionCreateWithoutBookingPaymentInput, PaymentTransactionUncheckedCreateWithoutBookingPaymentInput> | PaymentTransactionCreateWithoutBookingPaymentInput[] | PaymentTransactionUncheckedCreateWithoutBookingPaymentInput[]
    connectOrCreate?: PaymentTransactionCreateOrConnectWithoutBookingPaymentInput | PaymentTransactionCreateOrConnectWithoutBookingPaymentInput[]
    upsert?: PaymentTransactionUpsertWithWhereUniqueWithoutBookingPaymentInput | PaymentTransactionUpsertWithWhereUniqueWithoutBookingPaymentInput[]
    createMany?: PaymentTransactionCreateManyBookingPaymentInputEnvelope
    set?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    disconnect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    delete?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    connect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    update?: PaymentTransactionUpdateWithWhereUniqueWithoutBookingPaymentInput | PaymentTransactionUpdateWithWhereUniqueWithoutBookingPaymentInput[]
    updateMany?: PaymentTransactionUpdateManyWithWhereWithoutBookingPaymentInput | PaymentTransactionUpdateManyWithWhereWithoutBookingPaymentInput[]
    deleteMany?: PaymentTransactionScalarWhereInput | PaymentTransactionScalarWhereInput[]
  }

  export type RefundTransactionUpdateManyWithoutBookingPaymentNestedInput = {
    create?: XOR<RefundTransactionCreateWithoutBookingPaymentInput, RefundTransactionUncheckedCreateWithoutBookingPaymentInput> | RefundTransactionCreateWithoutBookingPaymentInput[] | RefundTransactionUncheckedCreateWithoutBookingPaymentInput[]
    connectOrCreate?: RefundTransactionCreateOrConnectWithoutBookingPaymentInput | RefundTransactionCreateOrConnectWithoutBookingPaymentInput[]
    upsert?: RefundTransactionUpsertWithWhereUniqueWithoutBookingPaymentInput | RefundTransactionUpsertWithWhereUniqueWithoutBookingPaymentInput[]
    createMany?: RefundTransactionCreateManyBookingPaymentInputEnvelope
    set?: RefundTransactionWhereUniqueInput | RefundTransactionWhereUniqueInput[]
    disconnect?: RefundTransactionWhereUniqueInput | RefundTransactionWhereUniqueInput[]
    delete?: RefundTransactionWhereUniqueInput | RefundTransactionWhereUniqueInput[]
    connect?: RefundTransactionWhereUniqueInput | RefundTransactionWhereUniqueInput[]
    update?: RefundTransactionUpdateWithWhereUniqueWithoutBookingPaymentInput | RefundTransactionUpdateWithWhereUniqueWithoutBookingPaymentInput[]
    updateMany?: RefundTransactionUpdateManyWithWhereWithoutBookingPaymentInput | RefundTransactionUpdateManyWithWhereWithoutBookingPaymentInput[]
    deleteMany?: RefundTransactionScalarWhereInput | RefundTransactionScalarWhereInput[]
  }

  export type PaymentTransactionUncheckedUpdateManyWithoutBookingPaymentNestedInput = {
    create?: XOR<PaymentTransactionCreateWithoutBookingPaymentInput, PaymentTransactionUncheckedCreateWithoutBookingPaymentInput> | PaymentTransactionCreateWithoutBookingPaymentInput[] | PaymentTransactionUncheckedCreateWithoutBookingPaymentInput[]
    connectOrCreate?: PaymentTransactionCreateOrConnectWithoutBookingPaymentInput | PaymentTransactionCreateOrConnectWithoutBookingPaymentInput[]
    upsert?: PaymentTransactionUpsertWithWhereUniqueWithoutBookingPaymentInput | PaymentTransactionUpsertWithWhereUniqueWithoutBookingPaymentInput[]
    createMany?: PaymentTransactionCreateManyBookingPaymentInputEnvelope
    set?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    disconnect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    delete?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    connect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    update?: PaymentTransactionUpdateWithWhereUniqueWithoutBookingPaymentInput | PaymentTransactionUpdateWithWhereUniqueWithoutBookingPaymentInput[]
    updateMany?: PaymentTransactionUpdateManyWithWhereWithoutBookingPaymentInput | PaymentTransactionUpdateManyWithWhereWithoutBookingPaymentInput[]
    deleteMany?: PaymentTransactionScalarWhereInput | PaymentTransactionScalarWhereInput[]
  }

  export type RefundTransactionUncheckedUpdateManyWithoutBookingPaymentNestedInput = {
    create?: XOR<RefundTransactionCreateWithoutBookingPaymentInput, RefundTransactionUncheckedCreateWithoutBookingPaymentInput> | RefundTransactionCreateWithoutBookingPaymentInput[] | RefundTransactionUncheckedCreateWithoutBookingPaymentInput[]
    connectOrCreate?: RefundTransactionCreateOrConnectWithoutBookingPaymentInput | RefundTransactionCreateOrConnectWithoutBookingPaymentInput[]
    upsert?: RefundTransactionUpsertWithWhereUniqueWithoutBookingPaymentInput | RefundTransactionUpsertWithWhereUniqueWithoutBookingPaymentInput[]
    createMany?: RefundTransactionCreateManyBookingPaymentInputEnvelope
    set?: RefundTransactionWhereUniqueInput | RefundTransactionWhereUniqueInput[]
    disconnect?: RefundTransactionWhereUniqueInput | RefundTransactionWhereUniqueInput[]
    delete?: RefundTransactionWhereUniqueInput | RefundTransactionWhereUniqueInput[]
    connect?: RefundTransactionWhereUniqueInput | RefundTransactionWhereUniqueInput[]
    update?: RefundTransactionUpdateWithWhereUniqueWithoutBookingPaymentInput | RefundTransactionUpdateWithWhereUniqueWithoutBookingPaymentInput[]
    updateMany?: RefundTransactionUpdateManyWithWhereWithoutBookingPaymentInput | RefundTransactionUpdateManyWithWhereWithoutBookingPaymentInput[]
    deleteMany?: RefundTransactionScalarWhereInput | RefundTransactionScalarWhereInput[]
  }

  export type BookingPaymentCreateNestedOneWithoutPaymentTransactionsInput = {
    create?: XOR<BookingPaymentCreateWithoutPaymentTransactionsInput, BookingPaymentUncheckedCreateWithoutPaymentTransactionsInput>
    connectOrCreate?: BookingPaymentCreateOrConnectWithoutPaymentTransactionsInput
    connect?: BookingPaymentWhereUniqueInput
  }

  export type PaymentMethodCreateNestedOneWithoutPaymentTransactionsInput = {
    create?: XOR<PaymentMethodCreateWithoutPaymentTransactionsInput, PaymentMethodUncheckedCreateWithoutPaymentTransactionsInput>
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutPaymentTransactionsInput
    connect?: PaymentMethodWhereUniqueInput
  }

  export type BookingPaymentUpdateOneRequiredWithoutPaymentTransactionsNestedInput = {
    create?: XOR<BookingPaymentCreateWithoutPaymentTransactionsInput, BookingPaymentUncheckedCreateWithoutPaymentTransactionsInput>
    connectOrCreate?: BookingPaymentCreateOrConnectWithoutPaymentTransactionsInput
    upsert?: BookingPaymentUpsertWithoutPaymentTransactionsInput
    connect?: BookingPaymentWhereUniqueInput
    update?: XOR<XOR<BookingPaymentUpdateToOneWithWhereWithoutPaymentTransactionsInput, BookingPaymentUpdateWithoutPaymentTransactionsInput>, BookingPaymentUncheckedUpdateWithoutPaymentTransactionsInput>
  }

  export type PaymentMethodUpdateOneRequiredWithoutPaymentTransactionsNestedInput = {
    create?: XOR<PaymentMethodCreateWithoutPaymentTransactionsInput, PaymentMethodUncheckedCreateWithoutPaymentTransactionsInput>
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutPaymentTransactionsInput
    upsert?: PaymentMethodUpsertWithoutPaymentTransactionsInput
    connect?: PaymentMethodWhereUniqueInput
    update?: XOR<XOR<PaymentMethodUpdateToOneWithWhereWithoutPaymentTransactionsInput, PaymentMethodUpdateWithoutPaymentTransactionsInput>, PaymentMethodUncheckedUpdateWithoutPaymentTransactionsInput>
  }

  export type BookingPaymentCreateNestedOneWithoutRefundTransactionsInput = {
    create?: XOR<BookingPaymentCreateWithoutRefundTransactionsInput, BookingPaymentUncheckedCreateWithoutRefundTransactionsInput>
    connectOrCreate?: BookingPaymentCreateOrConnectWithoutRefundTransactionsInput
    connect?: BookingPaymentWhereUniqueInput
  }

  export type BookingPaymentUpdateOneRequiredWithoutRefundTransactionsNestedInput = {
    create?: XOR<BookingPaymentCreateWithoutRefundTransactionsInput, BookingPaymentUncheckedCreateWithoutRefundTransactionsInput>
    connectOrCreate?: BookingPaymentCreateOrConnectWithoutRefundTransactionsInput
    upsert?: BookingPaymentUpsertWithoutRefundTransactionsInput
    connect?: BookingPaymentWhereUniqueInput
    update?: XOR<XOR<BookingPaymentUpdateToOneWithWhereWithoutRefundTransactionsInput, BookingPaymentUpdateWithoutRefundTransactionsInput>, BookingPaymentUncheckedUpdateWithoutRefundTransactionsInput>
  }

  export type PaymentTransactionCreateNestedManyWithoutPaymentMethodInput = {
    create?: XOR<PaymentTransactionCreateWithoutPaymentMethodInput, PaymentTransactionUncheckedCreateWithoutPaymentMethodInput> | PaymentTransactionCreateWithoutPaymentMethodInput[] | PaymentTransactionUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: PaymentTransactionCreateOrConnectWithoutPaymentMethodInput | PaymentTransactionCreateOrConnectWithoutPaymentMethodInput[]
    createMany?: PaymentTransactionCreateManyPaymentMethodInputEnvelope
    connect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
  }

  export type UserPaymentMethodCreateNestedManyWithoutPaymentMethodInput = {
    create?: XOR<UserPaymentMethodCreateWithoutPaymentMethodInput, UserPaymentMethodUncheckedCreateWithoutPaymentMethodInput> | UserPaymentMethodCreateWithoutPaymentMethodInput[] | UserPaymentMethodUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: UserPaymentMethodCreateOrConnectWithoutPaymentMethodInput | UserPaymentMethodCreateOrConnectWithoutPaymentMethodInput[]
    createMany?: UserPaymentMethodCreateManyPaymentMethodInputEnvelope
    connect?: UserPaymentMethodWhereUniqueInput | UserPaymentMethodWhereUniqueInput[]
  }

  export type ParkingPassPaymentCreateNestedManyWithoutPaymentMethodInput = {
    create?: XOR<ParkingPassPaymentCreateWithoutPaymentMethodInput, ParkingPassPaymentUncheckedCreateWithoutPaymentMethodInput> | ParkingPassPaymentCreateWithoutPaymentMethodInput[] | ParkingPassPaymentUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: ParkingPassPaymentCreateOrConnectWithoutPaymentMethodInput | ParkingPassPaymentCreateOrConnectWithoutPaymentMethodInput[]
    createMany?: ParkingPassPaymentCreateManyPaymentMethodInputEnvelope
    connect?: ParkingPassPaymentWhereUniqueInput | ParkingPassPaymentWhereUniqueInput[]
  }

  export type PaymentTransactionUncheckedCreateNestedManyWithoutPaymentMethodInput = {
    create?: XOR<PaymentTransactionCreateWithoutPaymentMethodInput, PaymentTransactionUncheckedCreateWithoutPaymentMethodInput> | PaymentTransactionCreateWithoutPaymentMethodInput[] | PaymentTransactionUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: PaymentTransactionCreateOrConnectWithoutPaymentMethodInput | PaymentTransactionCreateOrConnectWithoutPaymentMethodInput[]
    createMany?: PaymentTransactionCreateManyPaymentMethodInputEnvelope
    connect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
  }

  export type UserPaymentMethodUncheckedCreateNestedManyWithoutPaymentMethodInput = {
    create?: XOR<UserPaymentMethodCreateWithoutPaymentMethodInput, UserPaymentMethodUncheckedCreateWithoutPaymentMethodInput> | UserPaymentMethodCreateWithoutPaymentMethodInput[] | UserPaymentMethodUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: UserPaymentMethodCreateOrConnectWithoutPaymentMethodInput | UserPaymentMethodCreateOrConnectWithoutPaymentMethodInput[]
    createMany?: UserPaymentMethodCreateManyPaymentMethodInputEnvelope
    connect?: UserPaymentMethodWhereUniqueInput | UserPaymentMethodWhereUniqueInput[]
  }

  export type ParkingPassPaymentUncheckedCreateNestedManyWithoutPaymentMethodInput = {
    create?: XOR<ParkingPassPaymentCreateWithoutPaymentMethodInput, ParkingPassPaymentUncheckedCreateWithoutPaymentMethodInput> | ParkingPassPaymentCreateWithoutPaymentMethodInput[] | ParkingPassPaymentUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: ParkingPassPaymentCreateOrConnectWithoutPaymentMethodInput | ParkingPassPaymentCreateOrConnectWithoutPaymentMethodInput[]
    createMany?: ParkingPassPaymentCreateManyPaymentMethodInputEnvelope
    connect?: ParkingPassPaymentWhereUniqueInput | ParkingPassPaymentWhereUniqueInput[]
  }

  export type PaymentTransactionUpdateManyWithoutPaymentMethodNestedInput = {
    create?: XOR<PaymentTransactionCreateWithoutPaymentMethodInput, PaymentTransactionUncheckedCreateWithoutPaymentMethodInput> | PaymentTransactionCreateWithoutPaymentMethodInput[] | PaymentTransactionUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: PaymentTransactionCreateOrConnectWithoutPaymentMethodInput | PaymentTransactionCreateOrConnectWithoutPaymentMethodInput[]
    upsert?: PaymentTransactionUpsertWithWhereUniqueWithoutPaymentMethodInput | PaymentTransactionUpsertWithWhereUniqueWithoutPaymentMethodInput[]
    createMany?: PaymentTransactionCreateManyPaymentMethodInputEnvelope
    set?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    disconnect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    delete?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    connect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    update?: PaymentTransactionUpdateWithWhereUniqueWithoutPaymentMethodInput | PaymentTransactionUpdateWithWhereUniqueWithoutPaymentMethodInput[]
    updateMany?: PaymentTransactionUpdateManyWithWhereWithoutPaymentMethodInput | PaymentTransactionUpdateManyWithWhereWithoutPaymentMethodInput[]
    deleteMany?: PaymentTransactionScalarWhereInput | PaymentTransactionScalarWhereInput[]
  }

  export type UserPaymentMethodUpdateManyWithoutPaymentMethodNestedInput = {
    create?: XOR<UserPaymentMethodCreateWithoutPaymentMethodInput, UserPaymentMethodUncheckedCreateWithoutPaymentMethodInput> | UserPaymentMethodCreateWithoutPaymentMethodInput[] | UserPaymentMethodUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: UserPaymentMethodCreateOrConnectWithoutPaymentMethodInput | UserPaymentMethodCreateOrConnectWithoutPaymentMethodInput[]
    upsert?: UserPaymentMethodUpsertWithWhereUniqueWithoutPaymentMethodInput | UserPaymentMethodUpsertWithWhereUniqueWithoutPaymentMethodInput[]
    createMany?: UserPaymentMethodCreateManyPaymentMethodInputEnvelope
    set?: UserPaymentMethodWhereUniqueInput | UserPaymentMethodWhereUniqueInput[]
    disconnect?: UserPaymentMethodWhereUniqueInput | UserPaymentMethodWhereUniqueInput[]
    delete?: UserPaymentMethodWhereUniqueInput | UserPaymentMethodWhereUniqueInput[]
    connect?: UserPaymentMethodWhereUniqueInput | UserPaymentMethodWhereUniqueInput[]
    update?: UserPaymentMethodUpdateWithWhereUniqueWithoutPaymentMethodInput | UserPaymentMethodUpdateWithWhereUniqueWithoutPaymentMethodInput[]
    updateMany?: UserPaymentMethodUpdateManyWithWhereWithoutPaymentMethodInput | UserPaymentMethodUpdateManyWithWhereWithoutPaymentMethodInput[]
    deleteMany?: UserPaymentMethodScalarWhereInput | UserPaymentMethodScalarWhereInput[]
  }

  export type ParkingPassPaymentUpdateManyWithoutPaymentMethodNestedInput = {
    create?: XOR<ParkingPassPaymentCreateWithoutPaymentMethodInput, ParkingPassPaymentUncheckedCreateWithoutPaymentMethodInput> | ParkingPassPaymentCreateWithoutPaymentMethodInput[] | ParkingPassPaymentUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: ParkingPassPaymentCreateOrConnectWithoutPaymentMethodInput | ParkingPassPaymentCreateOrConnectWithoutPaymentMethodInput[]
    upsert?: ParkingPassPaymentUpsertWithWhereUniqueWithoutPaymentMethodInput | ParkingPassPaymentUpsertWithWhereUniqueWithoutPaymentMethodInput[]
    createMany?: ParkingPassPaymentCreateManyPaymentMethodInputEnvelope
    set?: ParkingPassPaymentWhereUniqueInput | ParkingPassPaymentWhereUniqueInput[]
    disconnect?: ParkingPassPaymentWhereUniqueInput | ParkingPassPaymentWhereUniqueInput[]
    delete?: ParkingPassPaymentWhereUniqueInput | ParkingPassPaymentWhereUniqueInput[]
    connect?: ParkingPassPaymentWhereUniqueInput | ParkingPassPaymentWhereUniqueInput[]
    update?: ParkingPassPaymentUpdateWithWhereUniqueWithoutPaymentMethodInput | ParkingPassPaymentUpdateWithWhereUniqueWithoutPaymentMethodInput[]
    updateMany?: ParkingPassPaymentUpdateManyWithWhereWithoutPaymentMethodInput | ParkingPassPaymentUpdateManyWithWhereWithoutPaymentMethodInput[]
    deleteMany?: ParkingPassPaymentScalarWhereInput | ParkingPassPaymentScalarWhereInput[]
  }

  export type PaymentTransactionUncheckedUpdateManyWithoutPaymentMethodNestedInput = {
    create?: XOR<PaymentTransactionCreateWithoutPaymentMethodInput, PaymentTransactionUncheckedCreateWithoutPaymentMethodInput> | PaymentTransactionCreateWithoutPaymentMethodInput[] | PaymentTransactionUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: PaymentTransactionCreateOrConnectWithoutPaymentMethodInput | PaymentTransactionCreateOrConnectWithoutPaymentMethodInput[]
    upsert?: PaymentTransactionUpsertWithWhereUniqueWithoutPaymentMethodInput | PaymentTransactionUpsertWithWhereUniqueWithoutPaymentMethodInput[]
    createMany?: PaymentTransactionCreateManyPaymentMethodInputEnvelope
    set?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    disconnect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    delete?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    connect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    update?: PaymentTransactionUpdateWithWhereUniqueWithoutPaymentMethodInput | PaymentTransactionUpdateWithWhereUniqueWithoutPaymentMethodInput[]
    updateMany?: PaymentTransactionUpdateManyWithWhereWithoutPaymentMethodInput | PaymentTransactionUpdateManyWithWhereWithoutPaymentMethodInput[]
    deleteMany?: PaymentTransactionScalarWhereInput | PaymentTransactionScalarWhereInput[]
  }

  export type UserPaymentMethodUncheckedUpdateManyWithoutPaymentMethodNestedInput = {
    create?: XOR<UserPaymentMethodCreateWithoutPaymentMethodInput, UserPaymentMethodUncheckedCreateWithoutPaymentMethodInput> | UserPaymentMethodCreateWithoutPaymentMethodInput[] | UserPaymentMethodUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: UserPaymentMethodCreateOrConnectWithoutPaymentMethodInput | UserPaymentMethodCreateOrConnectWithoutPaymentMethodInput[]
    upsert?: UserPaymentMethodUpsertWithWhereUniqueWithoutPaymentMethodInput | UserPaymentMethodUpsertWithWhereUniqueWithoutPaymentMethodInput[]
    createMany?: UserPaymentMethodCreateManyPaymentMethodInputEnvelope
    set?: UserPaymentMethodWhereUniqueInput | UserPaymentMethodWhereUniqueInput[]
    disconnect?: UserPaymentMethodWhereUniqueInput | UserPaymentMethodWhereUniqueInput[]
    delete?: UserPaymentMethodWhereUniqueInput | UserPaymentMethodWhereUniqueInput[]
    connect?: UserPaymentMethodWhereUniqueInput | UserPaymentMethodWhereUniqueInput[]
    update?: UserPaymentMethodUpdateWithWhereUniqueWithoutPaymentMethodInput | UserPaymentMethodUpdateWithWhereUniqueWithoutPaymentMethodInput[]
    updateMany?: UserPaymentMethodUpdateManyWithWhereWithoutPaymentMethodInput | UserPaymentMethodUpdateManyWithWhereWithoutPaymentMethodInput[]
    deleteMany?: UserPaymentMethodScalarWhereInput | UserPaymentMethodScalarWhereInput[]
  }

  export type ParkingPassPaymentUncheckedUpdateManyWithoutPaymentMethodNestedInput = {
    create?: XOR<ParkingPassPaymentCreateWithoutPaymentMethodInput, ParkingPassPaymentUncheckedCreateWithoutPaymentMethodInput> | ParkingPassPaymentCreateWithoutPaymentMethodInput[] | ParkingPassPaymentUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: ParkingPassPaymentCreateOrConnectWithoutPaymentMethodInput | ParkingPassPaymentCreateOrConnectWithoutPaymentMethodInput[]
    upsert?: ParkingPassPaymentUpsertWithWhereUniqueWithoutPaymentMethodInput | ParkingPassPaymentUpsertWithWhereUniqueWithoutPaymentMethodInput[]
    createMany?: ParkingPassPaymentCreateManyPaymentMethodInputEnvelope
    set?: ParkingPassPaymentWhereUniqueInput | ParkingPassPaymentWhereUniqueInput[]
    disconnect?: ParkingPassPaymentWhereUniqueInput | ParkingPassPaymentWhereUniqueInput[]
    delete?: ParkingPassPaymentWhereUniqueInput | ParkingPassPaymentWhereUniqueInput[]
    connect?: ParkingPassPaymentWhereUniqueInput | ParkingPassPaymentWhereUniqueInput[]
    update?: ParkingPassPaymentUpdateWithWhereUniqueWithoutPaymentMethodInput | ParkingPassPaymentUpdateWithWhereUniqueWithoutPaymentMethodInput[]
    updateMany?: ParkingPassPaymentUpdateManyWithWhereWithoutPaymentMethodInput | ParkingPassPaymentUpdateManyWithWhereWithoutPaymentMethodInput[]
    deleteMany?: ParkingPassPaymentScalarWhereInput | ParkingPassPaymentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUserPaymentMethodsInput = {
    create?: XOR<UserCreateWithoutUserPaymentMethodsInput, UserUncheckedCreateWithoutUserPaymentMethodsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserPaymentMethodsInput
    connect?: UserWhereUniqueInput
  }

  export type PaymentMethodCreateNestedOneWithoutUserPaymentMethodsInput = {
    create?: XOR<PaymentMethodCreateWithoutUserPaymentMethodsInput, PaymentMethodUncheckedCreateWithoutUserPaymentMethodsInput>
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutUserPaymentMethodsInput
    connect?: PaymentMethodWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserPaymentMethodsNestedInput = {
    create?: XOR<UserCreateWithoutUserPaymentMethodsInput, UserUncheckedCreateWithoutUserPaymentMethodsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserPaymentMethodsInput
    upsert?: UserUpsertWithoutUserPaymentMethodsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserPaymentMethodsInput, UserUpdateWithoutUserPaymentMethodsInput>, UserUncheckedUpdateWithoutUserPaymentMethodsInput>
  }

  export type PaymentMethodUpdateOneRequiredWithoutUserPaymentMethodsNestedInput = {
    create?: XOR<PaymentMethodCreateWithoutUserPaymentMethodsInput, PaymentMethodUncheckedCreateWithoutUserPaymentMethodsInput>
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutUserPaymentMethodsInput
    upsert?: PaymentMethodUpsertWithoutUserPaymentMethodsInput
    connect?: PaymentMethodWhereUniqueInput
    update?: XOR<XOR<PaymentMethodUpdateToOneWithWhereWithoutUserPaymentMethodsInput, PaymentMethodUpdateWithoutUserPaymentMethodsInput>, PaymentMethodUncheckedUpdateWithoutUserPaymentMethodsInput>
  }

  export type BookingCreateNestedManyWithoutPromoCodeInput = {
    create?: XOR<BookingCreateWithoutPromoCodeInput, BookingUncheckedCreateWithoutPromoCodeInput> | BookingCreateWithoutPromoCodeInput[] | BookingUncheckedCreateWithoutPromoCodeInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutPromoCodeInput | BookingCreateOrConnectWithoutPromoCodeInput[]
    createMany?: BookingCreateManyPromoCodeInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutPromoCodeInput = {
    create?: XOR<BookingCreateWithoutPromoCodeInput, BookingUncheckedCreateWithoutPromoCodeInput> | BookingCreateWithoutPromoCodeInput[] | BookingUncheckedCreateWithoutPromoCodeInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutPromoCodeInput | BookingCreateOrConnectWithoutPromoCodeInput[]
    createMany?: BookingCreateManyPromoCodeInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BookingUpdateManyWithoutPromoCodeNestedInput = {
    create?: XOR<BookingCreateWithoutPromoCodeInput, BookingUncheckedCreateWithoutPromoCodeInput> | BookingCreateWithoutPromoCodeInput[] | BookingUncheckedCreateWithoutPromoCodeInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutPromoCodeInput | BookingCreateOrConnectWithoutPromoCodeInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutPromoCodeInput | BookingUpsertWithWhereUniqueWithoutPromoCodeInput[]
    createMany?: BookingCreateManyPromoCodeInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutPromoCodeInput | BookingUpdateWithWhereUniqueWithoutPromoCodeInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutPromoCodeInput | BookingUpdateManyWithWhereWithoutPromoCodeInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutPromoCodeNestedInput = {
    create?: XOR<BookingCreateWithoutPromoCodeInput, BookingUncheckedCreateWithoutPromoCodeInput> | BookingCreateWithoutPromoCodeInput[] | BookingUncheckedCreateWithoutPromoCodeInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutPromoCodeInput | BookingCreateOrConnectWithoutPromoCodeInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutPromoCodeInput | BookingUpsertWithWhereUniqueWithoutPromoCodeInput[]
    createMany?: BookingCreateManyPromoCodeInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutPromoCodeInput | BookingUpdateWithWhereUniqueWithoutPromoCodeInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutPromoCodeInput | BookingUpdateManyWithWhereWithoutPromoCodeInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutParkingPassesInput = {
    create?: XOR<UserCreateWithoutParkingPassesInput, UserUncheckedCreateWithoutParkingPassesInput>
    connectOrCreate?: UserCreateOrConnectWithoutParkingPassesInput
    connect?: UserWhereUniqueInput
  }

  export type PlaceCreateNestedOneWithoutParkingPassesInput = {
    create?: XOR<PlaceCreateWithoutParkingPassesInput, PlaceUncheckedCreateWithoutParkingPassesInput>
    connectOrCreate?: PlaceCreateOrConnectWithoutParkingPassesInput
    connect?: PlaceWhereUniqueInput
  }

  export type ParkingPassPaymentCreateNestedManyWithoutParkingPassInput = {
    create?: XOR<ParkingPassPaymentCreateWithoutParkingPassInput, ParkingPassPaymentUncheckedCreateWithoutParkingPassInput> | ParkingPassPaymentCreateWithoutParkingPassInput[] | ParkingPassPaymentUncheckedCreateWithoutParkingPassInput[]
    connectOrCreate?: ParkingPassPaymentCreateOrConnectWithoutParkingPassInput | ParkingPassPaymentCreateOrConnectWithoutParkingPassInput[]
    createMany?: ParkingPassPaymentCreateManyParkingPassInputEnvelope
    connect?: ParkingPassPaymentWhereUniqueInput | ParkingPassPaymentWhereUniqueInput[]
  }

  export type ParkingPassPaymentUncheckedCreateNestedManyWithoutParkingPassInput = {
    create?: XOR<ParkingPassPaymentCreateWithoutParkingPassInput, ParkingPassPaymentUncheckedCreateWithoutParkingPassInput> | ParkingPassPaymentCreateWithoutParkingPassInput[] | ParkingPassPaymentUncheckedCreateWithoutParkingPassInput[]
    connectOrCreate?: ParkingPassPaymentCreateOrConnectWithoutParkingPassInput | ParkingPassPaymentCreateOrConnectWithoutParkingPassInput[]
    createMany?: ParkingPassPaymentCreateManyParkingPassInputEnvelope
    connect?: ParkingPassPaymentWhereUniqueInput | ParkingPassPaymentWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutParkingPassesNestedInput = {
    create?: XOR<UserCreateWithoutParkingPassesInput, UserUncheckedCreateWithoutParkingPassesInput>
    connectOrCreate?: UserCreateOrConnectWithoutParkingPassesInput
    upsert?: UserUpsertWithoutParkingPassesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutParkingPassesInput, UserUpdateWithoutParkingPassesInput>, UserUncheckedUpdateWithoutParkingPassesInput>
  }

  export type PlaceUpdateOneRequiredWithoutParkingPassesNestedInput = {
    create?: XOR<PlaceCreateWithoutParkingPassesInput, PlaceUncheckedCreateWithoutParkingPassesInput>
    connectOrCreate?: PlaceCreateOrConnectWithoutParkingPassesInput
    upsert?: PlaceUpsertWithoutParkingPassesInput
    connect?: PlaceWhereUniqueInput
    update?: XOR<XOR<PlaceUpdateToOneWithWhereWithoutParkingPassesInput, PlaceUpdateWithoutParkingPassesInput>, PlaceUncheckedUpdateWithoutParkingPassesInput>
  }

  export type ParkingPassPaymentUpdateManyWithoutParkingPassNestedInput = {
    create?: XOR<ParkingPassPaymentCreateWithoutParkingPassInput, ParkingPassPaymentUncheckedCreateWithoutParkingPassInput> | ParkingPassPaymentCreateWithoutParkingPassInput[] | ParkingPassPaymentUncheckedCreateWithoutParkingPassInput[]
    connectOrCreate?: ParkingPassPaymentCreateOrConnectWithoutParkingPassInput | ParkingPassPaymentCreateOrConnectWithoutParkingPassInput[]
    upsert?: ParkingPassPaymentUpsertWithWhereUniqueWithoutParkingPassInput | ParkingPassPaymentUpsertWithWhereUniqueWithoutParkingPassInput[]
    createMany?: ParkingPassPaymentCreateManyParkingPassInputEnvelope
    set?: ParkingPassPaymentWhereUniqueInput | ParkingPassPaymentWhereUniqueInput[]
    disconnect?: ParkingPassPaymentWhereUniqueInput | ParkingPassPaymentWhereUniqueInput[]
    delete?: ParkingPassPaymentWhereUniqueInput | ParkingPassPaymentWhereUniqueInput[]
    connect?: ParkingPassPaymentWhereUniqueInput | ParkingPassPaymentWhereUniqueInput[]
    update?: ParkingPassPaymentUpdateWithWhereUniqueWithoutParkingPassInput | ParkingPassPaymentUpdateWithWhereUniqueWithoutParkingPassInput[]
    updateMany?: ParkingPassPaymentUpdateManyWithWhereWithoutParkingPassInput | ParkingPassPaymentUpdateManyWithWhereWithoutParkingPassInput[]
    deleteMany?: ParkingPassPaymentScalarWhereInput | ParkingPassPaymentScalarWhereInput[]
  }

  export type ParkingPassPaymentUncheckedUpdateManyWithoutParkingPassNestedInput = {
    create?: XOR<ParkingPassPaymentCreateWithoutParkingPassInput, ParkingPassPaymentUncheckedCreateWithoutParkingPassInput> | ParkingPassPaymentCreateWithoutParkingPassInput[] | ParkingPassPaymentUncheckedCreateWithoutParkingPassInput[]
    connectOrCreate?: ParkingPassPaymentCreateOrConnectWithoutParkingPassInput | ParkingPassPaymentCreateOrConnectWithoutParkingPassInput[]
    upsert?: ParkingPassPaymentUpsertWithWhereUniqueWithoutParkingPassInput | ParkingPassPaymentUpsertWithWhereUniqueWithoutParkingPassInput[]
    createMany?: ParkingPassPaymentCreateManyParkingPassInputEnvelope
    set?: ParkingPassPaymentWhereUniqueInput | ParkingPassPaymentWhereUniqueInput[]
    disconnect?: ParkingPassPaymentWhereUniqueInput | ParkingPassPaymentWhereUniqueInput[]
    delete?: ParkingPassPaymentWhereUniqueInput | ParkingPassPaymentWhereUniqueInput[]
    connect?: ParkingPassPaymentWhereUniqueInput | ParkingPassPaymentWhereUniqueInput[]
    update?: ParkingPassPaymentUpdateWithWhereUniqueWithoutParkingPassInput | ParkingPassPaymentUpdateWithWhereUniqueWithoutParkingPassInput[]
    updateMany?: ParkingPassPaymentUpdateManyWithWhereWithoutParkingPassInput | ParkingPassPaymentUpdateManyWithWhereWithoutParkingPassInput[]
    deleteMany?: ParkingPassPaymentScalarWhereInput | ParkingPassPaymentScalarWhereInput[]
  }

  export type ParkingPassCreateNestedOneWithoutParkingPassPaymentsInput = {
    create?: XOR<ParkingPassCreateWithoutParkingPassPaymentsInput, ParkingPassUncheckedCreateWithoutParkingPassPaymentsInput>
    connectOrCreate?: ParkingPassCreateOrConnectWithoutParkingPassPaymentsInput
    connect?: ParkingPassWhereUniqueInput
  }

  export type PaymentMethodCreateNestedOneWithoutParkingPassPaymentsInput = {
    create?: XOR<PaymentMethodCreateWithoutParkingPassPaymentsInput, PaymentMethodUncheckedCreateWithoutParkingPassPaymentsInput>
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutParkingPassPaymentsInput
    connect?: PaymentMethodWhereUniqueInput
  }

  export type ParkingPassUpdateOneRequiredWithoutParkingPassPaymentsNestedInput = {
    create?: XOR<ParkingPassCreateWithoutParkingPassPaymentsInput, ParkingPassUncheckedCreateWithoutParkingPassPaymentsInput>
    connectOrCreate?: ParkingPassCreateOrConnectWithoutParkingPassPaymentsInput
    upsert?: ParkingPassUpsertWithoutParkingPassPaymentsInput
    connect?: ParkingPassWhereUniqueInput
    update?: XOR<XOR<ParkingPassUpdateToOneWithWhereWithoutParkingPassPaymentsInput, ParkingPassUpdateWithoutParkingPassPaymentsInput>, ParkingPassUncheckedUpdateWithoutParkingPassPaymentsInput>
  }

  export type PaymentMethodUpdateOneRequiredWithoutParkingPassPaymentsNestedInput = {
    create?: XOR<PaymentMethodCreateWithoutParkingPassPaymentsInput, PaymentMethodUncheckedCreateWithoutParkingPassPaymentsInput>
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutParkingPassPaymentsInput
    upsert?: PaymentMethodUpsertWithoutParkingPassPaymentsInput
    connect?: PaymentMethodWhereUniqueInput
    update?: XOR<XOR<PaymentMethodUpdateToOneWithWhereWithoutParkingPassPaymentsInput, PaymentMethodUpdateWithoutParkingPassPaymentsInput>, PaymentMethodUncheckedUpdateWithoutParkingPassPaymentsInput>
  }

  export type BookingCreateNestedOneWithoutAccessLogsInput = {
    create?: XOR<BookingCreateWithoutAccessLogsInput, BookingUncheckedCreateWithoutAccessLogsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutAccessLogsInput
    connect?: BookingWhereUniqueInput
  }

  export type BookingUpdateOneRequiredWithoutAccessLogsNestedInput = {
    create?: XOR<BookingCreateWithoutAccessLogsInput, BookingUncheckedCreateWithoutAccessLogsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutAccessLogsInput
    upsert?: BookingUpsertWithoutAccessLogsInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutAccessLogsInput, BookingUpdateWithoutAccessLogsInput>, BookingUncheckedUpdateWithoutAccessLogsInput>
  }

  export type BookingCreateNestedOneWithoutBookingExtensionsInput = {
    create?: XOR<BookingCreateWithoutBookingExtensionsInput, BookingUncheckedCreateWithoutBookingExtensionsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutBookingExtensionsInput
    connect?: BookingWhereUniqueInput
  }

  export type BookingUpdateOneRequiredWithoutBookingExtensionsNestedInput = {
    create?: XOR<BookingCreateWithoutBookingExtensionsInput, BookingUncheckedCreateWithoutBookingExtensionsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutBookingExtensionsInput
    upsert?: BookingUpsertWithoutBookingExtensionsInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutBookingExtensionsInput, BookingUpdateWithoutBookingExtensionsInput>, BookingUncheckedUpdateWithoutBookingExtensionsInput>
  }

  export type UserCreateNestedOneWithoutNotificationSettingsInput = {
    create?: XOR<UserCreateWithoutNotificationSettingsInput, UserUncheckedCreateWithoutNotificationSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationSettingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationSettingsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationSettingsInput, UserUncheckedCreateWithoutNotificationSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationSettingsInput
    upsert?: UserUpsertWithoutNotificationSettingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationSettingsInput, UserUpdateWithoutNotificationSettingsInput>, UserUncheckedUpdateWithoutNotificationSettingsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type BookingCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<BookingCreateWithoutNotificationsInput, BookingUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutNotificationsInput
    connect?: BookingWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type BookingUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<BookingCreateWithoutNotificationsInput, BookingUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutNotificationsInput
    upsert?: BookingUpsertWithoutNotificationsInput
    disconnect?: BookingWhereInput | boolean
    delete?: BookingWhereInput | boolean
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutNotificationsInput, BookingUpdateWithoutNotificationsInput>, BookingUncheckedUpdateWithoutNotificationsInput>
  }

  export type PlaceCreateNestedOneWithoutPlaceRatingsInput = {
    create?: XOR<PlaceCreateWithoutPlaceRatingsInput, PlaceUncheckedCreateWithoutPlaceRatingsInput>
    connectOrCreate?: PlaceCreateOrConnectWithoutPlaceRatingsInput
    connect?: PlaceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPlaceRatingsInput = {
    create?: XOR<UserCreateWithoutPlaceRatingsInput, UserUncheckedCreateWithoutPlaceRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlaceRatingsInput
    connect?: UserWhereUniqueInput
  }

  export type BookingCreateNestedOneWithoutPlaceRatingsInput = {
    create?: XOR<BookingCreateWithoutPlaceRatingsInput, BookingUncheckedCreateWithoutPlaceRatingsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPlaceRatingsInput
    connect?: BookingWhereUniqueInput
  }

  export type PlaceUpdateOneRequiredWithoutPlaceRatingsNestedInput = {
    create?: XOR<PlaceCreateWithoutPlaceRatingsInput, PlaceUncheckedCreateWithoutPlaceRatingsInput>
    connectOrCreate?: PlaceCreateOrConnectWithoutPlaceRatingsInput
    upsert?: PlaceUpsertWithoutPlaceRatingsInput
    connect?: PlaceWhereUniqueInput
    update?: XOR<XOR<PlaceUpdateToOneWithWhereWithoutPlaceRatingsInput, PlaceUpdateWithoutPlaceRatingsInput>, PlaceUncheckedUpdateWithoutPlaceRatingsInput>
  }

  export type UserUpdateOneRequiredWithoutPlaceRatingsNestedInput = {
    create?: XOR<UserCreateWithoutPlaceRatingsInput, UserUncheckedCreateWithoutPlaceRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlaceRatingsInput
    upsert?: UserUpsertWithoutPlaceRatingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPlaceRatingsInput, UserUpdateWithoutPlaceRatingsInput>, UserUncheckedUpdateWithoutPlaceRatingsInput>
  }

  export type BookingUpdateOneRequiredWithoutPlaceRatingsNestedInput = {
    create?: XOR<BookingCreateWithoutPlaceRatingsInput, BookingUncheckedCreateWithoutPlaceRatingsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPlaceRatingsInput
    upsert?: BookingUpsertWithoutPlaceRatingsInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutPlaceRatingsInput, BookingUpdateWithoutPlaceRatingsInput>, BookingUncheckedUpdateWithoutPlaceRatingsInput>
  }

  export type PlaceCreateNestedOneWithoutOperatingHoursInput = {
    create?: XOR<PlaceCreateWithoutOperatingHoursInput, PlaceUncheckedCreateWithoutOperatingHoursInput>
    connectOrCreate?: PlaceCreateOrConnectWithoutOperatingHoursInput
    connect?: PlaceWhereUniqueInput
  }

  export type PlaceUpdateOneRequiredWithoutOperatingHoursNestedInput = {
    create?: XOR<PlaceCreateWithoutOperatingHoursInput, PlaceUncheckedCreateWithoutOperatingHoursInput>
    connectOrCreate?: PlaceCreateOrConnectWithoutOperatingHoursInput
    upsert?: PlaceUpsertWithoutOperatingHoursInput
    connect?: PlaceWhereUniqueInput
    update?: XOR<XOR<PlaceUpdateToOneWithWhereWithoutOperatingHoursInput, PlaceUpdateWithoutOperatingHoursInput>, PlaceUncheckedUpdateWithoutOperatingHoursInput>
  }

  export type PlaceCreateNestedOneWithoutPlaceAdminsInput = {
    create?: XOR<PlaceCreateWithoutPlaceAdminsInput, PlaceUncheckedCreateWithoutPlaceAdminsInput>
    connectOrCreate?: PlaceCreateOrConnectWithoutPlaceAdminsInput
    connect?: PlaceWhereUniqueInput
  }

  export type PlaceUpdateOneRequiredWithoutPlaceAdminsNestedInput = {
    create?: XOR<PlaceCreateWithoutPlaceAdminsInput, PlaceUncheckedCreateWithoutPlaceAdminsInput>
    connectOrCreate?: PlaceCreateOrConnectWithoutPlaceAdminsInput
    upsert?: PlaceUpsertWithoutPlaceAdminsInput
    connect?: PlaceWhereUniqueInput
    update?: XOR<XOR<PlaceUpdateToOneWithWhereWithoutPlaceAdminsInput, PlaceUpdateWithoutPlaceAdminsInput>, PlaceUncheckedUpdateWithoutPlaceAdminsInput>
  }

  export type UserCreateNestedOneWithoutEmailVerificationTokenInput = {
    create?: XOR<UserCreateWithoutEmailVerificationTokenInput, UserUncheckedCreateWithoutEmailVerificationTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailVerificationTokenInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutEmailVerificationTokenNestedInput = {
    create?: XOR<UserCreateWithoutEmailVerificationTokenInput, UserUncheckedCreateWithoutEmailVerificationTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailVerificationTokenInput
    upsert?: UserUpsertWithoutEmailVerificationTokenInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmailVerificationTokenInput, UserUpdateWithoutEmailVerificationTokenInput>, UserUncheckedUpdateWithoutEmailVerificationTokenInput>
  }

  export type UserCreateNestedOneWithoutPhoneVerificationOtpInput = {
    create?: XOR<UserCreateWithoutPhoneVerificationOtpInput, UserUncheckedCreateWithoutPhoneVerificationOtpInput>
    connectOrCreate?: UserCreateOrConnectWithoutPhoneVerificationOtpInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPhoneVerificationOtpNestedInput = {
    create?: XOR<UserCreateWithoutPhoneVerificationOtpInput, UserUncheckedCreateWithoutPhoneVerificationOtpInput>
    connectOrCreate?: UserCreateOrConnectWithoutPhoneVerificationOtpInput
    upsert?: UserUpsertWithoutPhoneVerificationOtpInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPhoneVerificationOtpInput, UserUpdateWithoutPhoneVerificationOtpInput>, UserUncheckedUpdateWithoutPhoneVerificationOtpInput>
  }

  export type UserCreateNestedOneWithoutPasswordResetTokenInput = {
    create?: XOR<UserCreateWithoutPasswordResetTokenInput, UserUncheckedCreateWithoutPasswordResetTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetTokenInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPasswordResetTokenNestedInput = {
    create?: XOR<UserCreateWithoutPasswordResetTokenInput, UserUncheckedCreateWithoutPasswordResetTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetTokenInput
    upsert?: UserUpsertWithoutPasswordResetTokenInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPasswordResetTokenInput, UserUpdateWithoutPasswordResetTokenInput>, UserUncheckedUpdateWithoutPasswordResetTokenInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type UserProfileCreateWithoutUserInput = {
    firstName?: string | null
    lastName?: string | null
    profilePhoto?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type UserProfileUncheckedCreateWithoutUserInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    profilePhoto?: string | null
    gender?: string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type UserProfileCreateOrConnectWithoutUserInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
  }

  export type VehicleCreateWithoutUserInput = {
    licensePlate: string
    vehicleType: string
    brand?: string | null
    model?: string | null
    color?: string | null
    rfidTag?: string | null
    length?: Decimal | DecimalJsLike | number | string | null
    width?: Decimal | DecimalJsLike | number | string | null
    height?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    bookings?: BookingCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateWithoutUserInput = {
    id?: number
    licensePlate: string
    vehicleType: string
    brand?: string | null
    model?: string | null
    color?: string | null
    rfidTag?: string | null
    length?: Decimal | DecimalJsLike | number | string | null
    width?: Decimal | DecimalJsLike | number | string | null
    height?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    bookings?: BookingUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleCreateOrConnectWithoutUserInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutUserInput, VehicleUncheckedCreateWithoutUserInput>
  }

  export type VehicleCreateManyUserInputEnvelope = {
    data: VehicleCreateManyUserInput | VehicleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutUserInput = {
    bookingReference: string
    bookingTime?: Date | string
    scheduledEntry: Date | string
    scheduledExit: Date | string
    actualEntry?: Date | string | null
    actualExit?: Date | string | null
    qrCode?: string | null
    bookingStatus: string
    estimatedPrice: Decimal | DecimalJsLike | number | string
    finalPrice?: Decimal | DecimalJsLike | number | string | null
    cancellationReason?: string | null
    cancellationTimeMinutes?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    vehicle: VehicleCreateNestedOneWithoutBookingsInput
    parkingSlot: ParkingSlotCreateNestedOneWithoutBookingsInput
    promoCode?: PromoCodeCreateNestedOneWithoutBookingsInput
    bookingStatusLogs?: BookingStatusLogCreateNestedManyWithoutBookingInput
    bookingPayment?: BookingPaymentCreateNestedOneWithoutBookingInput
    accessLogs?: AccessLogCreateNestedManyWithoutBookingInput
    bookingExtensions?: BookingExtensionCreateNestedManyWithoutBookingInput
    placeRatings?: PlaceRatingCreateNestedManyWithoutBookingInput
    notifications?: NotificationCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutUserInput = {
    id?: number
    vehicleId: number
    slotId: number
    promoCodeId?: number | null
    bookingReference: string
    bookingTime?: Date | string
    scheduledEntry: Date | string
    scheduledExit: Date | string
    actualEntry?: Date | string | null
    actualExit?: Date | string | null
    qrCode?: string | null
    bookingStatus: string
    estimatedPrice: Decimal | DecimalJsLike | number | string
    finalPrice?: Decimal | DecimalJsLike | number | string | null
    cancellationReason?: string | null
    cancellationTimeMinutes?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    bookingStatusLogs?: BookingStatusLogUncheckedCreateNestedManyWithoutBookingInput
    bookingPayment?: BookingPaymentUncheckedCreateNestedOneWithoutBookingInput
    accessLogs?: AccessLogUncheckedCreateNestedManyWithoutBookingInput
    bookingExtensions?: BookingExtensionUncheckedCreateNestedManyWithoutBookingInput
    placeRatings?: PlaceRatingUncheckedCreateNestedManyWithoutBookingInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutUserInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput>
  }

  export type BookingCreateManyUserInputEnvelope = {
    data: BookingCreateManyUserInput | BookingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserPaymentMethodCreateWithoutUserInput = {
    tokenReference: string
    maskedInfo?: string | null
    expiryInfo?: string | null
    isDefault?: boolean
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    paymentMethod: PaymentMethodCreateNestedOneWithoutUserPaymentMethodsInput
  }

  export type UserPaymentMethodUncheckedCreateWithoutUserInput = {
    id?: number
    paymentMethodId: number
    tokenReference: string
    maskedInfo?: string | null
    expiryInfo?: string | null
    isDefault?: boolean
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type UserPaymentMethodCreateOrConnectWithoutUserInput = {
    where: UserPaymentMethodWhereUniqueInput
    create: XOR<UserPaymentMethodCreateWithoutUserInput, UserPaymentMethodUncheckedCreateWithoutUserInput>
  }

  export type UserPaymentMethodCreateManyUserInputEnvelope = {
    data: UserPaymentMethodCreateManyUserInput | UserPaymentMethodCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    notificationType: string
    channel: string
    content: string
    isRead?: boolean
    sentTime?: Date | string
    readTime?: Date | string | null
    createdAt?: Date | string
    booking?: BookingCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: number
    bookingId?: number | null
    notificationType: string
    channel: string
    content: string
    isRead?: boolean
    sentTime?: Date | string
    readTime?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ParkingPassCreateWithoutUserInput = {
    passType: string
    passReference?: string | null
    startDate: Date | string
    endDate: Date | string
    price: Decimal | DecimalJsLike | number | string
    status: string
    autoRenew?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    place: PlaceCreateNestedOneWithoutParkingPassesInput
    parkingPassPayments?: ParkingPassPaymentCreateNestedManyWithoutParkingPassInput
  }

  export type ParkingPassUncheckedCreateWithoutUserInput = {
    id?: number
    placeId: number
    passType: string
    passReference?: string | null
    startDate: Date | string
    endDate: Date | string
    price: Decimal | DecimalJsLike | number | string
    status: string
    autoRenew?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    parkingPassPayments?: ParkingPassPaymentUncheckedCreateNestedManyWithoutParkingPassInput
  }

  export type ParkingPassCreateOrConnectWithoutUserInput = {
    where: ParkingPassWhereUniqueInput
    create: XOR<ParkingPassCreateWithoutUserInput, ParkingPassUncheckedCreateWithoutUserInput>
  }

  export type ParkingPassCreateManyUserInputEnvelope = {
    data: ParkingPassCreateManyUserInput | ParkingPassCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PlaceRatingCreateWithoutUserInput = {
    ratingScore: Decimal | DecimalJsLike | number | string
    reviewComment?: string | null
    ratingDate?: Date | string
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    place: PlaceCreateNestedOneWithoutPlaceRatingsInput
    booking: BookingCreateNestedOneWithoutPlaceRatingsInput
  }

  export type PlaceRatingUncheckedCreateWithoutUserInput = {
    id?: number
    placeId: number
    bookingId: number
    ratingScore: Decimal | DecimalJsLike | number | string
    reviewComment?: string | null
    ratingDate?: Date | string
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type PlaceRatingCreateOrConnectWithoutUserInput = {
    where: PlaceRatingWhereUniqueInput
    create: XOR<PlaceRatingCreateWithoutUserInput, PlaceRatingUncheckedCreateWithoutUserInput>
  }

  export type PlaceRatingCreateManyUserInputEnvelope = {
    data: PlaceRatingCreateManyUserInput | PlaceRatingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationSettingCreateWithoutUserInput = {
    emailEnabled?: boolean
    smsEnabled?: boolean
    pushEnabled?: boolean
    bookingConfirmation?: boolean
    paymentNotifications?: boolean
    reminderNotifications?: boolean
    marketingNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type NotificationSettingUncheckedCreateWithoutUserInput = {
    id?: number
    emailEnabled?: boolean
    smsEnabled?: boolean
    pushEnabled?: boolean
    bookingConfirmation?: boolean
    paymentNotifications?: boolean
    reminderNotifications?: boolean
    marketingNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type NotificationSettingCreateOrConnectWithoutUserInput = {
    where: NotificationSettingWhereUniqueInput
    create: XOR<NotificationSettingCreateWithoutUserInput, NotificationSettingUncheckedCreateWithoutUserInput>
  }

  export type UserSessionCreateWithoutUserInput = {
    token: string
    deviceInfo?: string | null
    ipAddress?: string | null
    lastActivity?: Date | string
    expiryTime: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type UserSessionUncheckedCreateWithoutUserInput = {
    id?: number
    token: string
    deviceInfo?: string | null
    ipAddress?: string | null
    lastActivity?: Date | string
    expiryTime: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type UserSessionCreateOrConnectWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionCreateManyUserInputEnvelope = {
    data: UserSessionCreateManyUserInput | UserSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EmailVerificationTokenCreateWithoutUserInput = {
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type EmailVerificationTokenUncheckedCreateWithoutUserInput = {
    id?: number
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type EmailVerificationTokenCreateOrConnectWithoutUserInput = {
    where: EmailVerificationTokenWhereUniqueInput
    create: XOR<EmailVerificationTokenCreateWithoutUserInput, EmailVerificationTokenUncheckedCreateWithoutUserInput>
  }

  export type EmailVerificationTokenCreateManyUserInputEnvelope = {
    data: EmailVerificationTokenCreateManyUserInput | EmailVerificationTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PhoneVerificationOtpCreateWithoutUserInput = {
    phoneNumber: string
    otp: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type PhoneVerificationOtpUncheckedCreateWithoutUserInput = {
    id?: number
    phoneNumber: string
    otp: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type PhoneVerificationOtpCreateOrConnectWithoutUserInput = {
    where: PhoneVerificationOtpWhereUniqueInput
    create: XOR<PhoneVerificationOtpCreateWithoutUserInput, PhoneVerificationOtpUncheckedCreateWithoutUserInput>
  }

  export type PhoneVerificationOtpCreateManyUserInputEnvelope = {
    data: PhoneVerificationOtpCreateManyUserInput | PhoneVerificationOtpCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PasswordResetTokenCreateWithoutUserInput = {
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type PasswordResetTokenUncheckedCreateWithoutUserInput = {
    id?: number
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type PasswordResetTokenCreateOrConnectWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetTokenCreateManyUserInputEnvelope = {
    data: PasswordResetTokenCreateManyUserInput | PasswordResetTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserProfileUpsertWithoutUserInput = {
    update: XOR<UserProfileUpdateWithoutUserInput, UserProfileUncheckedUpdateWithoutUserInput>
    create: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutUserInput, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserProfileUpdateWithoutUserInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserProfileUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VehicleUpsertWithWhereUniqueWithoutUserInput = {
    where: VehicleWhereUniqueInput
    update: XOR<VehicleUpdateWithoutUserInput, VehicleUncheckedUpdateWithoutUserInput>
    create: XOR<VehicleCreateWithoutUserInput, VehicleUncheckedCreateWithoutUserInput>
  }

  export type VehicleUpdateWithWhereUniqueWithoutUserInput = {
    where: VehicleWhereUniqueInput
    data: XOR<VehicleUpdateWithoutUserInput, VehicleUncheckedUpdateWithoutUserInput>
  }

  export type VehicleUpdateManyWithWhereWithoutUserInput = {
    where: VehicleScalarWhereInput
    data: XOR<VehicleUpdateManyMutationInput, VehicleUncheckedUpdateManyWithoutUserInput>
  }

  export type VehicleScalarWhereInput = {
    AND?: VehicleScalarWhereInput | VehicleScalarWhereInput[]
    OR?: VehicleScalarWhereInput[]
    NOT?: VehicleScalarWhereInput | VehicleScalarWhereInput[]
    id?: IntFilter<"Vehicle"> | number
    userId?: IntFilter<"Vehicle"> | number
    licensePlate?: StringFilter<"Vehicle"> | string
    vehicleType?: StringFilter<"Vehicle"> | string
    brand?: StringNullableFilter<"Vehicle"> | string | null
    model?: StringNullableFilter<"Vehicle"> | string | null
    color?: StringNullableFilter<"Vehicle"> | string | null
    rfidTag?: StringNullableFilter<"Vehicle"> | string | null
    length?: DecimalNullableFilter<"Vehicle"> | Decimal | DecimalJsLike | number | string | null
    width?: DecimalNullableFilter<"Vehicle"> | Decimal | DecimalJsLike | number | string | null
    height?: DecimalNullableFilter<"Vehicle"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFilter<"Vehicle"> | boolean
    createdAt?: DateTimeFilter<"Vehicle"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Vehicle"> | Date | string | null
  }

  export type BookingUpsertWithWhereUniqueWithoutUserInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutUserInput, BookingUncheckedUpdateWithoutUserInput>
    create: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutUserInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutUserInput, BookingUncheckedUpdateWithoutUserInput>
  }

  export type BookingUpdateManyWithWhereWithoutUserInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutUserInput>
  }

  export type BookingScalarWhereInput = {
    AND?: BookingScalarWhereInput | BookingScalarWhereInput[]
    OR?: BookingScalarWhereInput[]
    NOT?: BookingScalarWhereInput | BookingScalarWhereInput[]
    id?: IntFilter<"Booking"> | number
    userId?: IntFilter<"Booking"> | number
    vehicleId?: IntFilter<"Booking"> | number
    slotId?: IntFilter<"Booking"> | number
    promoCodeId?: IntNullableFilter<"Booking"> | number | null
    bookingReference?: StringFilter<"Booking"> | string
    bookingTime?: DateTimeFilter<"Booking"> | Date | string
    scheduledEntry?: DateTimeFilter<"Booking"> | Date | string
    scheduledExit?: DateTimeFilter<"Booking"> | Date | string
    actualEntry?: DateTimeNullableFilter<"Booking"> | Date | string | null
    actualExit?: DateTimeNullableFilter<"Booking"> | Date | string | null
    qrCode?: StringNullableFilter<"Booking"> | string | null
    bookingStatus?: StringFilter<"Booking"> | string
    estimatedPrice?: DecimalFilter<"Booking"> | Decimal | DecimalJsLike | number | string
    finalPrice?: DecimalNullableFilter<"Booking"> | Decimal | DecimalJsLike | number | string | null
    cancellationReason?: StringNullableFilter<"Booking"> | string | null
    cancellationTimeMinutes?: IntNullableFilter<"Booking"> | number | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
  }

  export type UserPaymentMethodUpsertWithWhereUniqueWithoutUserInput = {
    where: UserPaymentMethodWhereUniqueInput
    update: XOR<UserPaymentMethodUpdateWithoutUserInput, UserPaymentMethodUncheckedUpdateWithoutUserInput>
    create: XOR<UserPaymentMethodCreateWithoutUserInput, UserPaymentMethodUncheckedCreateWithoutUserInput>
  }

  export type UserPaymentMethodUpdateWithWhereUniqueWithoutUserInput = {
    where: UserPaymentMethodWhereUniqueInput
    data: XOR<UserPaymentMethodUpdateWithoutUserInput, UserPaymentMethodUncheckedUpdateWithoutUserInput>
  }

  export type UserPaymentMethodUpdateManyWithWhereWithoutUserInput = {
    where: UserPaymentMethodScalarWhereInput
    data: XOR<UserPaymentMethodUpdateManyMutationInput, UserPaymentMethodUncheckedUpdateManyWithoutUserInput>
  }

  export type UserPaymentMethodScalarWhereInput = {
    AND?: UserPaymentMethodScalarWhereInput | UserPaymentMethodScalarWhereInput[]
    OR?: UserPaymentMethodScalarWhereInput[]
    NOT?: UserPaymentMethodScalarWhereInput | UserPaymentMethodScalarWhereInput[]
    id?: IntFilter<"UserPaymentMethod"> | number
    userId?: IntFilter<"UserPaymentMethod"> | number
    paymentMethodId?: IntFilter<"UserPaymentMethod"> | number
    tokenReference?: StringFilter<"UserPaymentMethod"> | string
    maskedInfo?: StringNullableFilter<"UserPaymentMethod"> | string | null
    expiryInfo?: StringNullableFilter<"UserPaymentMethod"> | string | null
    isDefault?: BoolFilter<"UserPaymentMethod"> | boolean
    isVerified?: BoolFilter<"UserPaymentMethod"> | boolean
    createdAt?: DateTimeFilter<"UserPaymentMethod"> | Date | string
    updatedAt?: DateTimeNullableFilter<"UserPaymentMethod"> | Date | string | null
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: IntFilter<"Notification"> | number
    userId?: IntFilter<"Notification"> | number
    bookingId?: IntNullableFilter<"Notification"> | number | null
    notificationType?: StringFilter<"Notification"> | string
    channel?: StringFilter<"Notification"> | string
    content?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    sentTime?: DateTimeFilter<"Notification"> | Date | string
    readTime?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type ParkingPassUpsertWithWhereUniqueWithoutUserInput = {
    where: ParkingPassWhereUniqueInput
    update: XOR<ParkingPassUpdateWithoutUserInput, ParkingPassUncheckedUpdateWithoutUserInput>
    create: XOR<ParkingPassCreateWithoutUserInput, ParkingPassUncheckedCreateWithoutUserInput>
  }

  export type ParkingPassUpdateWithWhereUniqueWithoutUserInput = {
    where: ParkingPassWhereUniqueInput
    data: XOR<ParkingPassUpdateWithoutUserInput, ParkingPassUncheckedUpdateWithoutUserInput>
  }

  export type ParkingPassUpdateManyWithWhereWithoutUserInput = {
    where: ParkingPassScalarWhereInput
    data: XOR<ParkingPassUpdateManyMutationInput, ParkingPassUncheckedUpdateManyWithoutUserInput>
  }

  export type ParkingPassScalarWhereInput = {
    AND?: ParkingPassScalarWhereInput | ParkingPassScalarWhereInput[]
    OR?: ParkingPassScalarWhereInput[]
    NOT?: ParkingPassScalarWhereInput | ParkingPassScalarWhereInput[]
    id?: IntFilter<"ParkingPass"> | number
    userId?: IntFilter<"ParkingPass"> | number
    placeId?: IntFilter<"ParkingPass"> | number
    passType?: StringFilter<"ParkingPass"> | string
    passReference?: StringNullableFilter<"ParkingPass"> | string | null
    startDate?: DateTimeFilter<"ParkingPass"> | Date | string
    endDate?: DateTimeFilter<"ParkingPass"> | Date | string
    price?: DecimalFilter<"ParkingPass"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"ParkingPass"> | string
    autoRenew?: BoolFilter<"ParkingPass"> | boolean
    createdAt?: DateTimeFilter<"ParkingPass"> | Date | string
    updatedAt?: DateTimeNullableFilter<"ParkingPass"> | Date | string | null
  }

  export type PlaceRatingUpsertWithWhereUniqueWithoutUserInput = {
    where: PlaceRatingWhereUniqueInput
    update: XOR<PlaceRatingUpdateWithoutUserInput, PlaceRatingUncheckedUpdateWithoutUserInput>
    create: XOR<PlaceRatingCreateWithoutUserInput, PlaceRatingUncheckedCreateWithoutUserInput>
  }

  export type PlaceRatingUpdateWithWhereUniqueWithoutUserInput = {
    where: PlaceRatingWhereUniqueInput
    data: XOR<PlaceRatingUpdateWithoutUserInput, PlaceRatingUncheckedUpdateWithoutUserInput>
  }

  export type PlaceRatingUpdateManyWithWhereWithoutUserInput = {
    where: PlaceRatingScalarWhereInput
    data: XOR<PlaceRatingUpdateManyMutationInput, PlaceRatingUncheckedUpdateManyWithoutUserInput>
  }

  export type PlaceRatingScalarWhereInput = {
    AND?: PlaceRatingScalarWhereInput | PlaceRatingScalarWhereInput[]
    OR?: PlaceRatingScalarWhereInput[]
    NOT?: PlaceRatingScalarWhereInput | PlaceRatingScalarWhereInput[]
    id?: IntFilter<"PlaceRating"> | number
    placeId?: IntFilter<"PlaceRating"> | number
    userId?: IntFilter<"PlaceRating"> | number
    bookingId?: IntFilter<"PlaceRating"> | number
    ratingScore?: DecimalFilter<"PlaceRating"> | Decimal | DecimalJsLike | number | string
    reviewComment?: StringNullableFilter<"PlaceRating"> | string | null
    ratingDate?: DateTimeFilter<"PlaceRating"> | Date | string
    isVerified?: BoolFilter<"PlaceRating"> | boolean
    createdAt?: DateTimeFilter<"PlaceRating"> | Date | string
    updatedAt?: DateTimeNullableFilter<"PlaceRating"> | Date | string | null
  }

  export type NotificationSettingUpsertWithoutUserInput = {
    update: XOR<NotificationSettingUpdateWithoutUserInput, NotificationSettingUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationSettingCreateWithoutUserInput, NotificationSettingUncheckedCreateWithoutUserInput>
    where?: NotificationSettingWhereInput
  }

  export type NotificationSettingUpdateToOneWithWhereWithoutUserInput = {
    where?: NotificationSettingWhereInput
    data: XOR<NotificationSettingUpdateWithoutUserInput, NotificationSettingUncheckedUpdateWithoutUserInput>
  }

  export type NotificationSettingUpdateWithoutUserInput = {
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    smsEnabled?: BoolFieldUpdateOperationsInput | boolean
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingConfirmation?: BoolFieldUpdateOperationsInput | boolean
    paymentNotifications?: BoolFieldUpdateOperationsInput | boolean
    reminderNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationSettingUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    smsEnabled?: BoolFieldUpdateOperationsInput | boolean
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingConfirmation?: BoolFieldUpdateOperationsInput | boolean
    paymentNotifications?: BoolFieldUpdateOperationsInput | boolean
    reminderNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    update: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    data: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
  }

  export type UserSessionUpdateManyWithWhereWithoutUserInput = {
    where: UserSessionScalarWhereInput
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type UserSessionScalarWhereInput = {
    AND?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    OR?: UserSessionScalarWhereInput[]
    NOT?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    id?: IntFilter<"UserSession"> | number
    userId?: IntFilter<"UserSession"> | number
    token?: StringFilter<"UserSession"> | string
    deviceInfo?: StringNullableFilter<"UserSession"> | string | null
    ipAddress?: StringNullableFilter<"UserSession"> | string | null
    lastActivity?: DateTimeFilter<"UserSession"> | Date | string
    expiryTime?: DateTimeFilter<"UserSession"> | Date | string
    isActive?: BoolFilter<"UserSession"> | boolean
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeNullableFilter<"UserSession"> | Date | string | null
  }

  export type EmailVerificationTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: EmailVerificationTokenWhereUniqueInput
    update: XOR<EmailVerificationTokenUpdateWithoutUserInput, EmailVerificationTokenUncheckedUpdateWithoutUserInput>
    create: XOR<EmailVerificationTokenCreateWithoutUserInput, EmailVerificationTokenUncheckedCreateWithoutUserInput>
  }

  export type EmailVerificationTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: EmailVerificationTokenWhereUniqueInput
    data: XOR<EmailVerificationTokenUpdateWithoutUserInput, EmailVerificationTokenUncheckedUpdateWithoutUserInput>
  }

  export type EmailVerificationTokenUpdateManyWithWhereWithoutUserInput = {
    where: EmailVerificationTokenScalarWhereInput
    data: XOR<EmailVerificationTokenUpdateManyMutationInput, EmailVerificationTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type EmailVerificationTokenScalarWhereInput = {
    AND?: EmailVerificationTokenScalarWhereInput | EmailVerificationTokenScalarWhereInput[]
    OR?: EmailVerificationTokenScalarWhereInput[]
    NOT?: EmailVerificationTokenScalarWhereInput | EmailVerificationTokenScalarWhereInput[]
    id?: IntFilter<"EmailVerificationToken"> | number
    userId?: IntFilter<"EmailVerificationToken"> | number
    token?: StringFilter<"EmailVerificationToken"> | string
    expiresAt?: DateTimeFilter<"EmailVerificationToken"> | Date | string
    createdAt?: DateTimeFilter<"EmailVerificationToken"> | Date | string
  }

  export type PhoneVerificationOtpUpsertWithWhereUniqueWithoutUserInput = {
    where: PhoneVerificationOtpWhereUniqueInput
    update: XOR<PhoneVerificationOtpUpdateWithoutUserInput, PhoneVerificationOtpUncheckedUpdateWithoutUserInput>
    create: XOR<PhoneVerificationOtpCreateWithoutUserInput, PhoneVerificationOtpUncheckedCreateWithoutUserInput>
  }

  export type PhoneVerificationOtpUpdateWithWhereUniqueWithoutUserInput = {
    where: PhoneVerificationOtpWhereUniqueInput
    data: XOR<PhoneVerificationOtpUpdateWithoutUserInput, PhoneVerificationOtpUncheckedUpdateWithoutUserInput>
  }

  export type PhoneVerificationOtpUpdateManyWithWhereWithoutUserInput = {
    where: PhoneVerificationOtpScalarWhereInput
    data: XOR<PhoneVerificationOtpUpdateManyMutationInput, PhoneVerificationOtpUncheckedUpdateManyWithoutUserInput>
  }

  export type PhoneVerificationOtpScalarWhereInput = {
    AND?: PhoneVerificationOtpScalarWhereInput | PhoneVerificationOtpScalarWhereInput[]
    OR?: PhoneVerificationOtpScalarWhereInput[]
    NOT?: PhoneVerificationOtpScalarWhereInput | PhoneVerificationOtpScalarWhereInput[]
    id?: IntFilter<"PhoneVerificationOtp"> | number
    userId?: IntFilter<"PhoneVerificationOtp"> | number
    phoneNumber?: StringFilter<"PhoneVerificationOtp"> | string
    otp?: StringFilter<"PhoneVerificationOtp"> | string
    expiresAt?: DateTimeFilter<"PhoneVerificationOtp"> | Date | string
    createdAt?: DateTimeFilter<"PhoneVerificationOtp"> | Date | string
  }

  export type PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    update: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    data: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateManyWithWhereWithoutUserInput = {
    where: PasswordResetTokenScalarWhereInput
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type PasswordResetTokenScalarWhereInput = {
    AND?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
    OR?: PasswordResetTokenScalarWhereInput[]
    NOT?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
    id?: IntFilter<"PasswordResetToken"> | number
    userId?: IntFilter<"PasswordResetToken"> | number
    token?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
  }

  export type UserCreateWithoutSessionsInput = {
    username: string
    email: string
    passwordHash: string
    phoneNumber?: string | null
    accountType: string
    emailVerified?: boolean
    phoneVerified?: boolean
    accountStatus?: string
    googleId?: string | null
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    vehicles?: VehicleCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    userPaymentMethods?: UserPaymentMethodCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    parkingPasses?: ParkingPassCreateNestedManyWithoutUserInput
    placeRatings?: PlaceRatingCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingCreateNestedOneWithoutUserInput
    EmailVerificationToken?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    PhoneVerificationOtp?: PhoneVerificationOtpCreateNestedManyWithoutUserInput
    PasswordResetToken?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    phoneNumber?: string | null
    accountType: string
    emailVerified?: boolean
    phoneVerified?: boolean
    accountStatus?: string
    googleId?: string | null
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    vehicles?: VehicleUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    userPaymentMethods?: UserPaymentMethodUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    parkingPasses?: ParkingPassUncheckedCreateNestedManyWithoutUserInput
    placeRatings?: PlaceRatingUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingUncheckedCreateNestedOneWithoutUserInput
    EmailVerificationToken?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    PhoneVerificationOtp?: PhoneVerificationOtpUncheckedCreateNestedManyWithoutUserInput
    PasswordResetToken?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    accountStatus?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    vehicles?: VehicleUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    userPaymentMethods?: UserPaymentMethodUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    parkingPasses?: ParkingPassUpdateManyWithoutUserNestedInput
    placeRatings?: PlaceRatingUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingUpdateOneWithoutUserNestedInput
    EmailVerificationToken?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    PhoneVerificationOtp?: PhoneVerificationOtpUpdateManyWithoutUserNestedInput
    PasswordResetToken?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    accountStatus?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    vehicles?: VehicleUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    userPaymentMethods?: UserPaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    parkingPasses?: ParkingPassUncheckedUpdateManyWithoutUserNestedInput
    placeRatings?: PlaceRatingUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingUncheckedUpdateOneWithoutUserNestedInput
    EmailVerificationToken?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    PhoneVerificationOtp?: PhoneVerificationOtpUncheckedUpdateManyWithoutUserNestedInput
    PasswordResetToken?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutProfileInput = {
    username: string
    email: string
    passwordHash: string
    phoneNumber?: string | null
    accountType: string
    emailVerified?: boolean
    phoneVerified?: boolean
    accountStatus?: string
    googleId?: string | null
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    vehicles?: VehicleCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    userPaymentMethods?: UserPaymentMethodCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    parkingPasses?: ParkingPassCreateNestedManyWithoutUserInput
    placeRatings?: PlaceRatingCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    EmailVerificationToken?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    PhoneVerificationOtp?: PhoneVerificationOtpCreateNestedManyWithoutUserInput
    PasswordResetToken?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProfileInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    phoneNumber?: string | null
    accountType: string
    emailVerified?: boolean
    phoneVerified?: boolean
    accountStatus?: string
    googleId?: string | null
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    vehicles?: VehicleUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    userPaymentMethods?: UserPaymentMethodUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    parkingPasses?: ParkingPassUncheckedCreateNestedManyWithoutUserInput
    placeRatings?: PlaceRatingUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    EmailVerificationToken?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    PhoneVerificationOtp?: PhoneVerificationOtpUncheckedCreateNestedManyWithoutUserInput
    PasswordResetToken?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type UserUpsertWithoutProfileInput = {
    update: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserUpdateWithoutProfileInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    accountStatus?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicles?: VehicleUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    userPaymentMethods?: UserPaymentMethodUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    parkingPasses?: ParkingPassUpdateManyWithoutUserNestedInput
    placeRatings?: PlaceRatingUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    EmailVerificationToken?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    PhoneVerificationOtp?: PhoneVerificationOtpUpdateManyWithoutUserNestedInput
    PasswordResetToken?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    accountStatus?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicles?: VehicleUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    userPaymentMethods?: UserPaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    parkingPasses?: ParkingPassUncheckedUpdateManyWithoutUserNestedInput
    placeRatings?: PlaceRatingUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    EmailVerificationToken?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    PhoneVerificationOtp?: PhoneVerificationOtpUncheckedUpdateManyWithoutUserNestedInput
    PasswordResetToken?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutVehiclesInput = {
    username: string
    email: string
    passwordHash: string
    phoneNumber?: string | null
    accountType: string
    emailVerified?: boolean
    phoneVerified?: boolean
    accountStatus?: string
    googleId?: string | null
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    userPaymentMethods?: UserPaymentMethodCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    parkingPasses?: ParkingPassCreateNestedManyWithoutUserInput
    placeRatings?: PlaceRatingCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    EmailVerificationToken?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    PhoneVerificationOtp?: PhoneVerificationOtpCreateNestedManyWithoutUserInput
    PasswordResetToken?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVehiclesInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    phoneNumber?: string | null
    accountType: string
    emailVerified?: boolean
    phoneVerified?: boolean
    accountStatus?: string
    googleId?: string | null
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    userPaymentMethods?: UserPaymentMethodUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    parkingPasses?: ParkingPassUncheckedCreateNestedManyWithoutUserInput
    placeRatings?: PlaceRatingUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    EmailVerificationToken?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    PhoneVerificationOtp?: PhoneVerificationOtpUncheckedCreateNestedManyWithoutUserInput
    PasswordResetToken?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVehiclesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVehiclesInput, UserUncheckedCreateWithoutVehiclesInput>
  }

  export type BookingCreateWithoutVehicleInput = {
    bookingReference: string
    bookingTime?: Date | string
    scheduledEntry: Date | string
    scheduledExit: Date | string
    actualEntry?: Date | string | null
    actualExit?: Date | string | null
    qrCode?: string | null
    bookingStatus: string
    estimatedPrice: Decimal | DecimalJsLike | number | string
    finalPrice?: Decimal | DecimalJsLike | number | string | null
    cancellationReason?: string | null
    cancellationTimeMinutes?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutBookingsInput
    parkingSlot: ParkingSlotCreateNestedOneWithoutBookingsInput
    promoCode?: PromoCodeCreateNestedOneWithoutBookingsInput
    bookingStatusLogs?: BookingStatusLogCreateNestedManyWithoutBookingInput
    bookingPayment?: BookingPaymentCreateNestedOneWithoutBookingInput
    accessLogs?: AccessLogCreateNestedManyWithoutBookingInput
    bookingExtensions?: BookingExtensionCreateNestedManyWithoutBookingInput
    placeRatings?: PlaceRatingCreateNestedManyWithoutBookingInput
    notifications?: NotificationCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutVehicleInput = {
    id?: number
    userId: number
    slotId: number
    promoCodeId?: number | null
    bookingReference: string
    bookingTime?: Date | string
    scheduledEntry: Date | string
    scheduledExit: Date | string
    actualEntry?: Date | string | null
    actualExit?: Date | string | null
    qrCode?: string | null
    bookingStatus: string
    estimatedPrice: Decimal | DecimalJsLike | number | string
    finalPrice?: Decimal | DecimalJsLike | number | string | null
    cancellationReason?: string | null
    cancellationTimeMinutes?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    bookingStatusLogs?: BookingStatusLogUncheckedCreateNestedManyWithoutBookingInput
    bookingPayment?: BookingPaymentUncheckedCreateNestedOneWithoutBookingInput
    accessLogs?: AccessLogUncheckedCreateNestedManyWithoutBookingInput
    bookingExtensions?: BookingExtensionUncheckedCreateNestedManyWithoutBookingInput
    placeRatings?: PlaceRatingUncheckedCreateNestedManyWithoutBookingInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutVehicleInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutVehicleInput, BookingUncheckedCreateWithoutVehicleInput>
  }

  export type BookingCreateManyVehicleInputEnvelope = {
    data: BookingCreateManyVehicleInput | BookingCreateManyVehicleInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutVehiclesInput = {
    update: XOR<UserUpdateWithoutVehiclesInput, UserUncheckedUpdateWithoutVehiclesInput>
    create: XOR<UserCreateWithoutVehiclesInput, UserUncheckedCreateWithoutVehiclesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVehiclesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVehiclesInput, UserUncheckedUpdateWithoutVehiclesInput>
  }

  export type UserUpdateWithoutVehiclesInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    accountStatus?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    userPaymentMethods?: UserPaymentMethodUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    parkingPasses?: ParkingPassUpdateManyWithoutUserNestedInput
    placeRatings?: PlaceRatingUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    EmailVerificationToken?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    PhoneVerificationOtp?: PhoneVerificationOtpUpdateManyWithoutUserNestedInput
    PasswordResetToken?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVehiclesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    accountStatus?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    userPaymentMethods?: UserPaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    parkingPasses?: ParkingPassUncheckedUpdateManyWithoutUserNestedInput
    placeRatings?: PlaceRatingUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    EmailVerificationToken?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    PhoneVerificationOtp?: PhoneVerificationOtpUncheckedUpdateManyWithoutUserNestedInput
    PasswordResetToken?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BookingUpsertWithWhereUniqueWithoutVehicleInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutVehicleInput, BookingUncheckedUpdateWithoutVehicleInput>
    create: XOR<BookingCreateWithoutVehicleInput, BookingUncheckedCreateWithoutVehicleInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutVehicleInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutVehicleInput, BookingUncheckedUpdateWithoutVehicleInput>
  }

  export type BookingUpdateManyWithWhereWithoutVehicleInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutVehicleInput>
  }

  export type ParkingZoneCreateWithoutPlaceInput = {
    zoneName: string
    floorLevel?: string | null
    zoneType?: string | null
    totalSlots: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    parkingSlots?: ParkingSlotCreateNestedManyWithoutParkingZoneInput
  }

  export type ParkingZoneUncheckedCreateWithoutPlaceInput = {
    id?: number
    zoneName: string
    floorLevel?: string | null
    zoneType?: string | null
    totalSlots: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    parkingSlots?: ParkingSlotUncheckedCreateNestedManyWithoutParkingZoneInput
  }

  export type ParkingZoneCreateOrConnectWithoutPlaceInput = {
    where: ParkingZoneWhereUniqueInput
    create: XOR<ParkingZoneCreateWithoutPlaceInput, ParkingZoneUncheckedCreateWithoutPlaceInput>
  }

  export type ParkingZoneCreateManyPlaceInputEnvelope = {
    data: ParkingZoneCreateManyPlaceInput | ParkingZoneCreateManyPlaceInput[]
    skipDuplicates?: boolean
  }

  export type TariffPlanCreateWithoutPlaceInput = {
    planName: string
    description?: string | null
    effectiveFrom: Date | string
    effectiveUntil?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    tariffRates?: TariffRateCreateNestedManyWithoutTariffPlanInput
  }

  export type TariffPlanUncheckedCreateWithoutPlaceInput = {
    id?: number
    planName: string
    description?: string | null
    effectiveFrom: Date | string
    effectiveUntil?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    tariffRates?: TariffRateUncheckedCreateNestedManyWithoutTariffPlanInput
  }

  export type TariffPlanCreateOrConnectWithoutPlaceInput = {
    where: TariffPlanWhereUniqueInput
    create: XOR<TariffPlanCreateWithoutPlaceInput, TariffPlanUncheckedCreateWithoutPlaceInput>
  }

  export type TariffPlanCreateManyPlaceInputEnvelope = {
    data: TariffPlanCreateManyPlaceInput | TariffPlanCreateManyPlaceInput[]
    skipDuplicates?: boolean
  }

  export type ParkingPassCreateWithoutPlaceInput = {
    passType: string
    passReference?: string | null
    startDate: Date | string
    endDate: Date | string
    price: Decimal | DecimalJsLike | number | string
    status: string
    autoRenew?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutParkingPassesInput
    parkingPassPayments?: ParkingPassPaymentCreateNestedManyWithoutParkingPassInput
  }

  export type ParkingPassUncheckedCreateWithoutPlaceInput = {
    id?: number
    userId: number
    passType: string
    passReference?: string | null
    startDate: Date | string
    endDate: Date | string
    price: Decimal | DecimalJsLike | number | string
    status: string
    autoRenew?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    parkingPassPayments?: ParkingPassPaymentUncheckedCreateNestedManyWithoutParkingPassInput
  }

  export type ParkingPassCreateOrConnectWithoutPlaceInput = {
    where: ParkingPassWhereUniqueInput
    create: XOR<ParkingPassCreateWithoutPlaceInput, ParkingPassUncheckedCreateWithoutPlaceInput>
  }

  export type ParkingPassCreateManyPlaceInputEnvelope = {
    data: ParkingPassCreateManyPlaceInput | ParkingPassCreateManyPlaceInput[]
    skipDuplicates?: boolean
  }

  export type OperatingHourCreateWithoutPlaceInput = {
    dayOfWeek: string
    openingTime?: Date | string | null
    closingTime?: Date | string | null
    is24hours?: boolean
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type OperatingHourUncheckedCreateWithoutPlaceInput = {
    id?: number
    dayOfWeek: string
    openingTime?: Date | string | null
    closingTime?: Date | string | null
    is24hours?: boolean
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type OperatingHourCreateOrConnectWithoutPlaceInput = {
    where: OperatingHourWhereUniqueInput
    create: XOR<OperatingHourCreateWithoutPlaceInput, OperatingHourUncheckedCreateWithoutPlaceInput>
  }

  export type OperatingHourCreateManyPlaceInputEnvelope = {
    data: OperatingHourCreateManyPlaceInput | OperatingHourCreateManyPlaceInput[]
    skipDuplicates?: boolean
  }

  export type PlaceAdminCreateWithoutPlaceInput = {
    username: string
    email: string
    passwordHash: string
    fullName: string
    role: string
    contactNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type PlaceAdminUncheckedCreateWithoutPlaceInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    fullName: string
    role: string
    contactNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type PlaceAdminCreateOrConnectWithoutPlaceInput = {
    where: PlaceAdminWhereUniqueInput
    create: XOR<PlaceAdminCreateWithoutPlaceInput, PlaceAdminUncheckedCreateWithoutPlaceInput>
  }

  export type PlaceAdminCreateManyPlaceInputEnvelope = {
    data: PlaceAdminCreateManyPlaceInput | PlaceAdminCreateManyPlaceInput[]
    skipDuplicates?: boolean
  }

  export type PlaceRatingCreateWithoutPlaceInput = {
    ratingScore: Decimal | DecimalJsLike | number | string
    reviewComment?: string | null
    ratingDate?: Date | string
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutPlaceRatingsInput
    booking: BookingCreateNestedOneWithoutPlaceRatingsInput
  }

  export type PlaceRatingUncheckedCreateWithoutPlaceInput = {
    id?: number
    userId: number
    bookingId: number
    ratingScore: Decimal | DecimalJsLike | number | string
    reviewComment?: string | null
    ratingDate?: Date | string
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type PlaceRatingCreateOrConnectWithoutPlaceInput = {
    where: PlaceRatingWhereUniqueInput
    create: XOR<PlaceRatingCreateWithoutPlaceInput, PlaceRatingUncheckedCreateWithoutPlaceInput>
  }

  export type PlaceRatingCreateManyPlaceInputEnvelope = {
    data: PlaceRatingCreateManyPlaceInput | PlaceRatingCreateManyPlaceInput[]
    skipDuplicates?: boolean
  }

  export type ParkingZoneUpsertWithWhereUniqueWithoutPlaceInput = {
    where: ParkingZoneWhereUniqueInput
    update: XOR<ParkingZoneUpdateWithoutPlaceInput, ParkingZoneUncheckedUpdateWithoutPlaceInput>
    create: XOR<ParkingZoneCreateWithoutPlaceInput, ParkingZoneUncheckedCreateWithoutPlaceInput>
  }

  export type ParkingZoneUpdateWithWhereUniqueWithoutPlaceInput = {
    where: ParkingZoneWhereUniqueInput
    data: XOR<ParkingZoneUpdateWithoutPlaceInput, ParkingZoneUncheckedUpdateWithoutPlaceInput>
  }

  export type ParkingZoneUpdateManyWithWhereWithoutPlaceInput = {
    where: ParkingZoneScalarWhereInput
    data: XOR<ParkingZoneUpdateManyMutationInput, ParkingZoneUncheckedUpdateManyWithoutPlaceInput>
  }

  export type ParkingZoneScalarWhereInput = {
    AND?: ParkingZoneScalarWhereInput | ParkingZoneScalarWhereInput[]
    OR?: ParkingZoneScalarWhereInput[]
    NOT?: ParkingZoneScalarWhereInput | ParkingZoneScalarWhereInput[]
    id?: IntFilter<"ParkingZone"> | number
    placeId?: IntFilter<"ParkingZone"> | number
    zoneName?: StringFilter<"ParkingZone"> | string
    floorLevel?: StringNullableFilter<"ParkingZone"> | string | null
    zoneType?: StringNullableFilter<"ParkingZone"> | string | null
    totalSlots?: IntFilter<"ParkingZone"> | number
    isActive?: BoolFilter<"ParkingZone"> | boolean
    createdAt?: DateTimeFilter<"ParkingZone"> | Date | string
    updatedAt?: DateTimeNullableFilter<"ParkingZone"> | Date | string | null
  }

  export type TariffPlanUpsertWithWhereUniqueWithoutPlaceInput = {
    where: TariffPlanWhereUniqueInput
    update: XOR<TariffPlanUpdateWithoutPlaceInput, TariffPlanUncheckedUpdateWithoutPlaceInput>
    create: XOR<TariffPlanCreateWithoutPlaceInput, TariffPlanUncheckedCreateWithoutPlaceInput>
  }

  export type TariffPlanUpdateWithWhereUniqueWithoutPlaceInput = {
    where: TariffPlanWhereUniqueInput
    data: XOR<TariffPlanUpdateWithoutPlaceInput, TariffPlanUncheckedUpdateWithoutPlaceInput>
  }

  export type TariffPlanUpdateManyWithWhereWithoutPlaceInput = {
    where: TariffPlanScalarWhereInput
    data: XOR<TariffPlanUpdateManyMutationInput, TariffPlanUncheckedUpdateManyWithoutPlaceInput>
  }

  export type TariffPlanScalarWhereInput = {
    AND?: TariffPlanScalarWhereInput | TariffPlanScalarWhereInput[]
    OR?: TariffPlanScalarWhereInput[]
    NOT?: TariffPlanScalarWhereInput | TariffPlanScalarWhereInput[]
    id?: IntFilter<"TariffPlan"> | number
    placeId?: IntFilter<"TariffPlan"> | number
    planName?: StringFilter<"TariffPlan"> | string
    description?: StringNullableFilter<"TariffPlan"> | string | null
    effectiveFrom?: DateTimeFilter<"TariffPlan"> | Date | string
    effectiveUntil?: DateTimeNullableFilter<"TariffPlan"> | Date | string | null
    isActive?: BoolFilter<"TariffPlan"> | boolean
    createdAt?: DateTimeFilter<"TariffPlan"> | Date | string
    updatedAt?: DateTimeNullableFilter<"TariffPlan"> | Date | string | null
  }

  export type ParkingPassUpsertWithWhereUniqueWithoutPlaceInput = {
    where: ParkingPassWhereUniqueInput
    update: XOR<ParkingPassUpdateWithoutPlaceInput, ParkingPassUncheckedUpdateWithoutPlaceInput>
    create: XOR<ParkingPassCreateWithoutPlaceInput, ParkingPassUncheckedCreateWithoutPlaceInput>
  }

  export type ParkingPassUpdateWithWhereUniqueWithoutPlaceInput = {
    where: ParkingPassWhereUniqueInput
    data: XOR<ParkingPassUpdateWithoutPlaceInput, ParkingPassUncheckedUpdateWithoutPlaceInput>
  }

  export type ParkingPassUpdateManyWithWhereWithoutPlaceInput = {
    where: ParkingPassScalarWhereInput
    data: XOR<ParkingPassUpdateManyMutationInput, ParkingPassUncheckedUpdateManyWithoutPlaceInput>
  }

  export type OperatingHourUpsertWithWhereUniqueWithoutPlaceInput = {
    where: OperatingHourWhereUniqueInput
    update: XOR<OperatingHourUpdateWithoutPlaceInput, OperatingHourUncheckedUpdateWithoutPlaceInput>
    create: XOR<OperatingHourCreateWithoutPlaceInput, OperatingHourUncheckedCreateWithoutPlaceInput>
  }

  export type OperatingHourUpdateWithWhereUniqueWithoutPlaceInput = {
    where: OperatingHourWhereUniqueInput
    data: XOR<OperatingHourUpdateWithoutPlaceInput, OperatingHourUncheckedUpdateWithoutPlaceInput>
  }

  export type OperatingHourUpdateManyWithWhereWithoutPlaceInput = {
    where: OperatingHourScalarWhereInput
    data: XOR<OperatingHourUpdateManyMutationInput, OperatingHourUncheckedUpdateManyWithoutPlaceInput>
  }

  export type OperatingHourScalarWhereInput = {
    AND?: OperatingHourScalarWhereInput | OperatingHourScalarWhereInput[]
    OR?: OperatingHourScalarWhereInput[]
    NOT?: OperatingHourScalarWhereInput | OperatingHourScalarWhereInput[]
    id?: IntFilter<"OperatingHour"> | number
    placeId?: IntFilter<"OperatingHour"> | number
    dayOfWeek?: StringFilter<"OperatingHour"> | string
    openingTime?: DateTimeNullableFilter<"OperatingHour"> | Date | string | null
    closingTime?: DateTimeNullableFilter<"OperatingHour"> | Date | string | null
    is24hours?: BoolFilter<"OperatingHour"> | boolean
    isClosed?: BoolFilter<"OperatingHour"> | boolean
    createdAt?: DateTimeFilter<"OperatingHour"> | Date | string
    updatedAt?: DateTimeNullableFilter<"OperatingHour"> | Date | string | null
  }

  export type PlaceAdminUpsertWithWhereUniqueWithoutPlaceInput = {
    where: PlaceAdminWhereUniqueInput
    update: XOR<PlaceAdminUpdateWithoutPlaceInput, PlaceAdminUncheckedUpdateWithoutPlaceInput>
    create: XOR<PlaceAdminCreateWithoutPlaceInput, PlaceAdminUncheckedCreateWithoutPlaceInput>
  }

  export type PlaceAdminUpdateWithWhereUniqueWithoutPlaceInput = {
    where: PlaceAdminWhereUniqueInput
    data: XOR<PlaceAdminUpdateWithoutPlaceInput, PlaceAdminUncheckedUpdateWithoutPlaceInput>
  }

  export type PlaceAdminUpdateManyWithWhereWithoutPlaceInput = {
    where: PlaceAdminScalarWhereInput
    data: XOR<PlaceAdminUpdateManyMutationInput, PlaceAdminUncheckedUpdateManyWithoutPlaceInput>
  }

  export type PlaceAdminScalarWhereInput = {
    AND?: PlaceAdminScalarWhereInput | PlaceAdminScalarWhereInput[]
    OR?: PlaceAdminScalarWhereInput[]
    NOT?: PlaceAdminScalarWhereInput | PlaceAdminScalarWhereInput[]
    id?: IntFilter<"PlaceAdmin"> | number
    placeId?: IntFilter<"PlaceAdmin"> | number
    username?: StringFilter<"PlaceAdmin"> | string
    email?: StringFilter<"PlaceAdmin"> | string
    passwordHash?: StringFilter<"PlaceAdmin"> | string
    fullName?: StringFilter<"PlaceAdmin"> | string
    role?: StringFilter<"PlaceAdmin"> | string
    contactNumber?: StringNullableFilter<"PlaceAdmin"> | string | null
    isActive?: BoolFilter<"PlaceAdmin"> | boolean
    createdAt?: DateTimeFilter<"PlaceAdmin"> | Date | string
    updatedAt?: DateTimeNullableFilter<"PlaceAdmin"> | Date | string | null
  }

  export type PlaceRatingUpsertWithWhereUniqueWithoutPlaceInput = {
    where: PlaceRatingWhereUniqueInput
    update: XOR<PlaceRatingUpdateWithoutPlaceInput, PlaceRatingUncheckedUpdateWithoutPlaceInput>
    create: XOR<PlaceRatingCreateWithoutPlaceInput, PlaceRatingUncheckedCreateWithoutPlaceInput>
  }

  export type PlaceRatingUpdateWithWhereUniqueWithoutPlaceInput = {
    where: PlaceRatingWhereUniqueInput
    data: XOR<PlaceRatingUpdateWithoutPlaceInput, PlaceRatingUncheckedUpdateWithoutPlaceInput>
  }

  export type PlaceRatingUpdateManyWithWhereWithoutPlaceInput = {
    where: PlaceRatingScalarWhereInput
    data: XOR<PlaceRatingUpdateManyMutationInput, PlaceRatingUncheckedUpdateManyWithoutPlaceInput>
  }

  export type PlaceCreateWithoutParkingZonesInput = {
    name: string
    image?: string | null
    placeType: string
    address: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    contactNumber?: string | null
    email?: string | null
    description?: string | null
    totalCapacity: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    tariffPlans?: TariffPlanCreateNestedManyWithoutPlaceInput
    parkingPasses?: ParkingPassCreateNestedManyWithoutPlaceInput
    operatingHours?: OperatingHourCreateNestedManyWithoutPlaceInput
    placeAdmins?: PlaceAdminCreateNestedManyWithoutPlaceInput
    placeRatings?: PlaceRatingCreateNestedManyWithoutPlaceInput
  }

  export type PlaceUncheckedCreateWithoutParkingZonesInput = {
    id?: number
    name: string
    image?: string | null
    placeType: string
    address: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    contactNumber?: string | null
    email?: string | null
    description?: string | null
    totalCapacity: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutPlaceInput
    parkingPasses?: ParkingPassUncheckedCreateNestedManyWithoutPlaceInput
    operatingHours?: OperatingHourUncheckedCreateNestedManyWithoutPlaceInput
    placeAdmins?: PlaceAdminUncheckedCreateNestedManyWithoutPlaceInput
    placeRatings?: PlaceRatingUncheckedCreateNestedManyWithoutPlaceInput
  }

  export type PlaceCreateOrConnectWithoutParkingZonesInput = {
    where: PlaceWhereUniqueInput
    create: XOR<PlaceCreateWithoutParkingZonesInput, PlaceUncheckedCreateWithoutParkingZonesInput>
  }

  export type ParkingSlotCreateWithoutParkingZoneInput = {
    slotNumber: string
    slotType: string
    isReserved?: boolean
    isOccupied?: boolean
    isDisabledFriendly?: boolean
    hasEvCharger?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    slotAvailability?: SlotAvailabilityCreateNestedManyWithoutParkingSlotInput
    bookings?: BookingCreateNestedManyWithoutParkingSlotInput
  }

  export type ParkingSlotUncheckedCreateWithoutParkingZoneInput = {
    id?: number
    slotNumber: string
    slotType: string
    isReserved?: boolean
    isOccupied?: boolean
    isDisabledFriendly?: boolean
    hasEvCharger?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    slotAvailability?: SlotAvailabilityUncheckedCreateNestedManyWithoutParkingSlotInput
    bookings?: BookingUncheckedCreateNestedManyWithoutParkingSlotInput
  }

  export type ParkingSlotCreateOrConnectWithoutParkingZoneInput = {
    where: ParkingSlotWhereUniqueInput
    create: XOR<ParkingSlotCreateWithoutParkingZoneInput, ParkingSlotUncheckedCreateWithoutParkingZoneInput>
  }

  export type ParkingSlotCreateManyParkingZoneInputEnvelope = {
    data: ParkingSlotCreateManyParkingZoneInput | ParkingSlotCreateManyParkingZoneInput[]
    skipDuplicates?: boolean
  }

  export type PlaceUpsertWithoutParkingZonesInput = {
    update: XOR<PlaceUpdateWithoutParkingZonesInput, PlaceUncheckedUpdateWithoutParkingZonesInput>
    create: XOR<PlaceCreateWithoutParkingZonesInput, PlaceUncheckedCreateWithoutParkingZonesInput>
    where?: PlaceWhereInput
  }

  export type PlaceUpdateToOneWithWhereWithoutParkingZonesInput = {
    where?: PlaceWhereInput
    data: XOR<PlaceUpdateWithoutParkingZonesInput, PlaceUncheckedUpdateWithoutParkingZonesInput>
  }

  export type PlaceUpdateWithoutParkingZonesInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    placeType?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalCapacity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tariffPlans?: TariffPlanUpdateManyWithoutPlaceNestedInput
    parkingPasses?: ParkingPassUpdateManyWithoutPlaceNestedInput
    operatingHours?: OperatingHourUpdateManyWithoutPlaceNestedInput
    placeAdmins?: PlaceAdminUpdateManyWithoutPlaceNestedInput
    placeRatings?: PlaceRatingUpdateManyWithoutPlaceNestedInput
  }

  export type PlaceUncheckedUpdateWithoutParkingZonesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    placeType?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalCapacity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutPlaceNestedInput
    parkingPasses?: ParkingPassUncheckedUpdateManyWithoutPlaceNestedInput
    operatingHours?: OperatingHourUncheckedUpdateManyWithoutPlaceNestedInput
    placeAdmins?: PlaceAdminUncheckedUpdateManyWithoutPlaceNestedInput
    placeRatings?: PlaceRatingUncheckedUpdateManyWithoutPlaceNestedInput
  }

  export type ParkingSlotUpsertWithWhereUniqueWithoutParkingZoneInput = {
    where: ParkingSlotWhereUniqueInput
    update: XOR<ParkingSlotUpdateWithoutParkingZoneInput, ParkingSlotUncheckedUpdateWithoutParkingZoneInput>
    create: XOR<ParkingSlotCreateWithoutParkingZoneInput, ParkingSlotUncheckedCreateWithoutParkingZoneInput>
  }

  export type ParkingSlotUpdateWithWhereUniqueWithoutParkingZoneInput = {
    where: ParkingSlotWhereUniqueInput
    data: XOR<ParkingSlotUpdateWithoutParkingZoneInput, ParkingSlotUncheckedUpdateWithoutParkingZoneInput>
  }

  export type ParkingSlotUpdateManyWithWhereWithoutParkingZoneInput = {
    where: ParkingSlotScalarWhereInput
    data: XOR<ParkingSlotUpdateManyMutationInput, ParkingSlotUncheckedUpdateManyWithoutParkingZoneInput>
  }

  export type ParkingSlotScalarWhereInput = {
    AND?: ParkingSlotScalarWhereInput | ParkingSlotScalarWhereInput[]
    OR?: ParkingSlotScalarWhereInput[]
    NOT?: ParkingSlotScalarWhereInput | ParkingSlotScalarWhereInput[]
    id?: IntFilter<"ParkingSlot"> | number
    zoneId?: IntFilter<"ParkingSlot"> | number
    slotNumber?: StringFilter<"ParkingSlot"> | string
    slotType?: StringFilter<"ParkingSlot"> | string
    isReserved?: BoolFilter<"ParkingSlot"> | boolean
    isOccupied?: BoolFilter<"ParkingSlot"> | boolean
    isDisabledFriendly?: BoolFilter<"ParkingSlot"> | boolean
    hasEvCharger?: BoolFilter<"ParkingSlot"> | boolean
    isActive?: BoolFilter<"ParkingSlot"> | boolean
    createdAt?: DateTimeFilter<"ParkingSlot"> | Date | string
    updatedAt?: DateTimeNullableFilter<"ParkingSlot"> | Date | string | null
  }

  export type ParkingZoneCreateWithoutParkingSlotsInput = {
    zoneName: string
    floorLevel?: string | null
    zoneType?: string | null
    totalSlots: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    place: PlaceCreateNestedOneWithoutParkingZonesInput
  }

  export type ParkingZoneUncheckedCreateWithoutParkingSlotsInput = {
    id?: number
    placeId: number
    zoneName: string
    floorLevel?: string | null
    zoneType?: string | null
    totalSlots: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type ParkingZoneCreateOrConnectWithoutParkingSlotsInput = {
    where: ParkingZoneWhereUniqueInput
    create: XOR<ParkingZoneCreateWithoutParkingSlotsInput, ParkingZoneUncheckedCreateWithoutParkingSlotsInput>
  }

  export type SlotAvailabilityCreateWithoutParkingSlotInput = {
    availableFrom: Date | string
    availableUntil: Date | string
    isBookable?: boolean
    statusReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type SlotAvailabilityUncheckedCreateWithoutParkingSlotInput = {
    id?: number
    availableFrom: Date | string
    availableUntil: Date | string
    isBookable?: boolean
    statusReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type SlotAvailabilityCreateOrConnectWithoutParkingSlotInput = {
    where: SlotAvailabilityWhereUniqueInput
    create: XOR<SlotAvailabilityCreateWithoutParkingSlotInput, SlotAvailabilityUncheckedCreateWithoutParkingSlotInput>
  }

  export type SlotAvailabilityCreateManyParkingSlotInputEnvelope = {
    data: SlotAvailabilityCreateManyParkingSlotInput | SlotAvailabilityCreateManyParkingSlotInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutParkingSlotInput = {
    bookingReference: string
    bookingTime?: Date | string
    scheduledEntry: Date | string
    scheduledExit: Date | string
    actualEntry?: Date | string | null
    actualExit?: Date | string | null
    qrCode?: string | null
    bookingStatus: string
    estimatedPrice: Decimal | DecimalJsLike | number | string
    finalPrice?: Decimal | DecimalJsLike | number | string | null
    cancellationReason?: string | null
    cancellationTimeMinutes?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutBookingsInput
    vehicle: VehicleCreateNestedOneWithoutBookingsInput
    promoCode?: PromoCodeCreateNestedOneWithoutBookingsInput
    bookingStatusLogs?: BookingStatusLogCreateNestedManyWithoutBookingInput
    bookingPayment?: BookingPaymentCreateNestedOneWithoutBookingInput
    accessLogs?: AccessLogCreateNestedManyWithoutBookingInput
    bookingExtensions?: BookingExtensionCreateNestedManyWithoutBookingInput
    placeRatings?: PlaceRatingCreateNestedManyWithoutBookingInput
    notifications?: NotificationCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutParkingSlotInput = {
    id?: number
    userId: number
    vehicleId: number
    promoCodeId?: number | null
    bookingReference: string
    bookingTime?: Date | string
    scheduledEntry: Date | string
    scheduledExit: Date | string
    actualEntry?: Date | string | null
    actualExit?: Date | string | null
    qrCode?: string | null
    bookingStatus: string
    estimatedPrice: Decimal | DecimalJsLike | number | string
    finalPrice?: Decimal | DecimalJsLike | number | string | null
    cancellationReason?: string | null
    cancellationTimeMinutes?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    bookingStatusLogs?: BookingStatusLogUncheckedCreateNestedManyWithoutBookingInput
    bookingPayment?: BookingPaymentUncheckedCreateNestedOneWithoutBookingInput
    accessLogs?: AccessLogUncheckedCreateNestedManyWithoutBookingInput
    bookingExtensions?: BookingExtensionUncheckedCreateNestedManyWithoutBookingInput
    placeRatings?: PlaceRatingUncheckedCreateNestedManyWithoutBookingInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutParkingSlotInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutParkingSlotInput, BookingUncheckedCreateWithoutParkingSlotInput>
  }

  export type BookingCreateManyParkingSlotInputEnvelope = {
    data: BookingCreateManyParkingSlotInput | BookingCreateManyParkingSlotInput[]
    skipDuplicates?: boolean
  }

  export type ParkingZoneUpsertWithoutParkingSlotsInput = {
    update: XOR<ParkingZoneUpdateWithoutParkingSlotsInput, ParkingZoneUncheckedUpdateWithoutParkingSlotsInput>
    create: XOR<ParkingZoneCreateWithoutParkingSlotsInput, ParkingZoneUncheckedCreateWithoutParkingSlotsInput>
    where?: ParkingZoneWhereInput
  }

  export type ParkingZoneUpdateToOneWithWhereWithoutParkingSlotsInput = {
    where?: ParkingZoneWhereInput
    data: XOR<ParkingZoneUpdateWithoutParkingSlotsInput, ParkingZoneUncheckedUpdateWithoutParkingSlotsInput>
  }

  export type ParkingZoneUpdateWithoutParkingSlotsInput = {
    zoneName?: StringFieldUpdateOperationsInput | string
    floorLevel?: NullableStringFieldUpdateOperationsInput | string | null
    zoneType?: NullableStringFieldUpdateOperationsInput | string | null
    totalSlots?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    place?: PlaceUpdateOneRequiredWithoutParkingZonesNestedInput
  }

  export type ParkingZoneUncheckedUpdateWithoutParkingSlotsInput = {
    id?: IntFieldUpdateOperationsInput | number
    placeId?: IntFieldUpdateOperationsInput | number
    zoneName?: StringFieldUpdateOperationsInput | string
    floorLevel?: NullableStringFieldUpdateOperationsInput | string | null
    zoneType?: NullableStringFieldUpdateOperationsInput | string | null
    totalSlots?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SlotAvailabilityUpsertWithWhereUniqueWithoutParkingSlotInput = {
    where: SlotAvailabilityWhereUniqueInput
    update: XOR<SlotAvailabilityUpdateWithoutParkingSlotInput, SlotAvailabilityUncheckedUpdateWithoutParkingSlotInput>
    create: XOR<SlotAvailabilityCreateWithoutParkingSlotInput, SlotAvailabilityUncheckedCreateWithoutParkingSlotInput>
  }

  export type SlotAvailabilityUpdateWithWhereUniqueWithoutParkingSlotInput = {
    where: SlotAvailabilityWhereUniqueInput
    data: XOR<SlotAvailabilityUpdateWithoutParkingSlotInput, SlotAvailabilityUncheckedUpdateWithoutParkingSlotInput>
  }

  export type SlotAvailabilityUpdateManyWithWhereWithoutParkingSlotInput = {
    where: SlotAvailabilityScalarWhereInput
    data: XOR<SlotAvailabilityUpdateManyMutationInput, SlotAvailabilityUncheckedUpdateManyWithoutParkingSlotInput>
  }

  export type SlotAvailabilityScalarWhereInput = {
    AND?: SlotAvailabilityScalarWhereInput | SlotAvailabilityScalarWhereInput[]
    OR?: SlotAvailabilityScalarWhereInput[]
    NOT?: SlotAvailabilityScalarWhereInput | SlotAvailabilityScalarWhereInput[]
    id?: IntFilter<"SlotAvailability"> | number
    slotId?: IntFilter<"SlotAvailability"> | number
    availableFrom?: DateTimeFilter<"SlotAvailability"> | Date | string
    availableUntil?: DateTimeFilter<"SlotAvailability"> | Date | string
    isBookable?: BoolFilter<"SlotAvailability"> | boolean
    statusReason?: StringNullableFilter<"SlotAvailability"> | string | null
    createdAt?: DateTimeFilter<"SlotAvailability"> | Date | string
    updatedAt?: DateTimeNullableFilter<"SlotAvailability"> | Date | string | null
  }

  export type BookingUpsertWithWhereUniqueWithoutParkingSlotInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutParkingSlotInput, BookingUncheckedUpdateWithoutParkingSlotInput>
    create: XOR<BookingCreateWithoutParkingSlotInput, BookingUncheckedCreateWithoutParkingSlotInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutParkingSlotInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutParkingSlotInput, BookingUncheckedUpdateWithoutParkingSlotInput>
  }

  export type BookingUpdateManyWithWhereWithoutParkingSlotInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutParkingSlotInput>
  }

  export type ParkingSlotCreateWithoutSlotAvailabilityInput = {
    slotNumber: string
    slotType: string
    isReserved?: boolean
    isOccupied?: boolean
    isDisabledFriendly?: boolean
    hasEvCharger?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    parkingZone: ParkingZoneCreateNestedOneWithoutParkingSlotsInput
    bookings?: BookingCreateNestedManyWithoutParkingSlotInput
  }

  export type ParkingSlotUncheckedCreateWithoutSlotAvailabilityInput = {
    id?: number
    zoneId: number
    slotNumber: string
    slotType: string
    isReserved?: boolean
    isOccupied?: boolean
    isDisabledFriendly?: boolean
    hasEvCharger?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    bookings?: BookingUncheckedCreateNestedManyWithoutParkingSlotInput
  }

  export type ParkingSlotCreateOrConnectWithoutSlotAvailabilityInput = {
    where: ParkingSlotWhereUniqueInput
    create: XOR<ParkingSlotCreateWithoutSlotAvailabilityInput, ParkingSlotUncheckedCreateWithoutSlotAvailabilityInput>
  }

  export type ParkingSlotUpsertWithoutSlotAvailabilityInput = {
    update: XOR<ParkingSlotUpdateWithoutSlotAvailabilityInput, ParkingSlotUncheckedUpdateWithoutSlotAvailabilityInput>
    create: XOR<ParkingSlotCreateWithoutSlotAvailabilityInput, ParkingSlotUncheckedCreateWithoutSlotAvailabilityInput>
    where?: ParkingSlotWhereInput
  }

  export type ParkingSlotUpdateToOneWithWhereWithoutSlotAvailabilityInput = {
    where?: ParkingSlotWhereInput
    data: XOR<ParkingSlotUpdateWithoutSlotAvailabilityInput, ParkingSlotUncheckedUpdateWithoutSlotAvailabilityInput>
  }

  export type ParkingSlotUpdateWithoutSlotAvailabilityInput = {
    slotNumber?: StringFieldUpdateOperationsInput | string
    slotType?: StringFieldUpdateOperationsInput | string
    isReserved?: BoolFieldUpdateOperationsInput | boolean
    isOccupied?: BoolFieldUpdateOperationsInput | boolean
    isDisabledFriendly?: BoolFieldUpdateOperationsInput | boolean
    hasEvCharger?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parkingZone?: ParkingZoneUpdateOneRequiredWithoutParkingSlotsNestedInput
    bookings?: BookingUpdateManyWithoutParkingSlotNestedInput
  }

  export type ParkingSlotUncheckedUpdateWithoutSlotAvailabilityInput = {
    id?: IntFieldUpdateOperationsInput | number
    zoneId?: IntFieldUpdateOperationsInput | number
    slotNumber?: StringFieldUpdateOperationsInput | string
    slotType?: StringFieldUpdateOperationsInput | string
    isReserved?: BoolFieldUpdateOperationsInput | boolean
    isOccupied?: BoolFieldUpdateOperationsInput | boolean
    isDisabledFriendly?: BoolFieldUpdateOperationsInput | boolean
    hasEvCharger?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookings?: BookingUncheckedUpdateManyWithoutParkingSlotNestedInput
  }

  export type PlaceCreateWithoutTariffPlansInput = {
    name: string
    image?: string | null
    placeType: string
    address: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    contactNumber?: string | null
    email?: string | null
    description?: string | null
    totalCapacity: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    parkingZones?: ParkingZoneCreateNestedManyWithoutPlaceInput
    parkingPasses?: ParkingPassCreateNestedManyWithoutPlaceInput
    operatingHours?: OperatingHourCreateNestedManyWithoutPlaceInput
    placeAdmins?: PlaceAdminCreateNestedManyWithoutPlaceInput
    placeRatings?: PlaceRatingCreateNestedManyWithoutPlaceInput
  }

  export type PlaceUncheckedCreateWithoutTariffPlansInput = {
    id?: number
    name: string
    image?: string | null
    placeType: string
    address: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    contactNumber?: string | null
    email?: string | null
    description?: string | null
    totalCapacity: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    parkingZones?: ParkingZoneUncheckedCreateNestedManyWithoutPlaceInput
    parkingPasses?: ParkingPassUncheckedCreateNestedManyWithoutPlaceInput
    operatingHours?: OperatingHourUncheckedCreateNestedManyWithoutPlaceInput
    placeAdmins?: PlaceAdminUncheckedCreateNestedManyWithoutPlaceInput
    placeRatings?: PlaceRatingUncheckedCreateNestedManyWithoutPlaceInput
  }

  export type PlaceCreateOrConnectWithoutTariffPlansInput = {
    where: PlaceWhereUniqueInput
    create: XOR<PlaceCreateWithoutTariffPlansInput, PlaceUncheckedCreateWithoutTariffPlansInput>
  }

  export type TariffRateCreateWithoutTariffPlanInput = {
    vehicleType: string
    slotType: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    dayCategory?: string | null
    basePrice: Decimal | DecimalJsLike | number | string
    hourlyRate: Decimal | DecimalJsLike | number | string
    dayRate?: Decimal | DecimalJsLike | number | string | null
    minimumCharge?: Decimal | DecimalJsLike | number | string
    gracePeriodMinutes?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type TariffRateUncheckedCreateWithoutTariffPlanInput = {
    id?: number
    vehicleType: string
    slotType: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    dayCategory?: string | null
    basePrice: Decimal | DecimalJsLike | number | string
    hourlyRate: Decimal | DecimalJsLike | number | string
    dayRate?: Decimal | DecimalJsLike | number | string | null
    minimumCharge?: Decimal | DecimalJsLike | number | string
    gracePeriodMinutes?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type TariffRateCreateOrConnectWithoutTariffPlanInput = {
    where: TariffRateWhereUniqueInput
    create: XOR<TariffRateCreateWithoutTariffPlanInput, TariffRateUncheckedCreateWithoutTariffPlanInput>
  }

  export type TariffRateCreateManyTariffPlanInputEnvelope = {
    data: TariffRateCreateManyTariffPlanInput | TariffRateCreateManyTariffPlanInput[]
    skipDuplicates?: boolean
  }

  export type PlaceUpsertWithoutTariffPlansInput = {
    update: XOR<PlaceUpdateWithoutTariffPlansInput, PlaceUncheckedUpdateWithoutTariffPlansInput>
    create: XOR<PlaceCreateWithoutTariffPlansInput, PlaceUncheckedCreateWithoutTariffPlansInput>
    where?: PlaceWhereInput
  }

  export type PlaceUpdateToOneWithWhereWithoutTariffPlansInput = {
    where?: PlaceWhereInput
    data: XOR<PlaceUpdateWithoutTariffPlansInput, PlaceUncheckedUpdateWithoutTariffPlansInput>
  }

  export type PlaceUpdateWithoutTariffPlansInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    placeType?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalCapacity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parkingZones?: ParkingZoneUpdateManyWithoutPlaceNestedInput
    parkingPasses?: ParkingPassUpdateManyWithoutPlaceNestedInput
    operatingHours?: OperatingHourUpdateManyWithoutPlaceNestedInput
    placeAdmins?: PlaceAdminUpdateManyWithoutPlaceNestedInput
    placeRatings?: PlaceRatingUpdateManyWithoutPlaceNestedInput
  }

  export type PlaceUncheckedUpdateWithoutTariffPlansInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    placeType?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalCapacity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parkingZones?: ParkingZoneUncheckedUpdateManyWithoutPlaceNestedInput
    parkingPasses?: ParkingPassUncheckedUpdateManyWithoutPlaceNestedInput
    operatingHours?: OperatingHourUncheckedUpdateManyWithoutPlaceNestedInput
    placeAdmins?: PlaceAdminUncheckedUpdateManyWithoutPlaceNestedInput
    placeRatings?: PlaceRatingUncheckedUpdateManyWithoutPlaceNestedInput
  }

  export type TariffRateUpsertWithWhereUniqueWithoutTariffPlanInput = {
    where: TariffRateWhereUniqueInput
    update: XOR<TariffRateUpdateWithoutTariffPlanInput, TariffRateUncheckedUpdateWithoutTariffPlanInput>
    create: XOR<TariffRateCreateWithoutTariffPlanInput, TariffRateUncheckedCreateWithoutTariffPlanInput>
  }

  export type TariffRateUpdateWithWhereUniqueWithoutTariffPlanInput = {
    where: TariffRateWhereUniqueInput
    data: XOR<TariffRateUpdateWithoutTariffPlanInput, TariffRateUncheckedUpdateWithoutTariffPlanInput>
  }

  export type TariffRateUpdateManyWithWhereWithoutTariffPlanInput = {
    where: TariffRateScalarWhereInput
    data: XOR<TariffRateUpdateManyMutationInput, TariffRateUncheckedUpdateManyWithoutTariffPlanInput>
  }

  export type TariffRateScalarWhereInput = {
    AND?: TariffRateScalarWhereInput | TariffRateScalarWhereInput[]
    OR?: TariffRateScalarWhereInput[]
    NOT?: TariffRateScalarWhereInput | TariffRateScalarWhereInput[]
    id?: IntFilter<"TariffRate"> | number
    planId?: IntFilter<"TariffRate"> | number
    vehicleType?: StringFilter<"TariffRate"> | string
    slotType?: StringFilter<"TariffRate"> | string
    startTime?: DateTimeNullableFilter<"TariffRate"> | Date | string | null
    endTime?: DateTimeNullableFilter<"TariffRate"> | Date | string | null
    dayCategory?: StringNullableFilter<"TariffRate"> | string | null
    basePrice?: DecimalFilter<"TariffRate"> | Decimal | DecimalJsLike | number | string
    hourlyRate?: DecimalFilter<"TariffRate"> | Decimal | DecimalJsLike | number | string
    dayRate?: DecimalNullableFilter<"TariffRate"> | Decimal | DecimalJsLike | number | string | null
    minimumCharge?: DecimalFilter<"TariffRate"> | Decimal | DecimalJsLike | number | string
    gracePeriodMinutes?: IntFilter<"TariffRate"> | number
    createdAt?: DateTimeFilter<"TariffRate"> | Date | string
    updatedAt?: DateTimeNullableFilter<"TariffRate"> | Date | string | null
  }

  export type TariffPlanCreateWithoutTariffRatesInput = {
    planName: string
    description?: string | null
    effectiveFrom: Date | string
    effectiveUntil?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    place: PlaceCreateNestedOneWithoutTariffPlansInput
  }

  export type TariffPlanUncheckedCreateWithoutTariffRatesInput = {
    id?: number
    placeId: number
    planName: string
    description?: string | null
    effectiveFrom: Date | string
    effectiveUntil?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type TariffPlanCreateOrConnectWithoutTariffRatesInput = {
    where: TariffPlanWhereUniqueInput
    create: XOR<TariffPlanCreateWithoutTariffRatesInput, TariffPlanUncheckedCreateWithoutTariffRatesInput>
  }

  export type TariffPlanUpsertWithoutTariffRatesInput = {
    update: XOR<TariffPlanUpdateWithoutTariffRatesInput, TariffPlanUncheckedUpdateWithoutTariffRatesInput>
    create: XOR<TariffPlanCreateWithoutTariffRatesInput, TariffPlanUncheckedCreateWithoutTariffRatesInput>
    where?: TariffPlanWhereInput
  }

  export type TariffPlanUpdateToOneWithWhereWithoutTariffRatesInput = {
    where?: TariffPlanWhereInput
    data: XOR<TariffPlanUpdateWithoutTariffRatesInput, TariffPlanUncheckedUpdateWithoutTariffRatesInput>
  }

  export type TariffPlanUpdateWithoutTariffRatesInput = {
    planName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    place?: PlaceUpdateOneRequiredWithoutTariffPlansNestedInput
  }

  export type TariffPlanUncheckedUpdateWithoutTariffRatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    placeId?: IntFieldUpdateOperationsInput | number
    planName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateWithoutBookingsInput = {
    username: string
    email: string
    passwordHash: string
    phoneNumber?: string | null
    accountType: string
    emailVerified?: boolean
    phoneVerified?: boolean
    accountStatus?: string
    googleId?: string | null
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    vehicles?: VehicleCreateNestedManyWithoutUserInput
    userPaymentMethods?: UserPaymentMethodCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    parkingPasses?: ParkingPassCreateNestedManyWithoutUserInput
    placeRatings?: PlaceRatingCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    EmailVerificationToken?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    PhoneVerificationOtp?: PhoneVerificationOtpCreateNestedManyWithoutUserInput
    PasswordResetToken?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBookingsInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    phoneNumber?: string | null
    accountType: string
    emailVerified?: boolean
    phoneVerified?: boolean
    accountStatus?: string
    googleId?: string | null
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    vehicles?: VehicleUncheckedCreateNestedManyWithoutUserInput
    userPaymentMethods?: UserPaymentMethodUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    parkingPasses?: ParkingPassUncheckedCreateNestedManyWithoutUserInput
    placeRatings?: PlaceRatingUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    EmailVerificationToken?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    PhoneVerificationOtp?: PhoneVerificationOtpUncheckedCreateNestedManyWithoutUserInput
    PasswordResetToken?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBookingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
  }

  export type VehicleCreateWithoutBookingsInput = {
    licensePlate: string
    vehicleType: string
    brand?: string | null
    model?: string | null
    color?: string | null
    rfidTag?: string | null
    length?: Decimal | DecimalJsLike | number | string | null
    width?: Decimal | DecimalJsLike | number | string | null
    height?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutVehiclesInput
  }

  export type VehicleUncheckedCreateWithoutBookingsInput = {
    id?: number
    userId: number
    licensePlate: string
    vehicleType: string
    brand?: string | null
    model?: string | null
    color?: string | null
    rfidTag?: string | null
    length?: Decimal | DecimalJsLike | number | string | null
    width?: Decimal | DecimalJsLike | number | string | null
    height?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type VehicleCreateOrConnectWithoutBookingsInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutBookingsInput, VehicleUncheckedCreateWithoutBookingsInput>
  }

  export type ParkingSlotCreateWithoutBookingsInput = {
    slotNumber: string
    slotType: string
    isReserved?: boolean
    isOccupied?: boolean
    isDisabledFriendly?: boolean
    hasEvCharger?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    parkingZone: ParkingZoneCreateNestedOneWithoutParkingSlotsInput
    slotAvailability?: SlotAvailabilityCreateNestedManyWithoutParkingSlotInput
  }

  export type ParkingSlotUncheckedCreateWithoutBookingsInput = {
    id?: number
    zoneId: number
    slotNumber: string
    slotType: string
    isReserved?: boolean
    isOccupied?: boolean
    isDisabledFriendly?: boolean
    hasEvCharger?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    slotAvailability?: SlotAvailabilityUncheckedCreateNestedManyWithoutParkingSlotInput
  }

  export type ParkingSlotCreateOrConnectWithoutBookingsInput = {
    where: ParkingSlotWhereUniqueInput
    create: XOR<ParkingSlotCreateWithoutBookingsInput, ParkingSlotUncheckedCreateWithoutBookingsInput>
  }

  export type PromoCodeCreateWithoutBookingsInput = {
    code: string
    description?: string | null
    discountType: string
    discountValue: Decimal | DecimalJsLike | number | string
    minimumSpend?: Decimal | DecimalJsLike | number | string
    validFrom: Date | string
    validUntil?: Date | string | null
    usageLimit?: number | null
    usageCount?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type PromoCodeUncheckedCreateWithoutBookingsInput = {
    id?: number
    code: string
    description?: string | null
    discountType: string
    discountValue: Decimal | DecimalJsLike | number | string
    minimumSpend?: Decimal | DecimalJsLike | number | string
    validFrom: Date | string
    validUntil?: Date | string | null
    usageLimit?: number | null
    usageCount?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type PromoCodeCreateOrConnectWithoutBookingsInput = {
    where: PromoCodeWhereUniqueInput
    create: XOR<PromoCodeCreateWithoutBookingsInput, PromoCodeUncheckedCreateWithoutBookingsInput>
  }

  export type BookingStatusLogCreateWithoutBookingInput = {
    previousStatus: string
    newStatus: string
    changedBy: string
    reason?: string | null
    statusTime?: Date | string
    createdAt?: Date | string
  }

  export type BookingStatusLogUncheckedCreateWithoutBookingInput = {
    id?: number
    previousStatus: string
    newStatus: string
    changedBy: string
    reason?: string | null
    statusTime?: Date | string
    createdAt?: Date | string
  }

  export type BookingStatusLogCreateOrConnectWithoutBookingInput = {
    where: BookingStatusLogWhereUniqueInput
    create: XOR<BookingStatusLogCreateWithoutBookingInput, BookingStatusLogUncheckedCreateWithoutBookingInput>
  }

  export type BookingStatusLogCreateManyBookingInputEnvelope = {
    data: BookingStatusLogCreateManyBookingInput | BookingStatusLogCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type BookingPaymentCreateWithoutBookingInput = {
    paymentReference?: string | null
    paymentStatus: string
    originalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    surchargeAmount?: Decimal | DecimalJsLike | number | string
    finalAmount: Decimal | DecimalJsLike | number | string
    isPrepaid?: boolean
    isRefunded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    paymentTransactions?: PaymentTransactionCreateNestedManyWithoutBookingPaymentInput
    refundTransactions?: RefundTransactionCreateNestedManyWithoutBookingPaymentInput
  }

  export type BookingPaymentUncheckedCreateWithoutBookingInput = {
    id?: number
    paymentReference?: string | null
    paymentStatus: string
    originalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    surchargeAmount?: Decimal | DecimalJsLike | number | string
    finalAmount: Decimal | DecimalJsLike | number | string
    isPrepaid?: boolean
    isRefunded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    paymentTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutBookingPaymentInput
    refundTransactions?: RefundTransactionUncheckedCreateNestedManyWithoutBookingPaymentInput
  }

  export type BookingPaymentCreateOrConnectWithoutBookingInput = {
    where: BookingPaymentWhereUniqueInput
    create: XOR<BookingPaymentCreateWithoutBookingInput, BookingPaymentUncheckedCreateWithoutBookingInput>
  }

  export type AccessLogCreateWithoutBookingInput = {
    logType: string
    logTime?: Date | string
    verificationMethod?: string | null
    verifiedBy?: string | null
    location?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type AccessLogUncheckedCreateWithoutBookingInput = {
    id?: number
    logType: string
    logTime?: Date | string
    verificationMethod?: string | null
    verifiedBy?: string | null
    location?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type AccessLogCreateOrConnectWithoutBookingInput = {
    where: AccessLogWhereUniqueInput
    create: XOR<AccessLogCreateWithoutBookingInput, AccessLogUncheckedCreateWithoutBookingInput>
  }

  export type AccessLogCreateManyBookingInputEnvelope = {
    data: AccessLogCreateManyBookingInput | AccessLogCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type BookingExtensionCreateWithoutBookingInput = {
    originalEndTime: Date | string
    newEndTime: Date | string
    additionalCharge: Decimal | DecimalJsLike | number | string
    paymentStatus: string
    requestTime?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type BookingExtensionUncheckedCreateWithoutBookingInput = {
    id?: number
    originalEndTime: Date | string
    newEndTime: Date | string
    additionalCharge: Decimal | DecimalJsLike | number | string
    paymentStatus: string
    requestTime?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type BookingExtensionCreateOrConnectWithoutBookingInput = {
    where: BookingExtensionWhereUniqueInput
    create: XOR<BookingExtensionCreateWithoutBookingInput, BookingExtensionUncheckedCreateWithoutBookingInput>
  }

  export type BookingExtensionCreateManyBookingInputEnvelope = {
    data: BookingExtensionCreateManyBookingInput | BookingExtensionCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type PlaceRatingCreateWithoutBookingInput = {
    ratingScore: Decimal | DecimalJsLike | number | string
    reviewComment?: string | null
    ratingDate?: Date | string
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    place: PlaceCreateNestedOneWithoutPlaceRatingsInput
    user: UserCreateNestedOneWithoutPlaceRatingsInput
  }

  export type PlaceRatingUncheckedCreateWithoutBookingInput = {
    id?: number
    placeId: number
    userId: number
    ratingScore: Decimal | DecimalJsLike | number | string
    reviewComment?: string | null
    ratingDate?: Date | string
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type PlaceRatingCreateOrConnectWithoutBookingInput = {
    where: PlaceRatingWhereUniqueInput
    create: XOR<PlaceRatingCreateWithoutBookingInput, PlaceRatingUncheckedCreateWithoutBookingInput>
  }

  export type PlaceRatingCreateManyBookingInputEnvelope = {
    data: PlaceRatingCreateManyBookingInput | PlaceRatingCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutBookingInput = {
    notificationType: string
    channel: string
    content: string
    isRead?: boolean
    sentTime?: Date | string
    readTime?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutBookingInput = {
    id?: number
    userId: number
    notificationType: string
    channel: string
    content: string
    isRead?: boolean
    sentTime?: Date | string
    readTime?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutBookingInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutBookingInput, NotificationUncheckedCreateWithoutBookingInput>
  }

  export type NotificationCreateManyBookingInputEnvelope = {
    data: NotificationCreateManyBookingInput | NotificationCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutBookingsInput = {
    update: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBookingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type UserUpdateWithoutBookingsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    accountStatus?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    vehicles?: VehicleUpdateManyWithoutUserNestedInput
    userPaymentMethods?: UserPaymentMethodUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    parkingPasses?: ParkingPassUpdateManyWithoutUserNestedInput
    placeRatings?: PlaceRatingUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    EmailVerificationToken?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    PhoneVerificationOtp?: PhoneVerificationOtpUpdateManyWithoutUserNestedInput
    PasswordResetToken?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    accountStatus?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    vehicles?: VehicleUncheckedUpdateManyWithoutUserNestedInput
    userPaymentMethods?: UserPaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    parkingPasses?: ParkingPassUncheckedUpdateManyWithoutUserNestedInput
    placeRatings?: PlaceRatingUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    EmailVerificationToken?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    PhoneVerificationOtp?: PhoneVerificationOtpUncheckedUpdateManyWithoutUserNestedInput
    PasswordResetToken?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VehicleUpsertWithoutBookingsInput = {
    update: XOR<VehicleUpdateWithoutBookingsInput, VehicleUncheckedUpdateWithoutBookingsInput>
    create: XOR<VehicleCreateWithoutBookingsInput, VehicleUncheckedCreateWithoutBookingsInput>
    where?: VehicleWhereInput
  }

  export type VehicleUpdateToOneWithWhereWithoutBookingsInput = {
    where?: VehicleWhereInput
    data: XOR<VehicleUpdateWithoutBookingsInput, VehicleUncheckedUpdateWithoutBookingsInput>
  }

  export type VehicleUpdateWithoutBookingsInput = {
    licensePlate?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    rfidTag?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    width?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutVehiclesNestedInput
  }

  export type VehicleUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    licensePlate?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    rfidTag?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    width?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ParkingSlotUpsertWithoutBookingsInput = {
    update: XOR<ParkingSlotUpdateWithoutBookingsInput, ParkingSlotUncheckedUpdateWithoutBookingsInput>
    create: XOR<ParkingSlotCreateWithoutBookingsInput, ParkingSlotUncheckedCreateWithoutBookingsInput>
    where?: ParkingSlotWhereInput
  }

  export type ParkingSlotUpdateToOneWithWhereWithoutBookingsInput = {
    where?: ParkingSlotWhereInput
    data: XOR<ParkingSlotUpdateWithoutBookingsInput, ParkingSlotUncheckedUpdateWithoutBookingsInput>
  }

  export type ParkingSlotUpdateWithoutBookingsInput = {
    slotNumber?: StringFieldUpdateOperationsInput | string
    slotType?: StringFieldUpdateOperationsInput | string
    isReserved?: BoolFieldUpdateOperationsInput | boolean
    isOccupied?: BoolFieldUpdateOperationsInput | boolean
    isDisabledFriendly?: BoolFieldUpdateOperationsInput | boolean
    hasEvCharger?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parkingZone?: ParkingZoneUpdateOneRequiredWithoutParkingSlotsNestedInput
    slotAvailability?: SlotAvailabilityUpdateManyWithoutParkingSlotNestedInput
  }

  export type ParkingSlotUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    zoneId?: IntFieldUpdateOperationsInput | number
    slotNumber?: StringFieldUpdateOperationsInput | string
    slotType?: StringFieldUpdateOperationsInput | string
    isReserved?: BoolFieldUpdateOperationsInput | boolean
    isOccupied?: BoolFieldUpdateOperationsInput | boolean
    isDisabledFriendly?: BoolFieldUpdateOperationsInput | boolean
    hasEvCharger?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slotAvailability?: SlotAvailabilityUncheckedUpdateManyWithoutParkingSlotNestedInput
  }

  export type PromoCodeUpsertWithoutBookingsInput = {
    update: XOR<PromoCodeUpdateWithoutBookingsInput, PromoCodeUncheckedUpdateWithoutBookingsInput>
    create: XOR<PromoCodeCreateWithoutBookingsInput, PromoCodeUncheckedCreateWithoutBookingsInput>
    where?: PromoCodeWhereInput
  }

  export type PromoCodeUpdateToOneWithWhereWithoutBookingsInput = {
    where?: PromoCodeWhereInput
    data: XOR<PromoCodeUpdateWithoutBookingsInput, PromoCodeUncheckedUpdateWithoutBookingsInput>
  }

  export type PromoCodeUpdateWithoutBookingsInput = {
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minimumSpend?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PromoCodeUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minimumSpend?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BookingStatusLogUpsertWithWhereUniqueWithoutBookingInput = {
    where: BookingStatusLogWhereUniqueInput
    update: XOR<BookingStatusLogUpdateWithoutBookingInput, BookingStatusLogUncheckedUpdateWithoutBookingInput>
    create: XOR<BookingStatusLogCreateWithoutBookingInput, BookingStatusLogUncheckedCreateWithoutBookingInput>
  }

  export type BookingStatusLogUpdateWithWhereUniqueWithoutBookingInput = {
    where: BookingStatusLogWhereUniqueInput
    data: XOR<BookingStatusLogUpdateWithoutBookingInput, BookingStatusLogUncheckedUpdateWithoutBookingInput>
  }

  export type BookingStatusLogUpdateManyWithWhereWithoutBookingInput = {
    where: BookingStatusLogScalarWhereInput
    data: XOR<BookingStatusLogUpdateManyMutationInput, BookingStatusLogUncheckedUpdateManyWithoutBookingInput>
  }

  export type BookingStatusLogScalarWhereInput = {
    AND?: BookingStatusLogScalarWhereInput | BookingStatusLogScalarWhereInput[]
    OR?: BookingStatusLogScalarWhereInput[]
    NOT?: BookingStatusLogScalarWhereInput | BookingStatusLogScalarWhereInput[]
    id?: IntFilter<"BookingStatusLog"> | number
    bookingId?: IntFilter<"BookingStatusLog"> | number
    previousStatus?: StringFilter<"BookingStatusLog"> | string
    newStatus?: StringFilter<"BookingStatusLog"> | string
    changedBy?: StringFilter<"BookingStatusLog"> | string
    reason?: StringNullableFilter<"BookingStatusLog"> | string | null
    statusTime?: DateTimeFilter<"BookingStatusLog"> | Date | string
    createdAt?: DateTimeFilter<"BookingStatusLog"> | Date | string
  }

  export type BookingPaymentUpsertWithoutBookingInput = {
    update: XOR<BookingPaymentUpdateWithoutBookingInput, BookingPaymentUncheckedUpdateWithoutBookingInput>
    create: XOR<BookingPaymentCreateWithoutBookingInput, BookingPaymentUncheckedCreateWithoutBookingInput>
    where?: BookingPaymentWhereInput
  }

  export type BookingPaymentUpdateToOneWithWhereWithoutBookingInput = {
    where?: BookingPaymentWhereInput
    data: XOR<BookingPaymentUpdateWithoutBookingInput, BookingPaymentUncheckedUpdateWithoutBookingInput>
  }

  export type BookingPaymentUpdateWithoutBookingInput = {
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    originalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    surchargeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPrepaid?: BoolFieldUpdateOperationsInput | boolean
    isRefunded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentTransactions?: PaymentTransactionUpdateManyWithoutBookingPaymentNestedInput
    refundTransactions?: RefundTransactionUpdateManyWithoutBookingPaymentNestedInput
  }

  export type BookingPaymentUncheckedUpdateWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    originalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    surchargeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPrepaid?: BoolFieldUpdateOperationsInput | boolean
    isRefunded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentTransactions?: PaymentTransactionUncheckedUpdateManyWithoutBookingPaymentNestedInput
    refundTransactions?: RefundTransactionUncheckedUpdateManyWithoutBookingPaymentNestedInput
  }

  export type AccessLogUpsertWithWhereUniqueWithoutBookingInput = {
    where: AccessLogWhereUniqueInput
    update: XOR<AccessLogUpdateWithoutBookingInput, AccessLogUncheckedUpdateWithoutBookingInput>
    create: XOR<AccessLogCreateWithoutBookingInput, AccessLogUncheckedCreateWithoutBookingInput>
  }

  export type AccessLogUpdateWithWhereUniqueWithoutBookingInput = {
    where: AccessLogWhereUniqueInput
    data: XOR<AccessLogUpdateWithoutBookingInput, AccessLogUncheckedUpdateWithoutBookingInput>
  }

  export type AccessLogUpdateManyWithWhereWithoutBookingInput = {
    where: AccessLogScalarWhereInput
    data: XOR<AccessLogUpdateManyMutationInput, AccessLogUncheckedUpdateManyWithoutBookingInput>
  }

  export type AccessLogScalarWhereInput = {
    AND?: AccessLogScalarWhereInput | AccessLogScalarWhereInput[]
    OR?: AccessLogScalarWhereInput[]
    NOT?: AccessLogScalarWhereInput | AccessLogScalarWhereInput[]
    id?: IntFilter<"AccessLog"> | number
    bookingId?: IntFilter<"AccessLog"> | number
    logType?: StringFilter<"AccessLog"> | string
    logTime?: DateTimeFilter<"AccessLog"> | Date | string
    verificationMethod?: StringNullableFilter<"AccessLog"> | string | null
    verifiedBy?: StringNullableFilter<"AccessLog"> | string | null
    location?: StringNullableFilter<"AccessLog"> | string | null
    notes?: StringNullableFilter<"AccessLog"> | string | null
    createdAt?: DateTimeFilter<"AccessLog"> | Date | string
  }

  export type BookingExtensionUpsertWithWhereUniqueWithoutBookingInput = {
    where: BookingExtensionWhereUniqueInput
    update: XOR<BookingExtensionUpdateWithoutBookingInput, BookingExtensionUncheckedUpdateWithoutBookingInput>
    create: XOR<BookingExtensionCreateWithoutBookingInput, BookingExtensionUncheckedCreateWithoutBookingInput>
  }

  export type BookingExtensionUpdateWithWhereUniqueWithoutBookingInput = {
    where: BookingExtensionWhereUniqueInput
    data: XOR<BookingExtensionUpdateWithoutBookingInput, BookingExtensionUncheckedUpdateWithoutBookingInput>
  }

  export type BookingExtensionUpdateManyWithWhereWithoutBookingInput = {
    where: BookingExtensionScalarWhereInput
    data: XOR<BookingExtensionUpdateManyMutationInput, BookingExtensionUncheckedUpdateManyWithoutBookingInput>
  }

  export type BookingExtensionScalarWhereInput = {
    AND?: BookingExtensionScalarWhereInput | BookingExtensionScalarWhereInput[]
    OR?: BookingExtensionScalarWhereInput[]
    NOT?: BookingExtensionScalarWhereInput | BookingExtensionScalarWhereInput[]
    id?: IntFilter<"BookingExtension"> | number
    bookingId?: IntFilter<"BookingExtension"> | number
    originalEndTime?: DateTimeFilter<"BookingExtension"> | Date | string
    newEndTime?: DateTimeFilter<"BookingExtension"> | Date | string
    additionalCharge?: DecimalFilter<"BookingExtension"> | Decimal | DecimalJsLike | number | string
    paymentStatus?: StringFilter<"BookingExtension"> | string
    requestTime?: DateTimeFilter<"BookingExtension"> | Date | string
    createdAt?: DateTimeFilter<"BookingExtension"> | Date | string
    updatedAt?: DateTimeNullableFilter<"BookingExtension"> | Date | string | null
  }

  export type PlaceRatingUpsertWithWhereUniqueWithoutBookingInput = {
    where: PlaceRatingWhereUniqueInput
    update: XOR<PlaceRatingUpdateWithoutBookingInput, PlaceRatingUncheckedUpdateWithoutBookingInput>
    create: XOR<PlaceRatingCreateWithoutBookingInput, PlaceRatingUncheckedCreateWithoutBookingInput>
  }

  export type PlaceRatingUpdateWithWhereUniqueWithoutBookingInput = {
    where: PlaceRatingWhereUniqueInput
    data: XOR<PlaceRatingUpdateWithoutBookingInput, PlaceRatingUncheckedUpdateWithoutBookingInput>
  }

  export type PlaceRatingUpdateManyWithWhereWithoutBookingInput = {
    where: PlaceRatingScalarWhereInput
    data: XOR<PlaceRatingUpdateManyMutationInput, PlaceRatingUncheckedUpdateManyWithoutBookingInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutBookingInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutBookingInput, NotificationUncheckedUpdateWithoutBookingInput>
    create: XOR<NotificationCreateWithoutBookingInput, NotificationUncheckedCreateWithoutBookingInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutBookingInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutBookingInput, NotificationUncheckedUpdateWithoutBookingInput>
  }

  export type NotificationUpdateManyWithWhereWithoutBookingInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutBookingInput>
  }

  export type BookingCreateWithoutBookingStatusLogsInput = {
    bookingReference: string
    bookingTime?: Date | string
    scheduledEntry: Date | string
    scheduledExit: Date | string
    actualEntry?: Date | string | null
    actualExit?: Date | string | null
    qrCode?: string | null
    bookingStatus: string
    estimatedPrice: Decimal | DecimalJsLike | number | string
    finalPrice?: Decimal | DecimalJsLike | number | string | null
    cancellationReason?: string | null
    cancellationTimeMinutes?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutBookingsInput
    vehicle: VehicleCreateNestedOneWithoutBookingsInput
    parkingSlot: ParkingSlotCreateNestedOneWithoutBookingsInput
    promoCode?: PromoCodeCreateNestedOneWithoutBookingsInput
    bookingPayment?: BookingPaymentCreateNestedOneWithoutBookingInput
    accessLogs?: AccessLogCreateNestedManyWithoutBookingInput
    bookingExtensions?: BookingExtensionCreateNestedManyWithoutBookingInput
    placeRatings?: PlaceRatingCreateNestedManyWithoutBookingInput
    notifications?: NotificationCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutBookingStatusLogsInput = {
    id?: number
    userId: number
    vehicleId: number
    slotId: number
    promoCodeId?: number | null
    bookingReference: string
    bookingTime?: Date | string
    scheduledEntry: Date | string
    scheduledExit: Date | string
    actualEntry?: Date | string | null
    actualExit?: Date | string | null
    qrCode?: string | null
    bookingStatus: string
    estimatedPrice: Decimal | DecimalJsLike | number | string
    finalPrice?: Decimal | DecimalJsLike | number | string | null
    cancellationReason?: string | null
    cancellationTimeMinutes?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    bookingPayment?: BookingPaymentUncheckedCreateNestedOneWithoutBookingInput
    accessLogs?: AccessLogUncheckedCreateNestedManyWithoutBookingInput
    bookingExtensions?: BookingExtensionUncheckedCreateNestedManyWithoutBookingInput
    placeRatings?: PlaceRatingUncheckedCreateNestedManyWithoutBookingInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutBookingStatusLogsInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutBookingStatusLogsInput, BookingUncheckedCreateWithoutBookingStatusLogsInput>
  }

  export type BookingUpsertWithoutBookingStatusLogsInput = {
    update: XOR<BookingUpdateWithoutBookingStatusLogsInput, BookingUncheckedUpdateWithoutBookingStatusLogsInput>
    create: XOR<BookingCreateWithoutBookingStatusLogsInput, BookingUncheckedCreateWithoutBookingStatusLogsInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutBookingStatusLogsInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutBookingStatusLogsInput, BookingUncheckedUpdateWithoutBookingStatusLogsInput>
  }

  export type BookingUpdateWithoutBookingStatusLogsInput = {
    bookingReference?: StringFieldUpdateOperationsInput | string
    bookingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledExit?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualExit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    bookingStatus?: StringFieldUpdateOperationsInput | string
    estimatedPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutBookingsNestedInput
    parkingSlot?: ParkingSlotUpdateOneRequiredWithoutBookingsNestedInput
    promoCode?: PromoCodeUpdateOneWithoutBookingsNestedInput
    bookingPayment?: BookingPaymentUpdateOneWithoutBookingNestedInput
    accessLogs?: AccessLogUpdateManyWithoutBookingNestedInput
    bookingExtensions?: BookingExtensionUpdateManyWithoutBookingNestedInput
    placeRatings?: PlaceRatingUpdateManyWithoutBookingNestedInput
    notifications?: NotificationUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutBookingStatusLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    slotId?: IntFieldUpdateOperationsInput | number
    promoCodeId?: NullableIntFieldUpdateOperationsInput | number | null
    bookingReference?: StringFieldUpdateOperationsInput | string
    bookingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledExit?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualExit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    bookingStatus?: StringFieldUpdateOperationsInput | string
    estimatedPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookingPayment?: BookingPaymentUncheckedUpdateOneWithoutBookingNestedInput
    accessLogs?: AccessLogUncheckedUpdateManyWithoutBookingNestedInput
    bookingExtensions?: BookingExtensionUncheckedUpdateManyWithoutBookingNestedInput
    placeRatings?: PlaceRatingUncheckedUpdateManyWithoutBookingNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingCreateWithoutBookingPaymentInput = {
    bookingReference: string
    bookingTime?: Date | string
    scheduledEntry: Date | string
    scheduledExit: Date | string
    actualEntry?: Date | string | null
    actualExit?: Date | string | null
    qrCode?: string | null
    bookingStatus: string
    estimatedPrice: Decimal | DecimalJsLike | number | string
    finalPrice?: Decimal | DecimalJsLike | number | string | null
    cancellationReason?: string | null
    cancellationTimeMinutes?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutBookingsInput
    vehicle: VehicleCreateNestedOneWithoutBookingsInput
    parkingSlot: ParkingSlotCreateNestedOneWithoutBookingsInput
    promoCode?: PromoCodeCreateNestedOneWithoutBookingsInput
    bookingStatusLogs?: BookingStatusLogCreateNestedManyWithoutBookingInput
    accessLogs?: AccessLogCreateNestedManyWithoutBookingInput
    bookingExtensions?: BookingExtensionCreateNestedManyWithoutBookingInput
    placeRatings?: PlaceRatingCreateNestedManyWithoutBookingInput
    notifications?: NotificationCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutBookingPaymentInput = {
    id?: number
    userId: number
    vehicleId: number
    slotId: number
    promoCodeId?: number | null
    bookingReference: string
    bookingTime?: Date | string
    scheduledEntry: Date | string
    scheduledExit: Date | string
    actualEntry?: Date | string | null
    actualExit?: Date | string | null
    qrCode?: string | null
    bookingStatus: string
    estimatedPrice: Decimal | DecimalJsLike | number | string
    finalPrice?: Decimal | DecimalJsLike | number | string | null
    cancellationReason?: string | null
    cancellationTimeMinutes?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    bookingStatusLogs?: BookingStatusLogUncheckedCreateNestedManyWithoutBookingInput
    accessLogs?: AccessLogUncheckedCreateNestedManyWithoutBookingInput
    bookingExtensions?: BookingExtensionUncheckedCreateNestedManyWithoutBookingInput
    placeRatings?: PlaceRatingUncheckedCreateNestedManyWithoutBookingInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutBookingPaymentInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutBookingPaymentInput, BookingUncheckedCreateWithoutBookingPaymentInput>
  }

  export type PaymentTransactionCreateWithoutBookingPaymentInput = {
    transactionReference?: string | null
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    transactionStatus: string
    gatewayResponse?: string | null
    transactionData?: string | null
    transactionTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    paymentMethod: PaymentMethodCreateNestedOneWithoutPaymentTransactionsInput
  }

  export type PaymentTransactionUncheckedCreateWithoutBookingPaymentInput = {
    id?: number
    paymentMethodId: number
    transactionReference?: string | null
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    transactionStatus: string
    gatewayResponse?: string | null
    transactionData?: string | null
    transactionTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type PaymentTransactionCreateOrConnectWithoutBookingPaymentInput = {
    where: PaymentTransactionWhereUniqueInput
    create: XOR<PaymentTransactionCreateWithoutBookingPaymentInput, PaymentTransactionUncheckedCreateWithoutBookingPaymentInput>
  }

  export type PaymentTransactionCreateManyBookingPaymentInputEnvelope = {
    data: PaymentTransactionCreateManyBookingPaymentInput | PaymentTransactionCreateManyBookingPaymentInput[]
    skipDuplicates?: boolean
  }

  export type RefundTransactionCreateWithoutBookingPaymentInput = {
    refundReference?: string | null
    refundAmount: Decimal | DecimalJsLike | number | string
    refundReason?: string | null
    refundStatus: string
    processorResponse?: string | null
    refundData?: string | null
    refundTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type RefundTransactionUncheckedCreateWithoutBookingPaymentInput = {
    id?: number
    refundReference?: string | null
    refundAmount: Decimal | DecimalJsLike | number | string
    refundReason?: string | null
    refundStatus: string
    processorResponse?: string | null
    refundData?: string | null
    refundTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type RefundTransactionCreateOrConnectWithoutBookingPaymentInput = {
    where: RefundTransactionWhereUniqueInput
    create: XOR<RefundTransactionCreateWithoutBookingPaymentInput, RefundTransactionUncheckedCreateWithoutBookingPaymentInput>
  }

  export type RefundTransactionCreateManyBookingPaymentInputEnvelope = {
    data: RefundTransactionCreateManyBookingPaymentInput | RefundTransactionCreateManyBookingPaymentInput[]
    skipDuplicates?: boolean
  }

  export type BookingUpsertWithoutBookingPaymentInput = {
    update: XOR<BookingUpdateWithoutBookingPaymentInput, BookingUncheckedUpdateWithoutBookingPaymentInput>
    create: XOR<BookingCreateWithoutBookingPaymentInput, BookingUncheckedCreateWithoutBookingPaymentInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutBookingPaymentInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutBookingPaymentInput, BookingUncheckedUpdateWithoutBookingPaymentInput>
  }

  export type BookingUpdateWithoutBookingPaymentInput = {
    bookingReference?: StringFieldUpdateOperationsInput | string
    bookingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledExit?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualExit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    bookingStatus?: StringFieldUpdateOperationsInput | string
    estimatedPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutBookingsNestedInput
    parkingSlot?: ParkingSlotUpdateOneRequiredWithoutBookingsNestedInput
    promoCode?: PromoCodeUpdateOneWithoutBookingsNestedInput
    bookingStatusLogs?: BookingStatusLogUpdateManyWithoutBookingNestedInput
    accessLogs?: AccessLogUpdateManyWithoutBookingNestedInput
    bookingExtensions?: BookingExtensionUpdateManyWithoutBookingNestedInput
    placeRatings?: PlaceRatingUpdateManyWithoutBookingNestedInput
    notifications?: NotificationUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutBookingPaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    slotId?: IntFieldUpdateOperationsInput | number
    promoCodeId?: NullableIntFieldUpdateOperationsInput | number | null
    bookingReference?: StringFieldUpdateOperationsInput | string
    bookingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledExit?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualExit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    bookingStatus?: StringFieldUpdateOperationsInput | string
    estimatedPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookingStatusLogs?: BookingStatusLogUncheckedUpdateManyWithoutBookingNestedInput
    accessLogs?: AccessLogUncheckedUpdateManyWithoutBookingNestedInput
    bookingExtensions?: BookingExtensionUncheckedUpdateManyWithoutBookingNestedInput
    placeRatings?: PlaceRatingUncheckedUpdateManyWithoutBookingNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type PaymentTransactionUpsertWithWhereUniqueWithoutBookingPaymentInput = {
    where: PaymentTransactionWhereUniqueInput
    update: XOR<PaymentTransactionUpdateWithoutBookingPaymentInput, PaymentTransactionUncheckedUpdateWithoutBookingPaymentInput>
    create: XOR<PaymentTransactionCreateWithoutBookingPaymentInput, PaymentTransactionUncheckedCreateWithoutBookingPaymentInput>
  }

  export type PaymentTransactionUpdateWithWhereUniqueWithoutBookingPaymentInput = {
    where: PaymentTransactionWhereUniqueInput
    data: XOR<PaymentTransactionUpdateWithoutBookingPaymentInput, PaymentTransactionUncheckedUpdateWithoutBookingPaymentInput>
  }

  export type PaymentTransactionUpdateManyWithWhereWithoutBookingPaymentInput = {
    where: PaymentTransactionScalarWhereInput
    data: XOR<PaymentTransactionUpdateManyMutationInput, PaymentTransactionUncheckedUpdateManyWithoutBookingPaymentInput>
  }

  export type PaymentTransactionScalarWhereInput = {
    AND?: PaymentTransactionScalarWhereInput | PaymentTransactionScalarWhereInput[]
    OR?: PaymentTransactionScalarWhereInput[]
    NOT?: PaymentTransactionScalarWhereInput | PaymentTransactionScalarWhereInput[]
    id?: IntFilter<"PaymentTransaction"> | number
    paymentId?: IntFilter<"PaymentTransaction"> | number
    paymentMethodId?: IntFilter<"PaymentTransaction"> | number
    transactionReference?: StringNullableFilter<"PaymentTransaction"> | string | null
    transactionType?: StringFilter<"PaymentTransaction"> | string
    amount?: DecimalFilter<"PaymentTransaction"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"PaymentTransaction"> | string
    transactionStatus?: StringFilter<"PaymentTransaction"> | string
    gatewayResponse?: StringNullableFilter<"PaymentTransaction"> | string | null
    transactionData?: StringNullableFilter<"PaymentTransaction"> | string | null
    transactionTime?: DateTimeNullableFilter<"PaymentTransaction"> | Date | string | null
    createdAt?: DateTimeFilter<"PaymentTransaction"> | Date | string
    updatedAt?: DateTimeNullableFilter<"PaymentTransaction"> | Date | string | null
  }

  export type RefundTransactionUpsertWithWhereUniqueWithoutBookingPaymentInput = {
    where: RefundTransactionWhereUniqueInput
    update: XOR<RefundTransactionUpdateWithoutBookingPaymentInput, RefundTransactionUncheckedUpdateWithoutBookingPaymentInput>
    create: XOR<RefundTransactionCreateWithoutBookingPaymentInput, RefundTransactionUncheckedCreateWithoutBookingPaymentInput>
  }

  export type RefundTransactionUpdateWithWhereUniqueWithoutBookingPaymentInput = {
    where: RefundTransactionWhereUniqueInput
    data: XOR<RefundTransactionUpdateWithoutBookingPaymentInput, RefundTransactionUncheckedUpdateWithoutBookingPaymentInput>
  }

  export type RefundTransactionUpdateManyWithWhereWithoutBookingPaymentInput = {
    where: RefundTransactionScalarWhereInput
    data: XOR<RefundTransactionUpdateManyMutationInput, RefundTransactionUncheckedUpdateManyWithoutBookingPaymentInput>
  }

  export type RefundTransactionScalarWhereInput = {
    AND?: RefundTransactionScalarWhereInput | RefundTransactionScalarWhereInput[]
    OR?: RefundTransactionScalarWhereInput[]
    NOT?: RefundTransactionScalarWhereInput | RefundTransactionScalarWhereInput[]
    id?: IntFilter<"RefundTransaction"> | number
    paymentId?: IntFilter<"RefundTransaction"> | number
    refundReference?: StringNullableFilter<"RefundTransaction"> | string | null
    refundAmount?: DecimalFilter<"RefundTransaction"> | Decimal | DecimalJsLike | number | string
    refundReason?: StringNullableFilter<"RefundTransaction"> | string | null
    refundStatus?: StringFilter<"RefundTransaction"> | string
    processorResponse?: StringNullableFilter<"RefundTransaction"> | string | null
    refundData?: StringNullableFilter<"RefundTransaction"> | string | null
    refundTime?: DateTimeNullableFilter<"RefundTransaction"> | Date | string | null
    createdAt?: DateTimeFilter<"RefundTransaction"> | Date | string
    updatedAt?: DateTimeNullableFilter<"RefundTransaction"> | Date | string | null
  }

  export type BookingPaymentCreateWithoutPaymentTransactionsInput = {
    paymentReference?: string | null
    paymentStatus: string
    originalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    surchargeAmount?: Decimal | DecimalJsLike | number | string
    finalAmount: Decimal | DecimalJsLike | number | string
    isPrepaid?: boolean
    isRefunded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    booking: BookingCreateNestedOneWithoutBookingPaymentInput
    refundTransactions?: RefundTransactionCreateNestedManyWithoutBookingPaymentInput
  }

  export type BookingPaymentUncheckedCreateWithoutPaymentTransactionsInput = {
    id?: number
    bookingId: number
    paymentReference?: string | null
    paymentStatus: string
    originalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    surchargeAmount?: Decimal | DecimalJsLike | number | string
    finalAmount: Decimal | DecimalJsLike | number | string
    isPrepaid?: boolean
    isRefunded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    refundTransactions?: RefundTransactionUncheckedCreateNestedManyWithoutBookingPaymentInput
  }

  export type BookingPaymentCreateOrConnectWithoutPaymentTransactionsInput = {
    where: BookingPaymentWhereUniqueInput
    create: XOR<BookingPaymentCreateWithoutPaymentTransactionsInput, BookingPaymentUncheckedCreateWithoutPaymentTransactionsInput>
  }

  export type PaymentMethodCreateWithoutPaymentTransactionsInput = {
    methodName: string
    provider: string
    methodType: string
    description?: string | null
    processingFeePercent?: Decimal | DecimalJsLike | number | string
    fixedFee?: Decimal | DecimalJsLike | number | string
    supportsRefunds?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userPaymentMethods?: UserPaymentMethodCreateNestedManyWithoutPaymentMethodInput
    parkingPassPayments?: ParkingPassPaymentCreateNestedManyWithoutPaymentMethodInput
  }

  export type PaymentMethodUncheckedCreateWithoutPaymentTransactionsInput = {
    id?: number
    methodName: string
    provider: string
    methodType: string
    description?: string | null
    processingFeePercent?: Decimal | DecimalJsLike | number | string
    fixedFee?: Decimal | DecimalJsLike | number | string
    supportsRefunds?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userPaymentMethods?: UserPaymentMethodUncheckedCreateNestedManyWithoutPaymentMethodInput
    parkingPassPayments?: ParkingPassPaymentUncheckedCreateNestedManyWithoutPaymentMethodInput
  }

  export type PaymentMethodCreateOrConnectWithoutPaymentTransactionsInput = {
    where: PaymentMethodWhereUniqueInput
    create: XOR<PaymentMethodCreateWithoutPaymentTransactionsInput, PaymentMethodUncheckedCreateWithoutPaymentTransactionsInput>
  }

  export type BookingPaymentUpsertWithoutPaymentTransactionsInput = {
    update: XOR<BookingPaymentUpdateWithoutPaymentTransactionsInput, BookingPaymentUncheckedUpdateWithoutPaymentTransactionsInput>
    create: XOR<BookingPaymentCreateWithoutPaymentTransactionsInput, BookingPaymentUncheckedCreateWithoutPaymentTransactionsInput>
    where?: BookingPaymentWhereInput
  }

  export type BookingPaymentUpdateToOneWithWhereWithoutPaymentTransactionsInput = {
    where?: BookingPaymentWhereInput
    data: XOR<BookingPaymentUpdateWithoutPaymentTransactionsInput, BookingPaymentUncheckedUpdateWithoutPaymentTransactionsInput>
  }

  export type BookingPaymentUpdateWithoutPaymentTransactionsInput = {
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    originalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    surchargeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPrepaid?: BoolFieldUpdateOperationsInput | boolean
    isRefunded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    booking?: BookingUpdateOneRequiredWithoutBookingPaymentNestedInput
    refundTransactions?: RefundTransactionUpdateManyWithoutBookingPaymentNestedInput
  }

  export type BookingPaymentUncheckedUpdateWithoutPaymentTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    originalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    surchargeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPrepaid?: BoolFieldUpdateOperationsInput | boolean
    isRefunded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundTransactions?: RefundTransactionUncheckedUpdateManyWithoutBookingPaymentNestedInput
  }

  export type PaymentMethodUpsertWithoutPaymentTransactionsInput = {
    update: XOR<PaymentMethodUpdateWithoutPaymentTransactionsInput, PaymentMethodUncheckedUpdateWithoutPaymentTransactionsInput>
    create: XOR<PaymentMethodCreateWithoutPaymentTransactionsInput, PaymentMethodUncheckedCreateWithoutPaymentTransactionsInput>
    where?: PaymentMethodWhereInput
  }

  export type PaymentMethodUpdateToOneWithWhereWithoutPaymentTransactionsInput = {
    where?: PaymentMethodWhereInput
    data: XOR<PaymentMethodUpdateWithoutPaymentTransactionsInput, PaymentMethodUncheckedUpdateWithoutPaymentTransactionsInput>
  }

  export type PaymentMethodUpdateWithoutPaymentTransactionsInput = {
    methodName?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    methodType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    processingFeePercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fixedFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    supportsRefunds?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userPaymentMethods?: UserPaymentMethodUpdateManyWithoutPaymentMethodNestedInput
    parkingPassPayments?: ParkingPassPaymentUpdateManyWithoutPaymentMethodNestedInput
  }

  export type PaymentMethodUncheckedUpdateWithoutPaymentTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    methodName?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    methodType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    processingFeePercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fixedFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    supportsRefunds?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userPaymentMethods?: UserPaymentMethodUncheckedUpdateManyWithoutPaymentMethodNestedInput
    parkingPassPayments?: ParkingPassPaymentUncheckedUpdateManyWithoutPaymentMethodNestedInput
  }

  export type BookingPaymentCreateWithoutRefundTransactionsInput = {
    paymentReference?: string | null
    paymentStatus: string
    originalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    surchargeAmount?: Decimal | DecimalJsLike | number | string
    finalAmount: Decimal | DecimalJsLike | number | string
    isPrepaid?: boolean
    isRefunded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    booking: BookingCreateNestedOneWithoutBookingPaymentInput
    paymentTransactions?: PaymentTransactionCreateNestedManyWithoutBookingPaymentInput
  }

  export type BookingPaymentUncheckedCreateWithoutRefundTransactionsInput = {
    id?: number
    bookingId: number
    paymentReference?: string | null
    paymentStatus: string
    originalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    surchargeAmount?: Decimal | DecimalJsLike | number | string
    finalAmount: Decimal | DecimalJsLike | number | string
    isPrepaid?: boolean
    isRefunded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    paymentTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutBookingPaymentInput
  }

  export type BookingPaymentCreateOrConnectWithoutRefundTransactionsInput = {
    where: BookingPaymentWhereUniqueInput
    create: XOR<BookingPaymentCreateWithoutRefundTransactionsInput, BookingPaymentUncheckedCreateWithoutRefundTransactionsInput>
  }

  export type BookingPaymentUpsertWithoutRefundTransactionsInput = {
    update: XOR<BookingPaymentUpdateWithoutRefundTransactionsInput, BookingPaymentUncheckedUpdateWithoutRefundTransactionsInput>
    create: XOR<BookingPaymentCreateWithoutRefundTransactionsInput, BookingPaymentUncheckedCreateWithoutRefundTransactionsInput>
    where?: BookingPaymentWhereInput
  }

  export type BookingPaymentUpdateToOneWithWhereWithoutRefundTransactionsInput = {
    where?: BookingPaymentWhereInput
    data: XOR<BookingPaymentUpdateWithoutRefundTransactionsInput, BookingPaymentUncheckedUpdateWithoutRefundTransactionsInput>
  }

  export type BookingPaymentUpdateWithoutRefundTransactionsInput = {
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    originalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    surchargeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPrepaid?: BoolFieldUpdateOperationsInput | boolean
    isRefunded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    booking?: BookingUpdateOneRequiredWithoutBookingPaymentNestedInput
    paymentTransactions?: PaymentTransactionUpdateManyWithoutBookingPaymentNestedInput
  }

  export type BookingPaymentUncheckedUpdateWithoutRefundTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    originalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    surchargeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPrepaid?: BoolFieldUpdateOperationsInput | boolean
    isRefunded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentTransactions?: PaymentTransactionUncheckedUpdateManyWithoutBookingPaymentNestedInput
  }

  export type PaymentTransactionCreateWithoutPaymentMethodInput = {
    transactionReference?: string | null
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    transactionStatus: string
    gatewayResponse?: string | null
    transactionData?: string | null
    transactionTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    bookingPayment: BookingPaymentCreateNestedOneWithoutPaymentTransactionsInput
  }

  export type PaymentTransactionUncheckedCreateWithoutPaymentMethodInput = {
    id?: number
    paymentId: number
    transactionReference?: string | null
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    transactionStatus: string
    gatewayResponse?: string | null
    transactionData?: string | null
    transactionTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type PaymentTransactionCreateOrConnectWithoutPaymentMethodInput = {
    where: PaymentTransactionWhereUniqueInput
    create: XOR<PaymentTransactionCreateWithoutPaymentMethodInput, PaymentTransactionUncheckedCreateWithoutPaymentMethodInput>
  }

  export type PaymentTransactionCreateManyPaymentMethodInputEnvelope = {
    data: PaymentTransactionCreateManyPaymentMethodInput | PaymentTransactionCreateManyPaymentMethodInput[]
    skipDuplicates?: boolean
  }

  export type UserPaymentMethodCreateWithoutPaymentMethodInput = {
    tokenReference: string
    maskedInfo?: string | null
    expiryInfo?: string | null
    isDefault?: boolean
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutUserPaymentMethodsInput
  }

  export type UserPaymentMethodUncheckedCreateWithoutPaymentMethodInput = {
    id?: number
    userId: number
    tokenReference: string
    maskedInfo?: string | null
    expiryInfo?: string | null
    isDefault?: boolean
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type UserPaymentMethodCreateOrConnectWithoutPaymentMethodInput = {
    where: UserPaymentMethodWhereUniqueInput
    create: XOR<UserPaymentMethodCreateWithoutPaymentMethodInput, UserPaymentMethodUncheckedCreateWithoutPaymentMethodInput>
  }

  export type UserPaymentMethodCreateManyPaymentMethodInputEnvelope = {
    data: UserPaymentMethodCreateManyPaymentMethodInput | UserPaymentMethodCreateManyPaymentMethodInput[]
    skipDuplicates?: boolean
  }

  export type ParkingPassPaymentCreateWithoutPaymentMethodInput = {
    amount: Decimal | DecimalJsLike | number | string
    paymentStatus: string
    transactionReference?: string | null
    paymentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    parkingPass: ParkingPassCreateNestedOneWithoutParkingPassPaymentsInput
  }

  export type ParkingPassPaymentUncheckedCreateWithoutPaymentMethodInput = {
    id?: number
    passId: number
    amount: Decimal | DecimalJsLike | number | string
    paymentStatus: string
    transactionReference?: string | null
    paymentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type ParkingPassPaymentCreateOrConnectWithoutPaymentMethodInput = {
    where: ParkingPassPaymentWhereUniqueInput
    create: XOR<ParkingPassPaymentCreateWithoutPaymentMethodInput, ParkingPassPaymentUncheckedCreateWithoutPaymentMethodInput>
  }

  export type ParkingPassPaymentCreateManyPaymentMethodInputEnvelope = {
    data: ParkingPassPaymentCreateManyPaymentMethodInput | ParkingPassPaymentCreateManyPaymentMethodInput[]
    skipDuplicates?: boolean
  }

  export type PaymentTransactionUpsertWithWhereUniqueWithoutPaymentMethodInput = {
    where: PaymentTransactionWhereUniqueInput
    update: XOR<PaymentTransactionUpdateWithoutPaymentMethodInput, PaymentTransactionUncheckedUpdateWithoutPaymentMethodInput>
    create: XOR<PaymentTransactionCreateWithoutPaymentMethodInput, PaymentTransactionUncheckedCreateWithoutPaymentMethodInput>
  }

  export type PaymentTransactionUpdateWithWhereUniqueWithoutPaymentMethodInput = {
    where: PaymentTransactionWhereUniqueInput
    data: XOR<PaymentTransactionUpdateWithoutPaymentMethodInput, PaymentTransactionUncheckedUpdateWithoutPaymentMethodInput>
  }

  export type PaymentTransactionUpdateManyWithWhereWithoutPaymentMethodInput = {
    where: PaymentTransactionScalarWhereInput
    data: XOR<PaymentTransactionUpdateManyMutationInput, PaymentTransactionUncheckedUpdateManyWithoutPaymentMethodInput>
  }

  export type UserPaymentMethodUpsertWithWhereUniqueWithoutPaymentMethodInput = {
    where: UserPaymentMethodWhereUniqueInput
    update: XOR<UserPaymentMethodUpdateWithoutPaymentMethodInput, UserPaymentMethodUncheckedUpdateWithoutPaymentMethodInput>
    create: XOR<UserPaymentMethodCreateWithoutPaymentMethodInput, UserPaymentMethodUncheckedCreateWithoutPaymentMethodInput>
  }

  export type UserPaymentMethodUpdateWithWhereUniqueWithoutPaymentMethodInput = {
    where: UserPaymentMethodWhereUniqueInput
    data: XOR<UserPaymentMethodUpdateWithoutPaymentMethodInput, UserPaymentMethodUncheckedUpdateWithoutPaymentMethodInput>
  }

  export type UserPaymentMethodUpdateManyWithWhereWithoutPaymentMethodInput = {
    where: UserPaymentMethodScalarWhereInput
    data: XOR<UserPaymentMethodUpdateManyMutationInput, UserPaymentMethodUncheckedUpdateManyWithoutPaymentMethodInput>
  }

  export type ParkingPassPaymentUpsertWithWhereUniqueWithoutPaymentMethodInput = {
    where: ParkingPassPaymentWhereUniqueInput
    update: XOR<ParkingPassPaymentUpdateWithoutPaymentMethodInput, ParkingPassPaymentUncheckedUpdateWithoutPaymentMethodInput>
    create: XOR<ParkingPassPaymentCreateWithoutPaymentMethodInput, ParkingPassPaymentUncheckedCreateWithoutPaymentMethodInput>
  }

  export type ParkingPassPaymentUpdateWithWhereUniqueWithoutPaymentMethodInput = {
    where: ParkingPassPaymentWhereUniqueInput
    data: XOR<ParkingPassPaymentUpdateWithoutPaymentMethodInput, ParkingPassPaymentUncheckedUpdateWithoutPaymentMethodInput>
  }

  export type ParkingPassPaymentUpdateManyWithWhereWithoutPaymentMethodInput = {
    where: ParkingPassPaymentScalarWhereInput
    data: XOR<ParkingPassPaymentUpdateManyMutationInput, ParkingPassPaymentUncheckedUpdateManyWithoutPaymentMethodInput>
  }

  export type ParkingPassPaymentScalarWhereInput = {
    AND?: ParkingPassPaymentScalarWhereInput | ParkingPassPaymentScalarWhereInput[]
    OR?: ParkingPassPaymentScalarWhereInput[]
    NOT?: ParkingPassPaymentScalarWhereInput | ParkingPassPaymentScalarWhereInput[]
    id?: IntFilter<"ParkingPassPayment"> | number
    passId?: IntFilter<"ParkingPassPayment"> | number
    paymentMethodId?: IntFilter<"ParkingPassPayment"> | number
    amount?: DecimalFilter<"ParkingPassPayment"> | Decimal | DecimalJsLike | number | string
    paymentStatus?: StringFilter<"ParkingPassPayment"> | string
    transactionReference?: StringNullableFilter<"ParkingPassPayment"> | string | null
    paymentDate?: DateTimeNullableFilter<"ParkingPassPayment"> | Date | string | null
    createdAt?: DateTimeFilter<"ParkingPassPayment"> | Date | string
    updatedAt?: DateTimeNullableFilter<"ParkingPassPayment"> | Date | string | null
  }

  export type UserCreateWithoutUserPaymentMethodsInput = {
    username: string
    email: string
    passwordHash: string
    phoneNumber?: string | null
    accountType: string
    emailVerified?: boolean
    phoneVerified?: boolean
    accountStatus?: string
    googleId?: string | null
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    vehicles?: VehicleCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    parkingPasses?: ParkingPassCreateNestedManyWithoutUserInput
    placeRatings?: PlaceRatingCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    EmailVerificationToken?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    PhoneVerificationOtp?: PhoneVerificationOtpCreateNestedManyWithoutUserInput
    PasswordResetToken?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserPaymentMethodsInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    phoneNumber?: string | null
    accountType: string
    emailVerified?: boolean
    phoneVerified?: boolean
    accountStatus?: string
    googleId?: string | null
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    vehicles?: VehicleUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    parkingPasses?: ParkingPassUncheckedCreateNestedManyWithoutUserInput
    placeRatings?: PlaceRatingUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    EmailVerificationToken?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    PhoneVerificationOtp?: PhoneVerificationOtpUncheckedCreateNestedManyWithoutUserInput
    PasswordResetToken?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserPaymentMethodsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserPaymentMethodsInput, UserUncheckedCreateWithoutUserPaymentMethodsInput>
  }

  export type PaymentMethodCreateWithoutUserPaymentMethodsInput = {
    methodName: string
    provider: string
    methodType: string
    description?: string | null
    processingFeePercent?: Decimal | DecimalJsLike | number | string
    fixedFee?: Decimal | DecimalJsLike | number | string
    supportsRefunds?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    paymentTransactions?: PaymentTransactionCreateNestedManyWithoutPaymentMethodInput
    parkingPassPayments?: ParkingPassPaymentCreateNestedManyWithoutPaymentMethodInput
  }

  export type PaymentMethodUncheckedCreateWithoutUserPaymentMethodsInput = {
    id?: number
    methodName: string
    provider: string
    methodType: string
    description?: string | null
    processingFeePercent?: Decimal | DecimalJsLike | number | string
    fixedFee?: Decimal | DecimalJsLike | number | string
    supportsRefunds?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    paymentTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutPaymentMethodInput
    parkingPassPayments?: ParkingPassPaymentUncheckedCreateNestedManyWithoutPaymentMethodInput
  }

  export type PaymentMethodCreateOrConnectWithoutUserPaymentMethodsInput = {
    where: PaymentMethodWhereUniqueInput
    create: XOR<PaymentMethodCreateWithoutUserPaymentMethodsInput, PaymentMethodUncheckedCreateWithoutUserPaymentMethodsInput>
  }

  export type UserUpsertWithoutUserPaymentMethodsInput = {
    update: XOR<UserUpdateWithoutUserPaymentMethodsInput, UserUncheckedUpdateWithoutUserPaymentMethodsInput>
    create: XOR<UserCreateWithoutUserPaymentMethodsInput, UserUncheckedCreateWithoutUserPaymentMethodsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserPaymentMethodsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserPaymentMethodsInput, UserUncheckedUpdateWithoutUserPaymentMethodsInput>
  }

  export type UserUpdateWithoutUserPaymentMethodsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    accountStatus?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    vehicles?: VehicleUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    parkingPasses?: ParkingPassUpdateManyWithoutUserNestedInput
    placeRatings?: PlaceRatingUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    EmailVerificationToken?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    PhoneVerificationOtp?: PhoneVerificationOtpUpdateManyWithoutUserNestedInput
    PasswordResetToken?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserPaymentMethodsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    accountStatus?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    vehicles?: VehicleUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    parkingPasses?: ParkingPassUncheckedUpdateManyWithoutUserNestedInput
    placeRatings?: PlaceRatingUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    EmailVerificationToken?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    PhoneVerificationOtp?: PhoneVerificationOtpUncheckedUpdateManyWithoutUserNestedInput
    PasswordResetToken?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PaymentMethodUpsertWithoutUserPaymentMethodsInput = {
    update: XOR<PaymentMethodUpdateWithoutUserPaymentMethodsInput, PaymentMethodUncheckedUpdateWithoutUserPaymentMethodsInput>
    create: XOR<PaymentMethodCreateWithoutUserPaymentMethodsInput, PaymentMethodUncheckedCreateWithoutUserPaymentMethodsInput>
    where?: PaymentMethodWhereInput
  }

  export type PaymentMethodUpdateToOneWithWhereWithoutUserPaymentMethodsInput = {
    where?: PaymentMethodWhereInput
    data: XOR<PaymentMethodUpdateWithoutUserPaymentMethodsInput, PaymentMethodUncheckedUpdateWithoutUserPaymentMethodsInput>
  }

  export type PaymentMethodUpdateWithoutUserPaymentMethodsInput = {
    methodName?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    methodType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    processingFeePercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fixedFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    supportsRefunds?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentTransactions?: PaymentTransactionUpdateManyWithoutPaymentMethodNestedInput
    parkingPassPayments?: ParkingPassPaymentUpdateManyWithoutPaymentMethodNestedInput
  }

  export type PaymentMethodUncheckedUpdateWithoutUserPaymentMethodsInput = {
    id?: IntFieldUpdateOperationsInput | number
    methodName?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    methodType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    processingFeePercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fixedFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    supportsRefunds?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentTransactions?: PaymentTransactionUncheckedUpdateManyWithoutPaymentMethodNestedInput
    parkingPassPayments?: ParkingPassPaymentUncheckedUpdateManyWithoutPaymentMethodNestedInput
  }

  export type BookingCreateWithoutPromoCodeInput = {
    bookingReference: string
    bookingTime?: Date | string
    scheduledEntry: Date | string
    scheduledExit: Date | string
    actualEntry?: Date | string | null
    actualExit?: Date | string | null
    qrCode?: string | null
    bookingStatus: string
    estimatedPrice: Decimal | DecimalJsLike | number | string
    finalPrice?: Decimal | DecimalJsLike | number | string | null
    cancellationReason?: string | null
    cancellationTimeMinutes?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutBookingsInput
    vehicle: VehicleCreateNestedOneWithoutBookingsInput
    parkingSlot: ParkingSlotCreateNestedOneWithoutBookingsInput
    bookingStatusLogs?: BookingStatusLogCreateNestedManyWithoutBookingInput
    bookingPayment?: BookingPaymentCreateNestedOneWithoutBookingInput
    accessLogs?: AccessLogCreateNestedManyWithoutBookingInput
    bookingExtensions?: BookingExtensionCreateNestedManyWithoutBookingInput
    placeRatings?: PlaceRatingCreateNestedManyWithoutBookingInput
    notifications?: NotificationCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutPromoCodeInput = {
    id?: number
    userId: number
    vehicleId: number
    slotId: number
    bookingReference: string
    bookingTime?: Date | string
    scheduledEntry: Date | string
    scheduledExit: Date | string
    actualEntry?: Date | string | null
    actualExit?: Date | string | null
    qrCode?: string | null
    bookingStatus: string
    estimatedPrice: Decimal | DecimalJsLike | number | string
    finalPrice?: Decimal | DecimalJsLike | number | string | null
    cancellationReason?: string | null
    cancellationTimeMinutes?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    bookingStatusLogs?: BookingStatusLogUncheckedCreateNestedManyWithoutBookingInput
    bookingPayment?: BookingPaymentUncheckedCreateNestedOneWithoutBookingInput
    accessLogs?: AccessLogUncheckedCreateNestedManyWithoutBookingInput
    bookingExtensions?: BookingExtensionUncheckedCreateNestedManyWithoutBookingInput
    placeRatings?: PlaceRatingUncheckedCreateNestedManyWithoutBookingInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutPromoCodeInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutPromoCodeInput, BookingUncheckedCreateWithoutPromoCodeInput>
  }

  export type BookingCreateManyPromoCodeInputEnvelope = {
    data: BookingCreateManyPromoCodeInput | BookingCreateManyPromoCodeInput[]
    skipDuplicates?: boolean
  }

  export type BookingUpsertWithWhereUniqueWithoutPromoCodeInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutPromoCodeInput, BookingUncheckedUpdateWithoutPromoCodeInput>
    create: XOR<BookingCreateWithoutPromoCodeInput, BookingUncheckedCreateWithoutPromoCodeInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutPromoCodeInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutPromoCodeInput, BookingUncheckedUpdateWithoutPromoCodeInput>
  }

  export type BookingUpdateManyWithWhereWithoutPromoCodeInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutPromoCodeInput>
  }

  export type UserCreateWithoutParkingPassesInput = {
    username: string
    email: string
    passwordHash: string
    phoneNumber?: string | null
    accountType: string
    emailVerified?: boolean
    phoneVerified?: boolean
    accountStatus?: string
    googleId?: string | null
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    vehicles?: VehicleCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    userPaymentMethods?: UserPaymentMethodCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    placeRatings?: PlaceRatingCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    EmailVerificationToken?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    PhoneVerificationOtp?: PhoneVerificationOtpCreateNestedManyWithoutUserInput
    PasswordResetToken?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutParkingPassesInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    phoneNumber?: string | null
    accountType: string
    emailVerified?: boolean
    phoneVerified?: boolean
    accountStatus?: string
    googleId?: string | null
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    vehicles?: VehicleUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    userPaymentMethods?: UserPaymentMethodUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    placeRatings?: PlaceRatingUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    EmailVerificationToken?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    PhoneVerificationOtp?: PhoneVerificationOtpUncheckedCreateNestedManyWithoutUserInput
    PasswordResetToken?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutParkingPassesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutParkingPassesInput, UserUncheckedCreateWithoutParkingPassesInput>
  }

  export type PlaceCreateWithoutParkingPassesInput = {
    name: string
    image?: string | null
    placeType: string
    address: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    contactNumber?: string | null
    email?: string | null
    description?: string | null
    totalCapacity: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    parkingZones?: ParkingZoneCreateNestedManyWithoutPlaceInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutPlaceInput
    operatingHours?: OperatingHourCreateNestedManyWithoutPlaceInput
    placeAdmins?: PlaceAdminCreateNestedManyWithoutPlaceInput
    placeRatings?: PlaceRatingCreateNestedManyWithoutPlaceInput
  }

  export type PlaceUncheckedCreateWithoutParkingPassesInput = {
    id?: number
    name: string
    image?: string | null
    placeType: string
    address: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    contactNumber?: string | null
    email?: string | null
    description?: string | null
    totalCapacity: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    parkingZones?: ParkingZoneUncheckedCreateNestedManyWithoutPlaceInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutPlaceInput
    operatingHours?: OperatingHourUncheckedCreateNestedManyWithoutPlaceInput
    placeAdmins?: PlaceAdminUncheckedCreateNestedManyWithoutPlaceInput
    placeRatings?: PlaceRatingUncheckedCreateNestedManyWithoutPlaceInput
  }

  export type PlaceCreateOrConnectWithoutParkingPassesInput = {
    where: PlaceWhereUniqueInput
    create: XOR<PlaceCreateWithoutParkingPassesInput, PlaceUncheckedCreateWithoutParkingPassesInput>
  }

  export type ParkingPassPaymentCreateWithoutParkingPassInput = {
    amount: Decimal | DecimalJsLike | number | string
    paymentStatus: string
    transactionReference?: string | null
    paymentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    paymentMethod: PaymentMethodCreateNestedOneWithoutParkingPassPaymentsInput
  }

  export type ParkingPassPaymentUncheckedCreateWithoutParkingPassInput = {
    id?: number
    paymentMethodId: number
    amount: Decimal | DecimalJsLike | number | string
    paymentStatus: string
    transactionReference?: string | null
    paymentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type ParkingPassPaymentCreateOrConnectWithoutParkingPassInput = {
    where: ParkingPassPaymentWhereUniqueInput
    create: XOR<ParkingPassPaymentCreateWithoutParkingPassInput, ParkingPassPaymentUncheckedCreateWithoutParkingPassInput>
  }

  export type ParkingPassPaymentCreateManyParkingPassInputEnvelope = {
    data: ParkingPassPaymentCreateManyParkingPassInput | ParkingPassPaymentCreateManyParkingPassInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutParkingPassesInput = {
    update: XOR<UserUpdateWithoutParkingPassesInput, UserUncheckedUpdateWithoutParkingPassesInput>
    create: XOR<UserCreateWithoutParkingPassesInput, UserUncheckedCreateWithoutParkingPassesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutParkingPassesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutParkingPassesInput, UserUncheckedUpdateWithoutParkingPassesInput>
  }

  export type UserUpdateWithoutParkingPassesInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    accountStatus?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    vehicles?: VehicleUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    userPaymentMethods?: UserPaymentMethodUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    placeRatings?: PlaceRatingUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    EmailVerificationToken?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    PhoneVerificationOtp?: PhoneVerificationOtpUpdateManyWithoutUserNestedInput
    PasswordResetToken?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutParkingPassesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    accountStatus?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    vehicles?: VehicleUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    userPaymentMethods?: UserPaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    placeRatings?: PlaceRatingUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    EmailVerificationToken?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    PhoneVerificationOtp?: PhoneVerificationOtpUncheckedUpdateManyWithoutUserNestedInput
    PasswordResetToken?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PlaceUpsertWithoutParkingPassesInput = {
    update: XOR<PlaceUpdateWithoutParkingPassesInput, PlaceUncheckedUpdateWithoutParkingPassesInput>
    create: XOR<PlaceCreateWithoutParkingPassesInput, PlaceUncheckedCreateWithoutParkingPassesInput>
    where?: PlaceWhereInput
  }

  export type PlaceUpdateToOneWithWhereWithoutParkingPassesInput = {
    where?: PlaceWhereInput
    data: XOR<PlaceUpdateWithoutParkingPassesInput, PlaceUncheckedUpdateWithoutParkingPassesInput>
  }

  export type PlaceUpdateWithoutParkingPassesInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    placeType?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalCapacity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parkingZones?: ParkingZoneUpdateManyWithoutPlaceNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutPlaceNestedInput
    operatingHours?: OperatingHourUpdateManyWithoutPlaceNestedInput
    placeAdmins?: PlaceAdminUpdateManyWithoutPlaceNestedInput
    placeRatings?: PlaceRatingUpdateManyWithoutPlaceNestedInput
  }

  export type PlaceUncheckedUpdateWithoutParkingPassesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    placeType?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalCapacity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parkingZones?: ParkingZoneUncheckedUpdateManyWithoutPlaceNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutPlaceNestedInput
    operatingHours?: OperatingHourUncheckedUpdateManyWithoutPlaceNestedInput
    placeAdmins?: PlaceAdminUncheckedUpdateManyWithoutPlaceNestedInput
    placeRatings?: PlaceRatingUncheckedUpdateManyWithoutPlaceNestedInput
  }

  export type ParkingPassPaymentUpsertWithWhereUniqueWithoutParkingPassInput = {
    where: ParkingPassPaymentWhereUniqueInput
    update: XOR<ParkingPassPaymentUpdateWithoutParkingPassInput, ParkingPassPaymentUncheckedUpdateWithoutParkingPassInput>
    create: XOR<ParkingPassPaymentCreateWithoutParkingPassInput, ParkingPassPaymentUncheckedCreateWithoutParkingPassInput>
  }

  export type ParkingPassPaymentUpdateWithWhereUniqueWithoutParkingPassInput = {
    where: ParkingPassPaymentWhereUniqueInput
    data: XOR<ParkingPassPaymentUpdateWithoutParkingPassInput, ParkingPassPaymentUncheckedUpdateWithoutParkingPassInput>
  }

  export type ParkingPassPaymentUpdateManyWithWhereWithoutParkingPassInput = {
    where: ParkingPassPaymentScalarWhereInput
    data: XOR<ParkingPassPaymentUpdateManyMutationInput, ParkingPassPaymentUncheckedUpdateManyWithoutParkingPassInput>
  }

  export type ParkingPassCreateWithoutParkingPassPaymentsInput = {
    passType: string
    passReference?: string | null
    startDate: Date | string
    endDate: Date | string
    price: Decimal | DecimalJsLike | number | string
    status: string
    autoRenew?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutParkingPassesInput
    place: PlaceCreateNestedOneWithoutParkingPassesInput
  }

  export type ParkingPassUncheckedCreateWithoutParkingPassPaymentsInput = {
    id?: number
    userId: number
    placeId: number
    passType: string
    passReference?: string | null
    startDate: Date | string
    endDate: Date | string
    price: Decimal | DecimalJsLike | number | string
    status: string
    autoRenew?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type ParkingPassCreateOrConnectWithoutParkingPassPaymentsInput = {
    where: ParkingPassWhereUniqueInput
    create: XOR<ParkingPassCreateWithoutParkingPassPaymentsInput, ParkingPassUncheckedCreateWithoutParkingPassPaymentsInput>
  }

  export type PaymentMethodCreateWithoutParkingPassPaymentsInput = {
    methodName: string
    provider: string
    methodType: string
    description?: string | null
    processingFeePercent?: Decimal | DecimalJsLike | number | string
    fixedFee?: Decimal | DecimalJsLike | number | string
    supportsRefunds?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    paymentTransactions?: PaymentTransactionCreateNestedManyWithoutPaymentMethodInput
    userPaymentMethods?: UserPaymentMethodCreateNestedManyWithoutPaymentMethodInput
  }

  export type PaymentMethodUncheckedCreateWithoutParkingPassPaymentsInput = {
    id?: number
    methodName: string
    provider: string
    methodType: string
    description?: string | null
    processingFeePercent?: Decimal | DecimalJsLike | number | string
    fixedFee?: Decimal | DecimalJsLike | number | string
    supportsRefunds?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    paymentTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutPaymentMethodInput
    userPaymentMethods?: UserPaymentMethodUncheckedCreateNestedManyWithoutPaymentMethodInput
  }

  export type PaymentMethodCreateOrConnectWithoutParkingPassPaymentsInput = {
    where: PaymentMethodWhereUniqueInput
    create: XOR<PaymentMethodCreateWithoutParkingPassPaymentsInput, PaymentMethodUncheckedCreateWithoutParkingPassPaymentsInput>
  }

  export type ParkingPassUpsertWithoutParkingPassPaymentsInput = {
    update: XOR<ParkingPassUpdateWithoutParkingPassPaymentsInput, ParkingPassUncheckedUpdateWithoutParkingPassPaymentsInput>
    create: XOR<ParkingPassCreateWithoutParkingPassPaymentsInput, ParkingPassUncheckedCreateWithoutParkingPassPaymentsInput>
    where?: ParkingPassWhereInput
  }

  export type ParkingPassUpdateToOneWithWhereWithoutParkingPassPaymentsInput = {
    where?: ParkingPassWhereInput
    data: XOR<ParkingPassUpdateWithoutParkingPassPaymentsInput, ParkingPassUncheckedUpdateWithoutParkingPassPaymentsInput>
  }

  export type ParkingPassUpdateWithoutParkingPassPaymentsInput = {
    passType?: StringFieldUpdateOperationsInput | string
    passReference?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutParkingPassesNestedInput
    place?: PlaceUpdateOneRequiredWithoutParkingPassesNestedInput
  }

  export type ParkingPassUncheckedUpdateWithoutParkingPassPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    placeId?: IntFieldUpdateOperationsInput | number
    passType?: StringFieldUpdateOperationsInput | string
    passReference?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentMethodUpsertWithoutParkingPassPaymentsInput = {
    update: XOR<PaymentMethodUpdateWithoutParkingPassPaymentsInput, PaymentMethodUncheckedUpdateWithoutParkingPassPaymentsInput>
    create: XOR<PaymentMethodCreateWithoutParkingPassPaymentsInput, PaymentMethodUncheckedCreateWithoutParkingPassPaymentsInput>
    where?: PaymentMethodWhereInput
  }

  export type PaymentMethodUpdateToOneWithWhereWithoutParkingPassPaymentsInput = {
    where?: PaymentMethodWhereInput
    data: XOR<PaymentMethodUpdateWithoutParkingPassPaymentsInput, PaymentMethodUncheckedUpdateWithoutParkingPassPaymentsInput>
  }

  export type PaymentMethodUpdateWithoutParkingPassPaymentsInput = {
    methodName?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    methodType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    processingFeePercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fixedFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    supportsRefunds?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentTransactions?: PaymentTransactionUpdateManyWithoutPaymentMethodNestedInput
    userPaymentMethods?: UserPaymentMethodUpdateManyWithoutPaymentMethodNestedInput
  }

  export type PaymentMethodUncheckedUpdateWithoutParkingPassPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    methodName?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    methodType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    processingFeePercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fixedFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    supportsRefunds?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentTransactions?: PaymentTransactionUncheckedUpdateManyWithoutPaymentMethodNestedInput
    userPaymentMethods?: UserPaymentMethodUncheckedUpdateManyWithoutPaymentMethodNestedInput
  }

  export type BookingCreateWithoutAccessLogsInput = {
    bookingReference: string
    bookingTime?: Date | string
    scheduledEntry: Date | string
    scheduledExit: Date | string
    actualEntry?: Date | string | null
    actualExit?: Date | string | null
    qrCode?: string | null
    bookingStatus: string
    estimatedPrice: Decimal | DecimalJsLike | number | string
    finalPrice?: Decimal | DecimalJsLike | number | string | null
    cancellationReason?: string | null
    cancellationTimeMinutes?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutBookingsInput
    vehicle: VehicleCreateNestedOneWithoutBookingsInput
    parkingSlot: ParkingSlotCreateNestedOneWithoutBookingsInput
    promoCode?: PromoCodeCreateNestedOneWithoutBookingsInput
    bookingStatusLogs?: BookingStatusLogCreateNestedManyWithoutBookingInput
    bookingPayment?: BookingPaymentCreateNestedOneWithoutBookingInput
    bookingExtensions?: BookingExtensionCreateNestedManyWithoutBookingInput
    placeRatings?: PlaceRatingCreateNestedManyWithoutBookingInput
    notifications?: NotificationCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutAccessLogsInput = {
    id?: number
    userId: number
    vehicleId: number
    slotId: number
    promoCodeId?: number | null
    bookingReference: string
    bookingTime?: Date | string
    scheduledEntry: Date | string
    scheduledExit: Date | string
    actualEntry?: Date | string | null
    actualExit?: Date | string | null
    qrCode?: string | null
    bookingStatus: string
    estimatedPrice: Decimal | DecimalJsLike | number | string
    finalPrice?: Decimal | DecimalJsLike | number | string | null
    cancellationReason?: string | null
    cancellationTimeMinutes?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    bookingStatusLogs?: BookingStatusLogUncheckedCreateNestedManyWithoutBookingInput
    bookingPayment?: BookingPaymentUncheckedCreateNestedOneWithoutBookingInput
    bookingExtensions?: BookingExtensionUncheckedCreateNestedManyWithoutBookingInput
    placeRatings?: PlaceRatingUncheckedCreateNestedManyWithoutBookingInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutAccessLogsInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutAccessLogsInput, BookingUncheckedCreateWithoutAccessLogsInput>
  }

  export type BookingUpsertWithoutAccessLogsInput = {
    update: XOR<BookingUpdateWithoutAccessLogsInput, BookingUncheckedUpdateWithoutAccessLogsInput>
    create: XOR<BookingCreateWithoutAccessLogsInput, BookingUncheckedCreateWithoutAccessLogsInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutAccessLogsInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutAccessLogsInput, BookingUncheckedUpdateWithoutAccessLogsInput>
  }

  export type BookingUpdateWithoutAccessLogsInput = {
    bookingReference?: StringFieldUpdateOperationsInput | string
    bookingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledExit?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualExit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    bookingStatus?: StringFieldUpdateOperationsInput | string
    estimatedPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutBookingsNestedInput
    parkingSlot?: ParkingSlotUpdateOneRequiredWithoutBookingsNestedInput
    promoCode?: PromoCodeUpdateOneWithoutBookingsNestedInput
    bookingStatusLogs?: BookingStatusLogUpdateManyWithoutBookingNestedInput
    bookingPayment?: BookingPaymentUpdateOneWithoutBookingNestedInput
    bookingExtensions?: BookingExtensionUpdateManyWithoutBookingNestedInput
    placeRatings?: PlaceRatingUpdateManyWithoutBookingNestedInput
    notifications?: NotificationUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutAccessLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    slotId?: IntFieldUpdateOperationsInput | number
    promoCodeId?: NullableIntFieldUpdateOperationsInput | number | null
    bookingReference?: StringFieldUpdateOperationsInput | string
    bookingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledExit?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualExit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    bookingStatus?: StringFieldUpdateOperationsInput | string
    estimatedPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookingStatusLogs?: BookingStatusLogUncheckedUpdateManyWithoutBookingNestedInput
    bookingPayment?: BookingPaymentUncheckedUpdateOneWithoutBookingNestedInput
    bookingExtensions?: BookingExtensionUncheckedUpdateManyWithoutBookingNestedInput
    placeRatings?: PlaceRatingUncheckedUpdateManyWithoutBookingNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingCreateWithoutBookingExtensionsInput = {
    bookingReference: string
    bookingTime?: Date | string
    scheduledEntry: Date | string
    scheduledExit: Date | string
    actualEntry?: Date | string | null
    actualExit?: Date | string | null
    qrCode?: string | null
    bookingStatus: string
    estimatedPrice: Decimal | DecimalJsLike | number | string
    finalPrice?: Decimal | DecimalJsLike | number | string | null
    cancellationReason?: string | null
    cancellationTimeMinutes?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutBookingsInput
    vehicle: VehicleCreateNestedOneWithoutBookingsInput
    parkingSlot: ParkingSlotCreateNestedOneWithoutBookingsInput
    promoCode?: PromoCodeCreateNestedOneWithoutBookingsInput
    bookingStatusLogs?: BookingStatusLogCreateNestedManyWithoutBookingInput
    bookingPayment?: BookingPaymentCreateNestedOneWithoutBookingInput
    accessLogs?: AccessLogCreateNestedManyWithoutBookingInput
    placeRatings?: PlaceRatingCreateNestedManyWithoutBookingInput
    notifications?: NotificationCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutBookingExtensionsInput = {
    id?: number
    userId: number
    vehicleId: number
    slotId: number
    promoCodeId?: number | null
    bookingReference: string
    bookingTime?: Date | string
    scheduledEntry: Date | string
    scheduledExit: Date | string
    actualEntry?: Date | string | null
    actualExit?: Date | string | null
    qrCode?: string | null
    bookingStatus: string
    estimatedPrice: Decimal | DecimalJsLike | number | string
    finalPrice?: Decimal | DecimalJsLike | number | string | null
    cancellationReason?: string | null
    cancellationTimeMinutes?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    bookingStatusLogs?: BookingStatusLogUncheckedCreateNestedManyWithoutBookingInput
    bookingPayment?: BookingPaymentUncheckedCreateNestedOneWithoutBookingInput
    accessLogs?: AccessLogUncheckedCreateNestedManyWithoutBookingInput
    placeRatings?: PlaceRatingUncheckedCreateNestedManyWithoutBookingInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutBookingExtensionsInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutBookingExtensionsInput, BookingUncheckedCreateWithoutBookingExtensionsInput>
  }

  export type BookingUpsertWithoutBookingExtensionsInput = {
    update: XOR<BookingUpdateWithoutBookingExtensionsInput, BookingUncheckedUpdateWithoutBookingExtensionsInput>
    create: XOR<BookingCreateWithoutBookingExtensionsInput, BookingUncheckedCreateWithoutBookingExtensionsInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutBookingExtensionsInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutBookingExtensionsInput, BookingUncheckedUpdateWithoutBookingExtensionsInput>
  }

  export type BookingUpdateWithoutBookingExtensionsInput = {
    bookingReference?: StringFieldUpdateOperationsInput | string
    bookingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledExit?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualExit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    bookingStatus?: StringFieldUpdateOperationsInput | string
    estimatedPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutBookingsNestedInput
    parkingSlot?: ParkingSlotUpdateOneRequiredWithoutBookingsNestedInput
    promoCode?: PromoCodeUpdateOneWithoutBookingsNestedInput
    bookingStatusLogs?: BookingStatusLogUpdateManyWithoutBookingNestedInput
    bookingPayment?: BookingPaymentUpdateOneWithoutBookingNestedInput
    accessLogs?: AccessLogUpdateManyWithoutBookingNestedInput
    placeRatings?: PlaceRatingUpdateManyWithoutBookingNestedInput
    notifications?: NotificationUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutBookingExtensionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    slotId?: IntFieldUpdateOperationsInput | number
    promoCodeId?: NullableIntFieldUpdateOperationsInput | number | null
    bookingReference?: StringFieldUpdateOperationsInput | string
    bookingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledExit?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualExit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    bookingStatus?: StringFieldUpdateOperationsInput | string
    estimatedPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookingStatusLogs?: BookingStatusLogUncheckedUpdateManyWithoutBookingNestedInput
    bookingPayment?: BookingPaymentUncheckedUpdateOneWithoutBookingNestedInput
    accessLogs?: AccessLogUncheckedUpdateManyWithoutBookingNestedInput
    placeRatings?: PlaceRatingUncheckedUpdateManyWithoutBookingNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type UserCreateWithoutNotificationSettingsInput = {
    username: string
    email: string
    passwordHash: string
    phoneNumber?: string | null
    accountType: string
    emailVerified?: boolean
    phoneVerified?: boolean
    accountStatus?: string
    googleId?: string | null
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    vehicles?: VehicleCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    userPaymentMethods?: UserPaymentMethodCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    parkingPasses?: ParkingPassCreateNestedManyWithoutUserInput
    placeRatings?: PlaceRatingCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    EmailVerificationToken?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    PhoneVerificationOtp?: PhoneVerificationOtpCreateNestedManyWithoutUserInput
    PasswordResetToken?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationSettingsInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    phoneNumber?: string | null
    accountType: string
    emailVerified?: boolean
    phoneVerified?: boolean
    accountStatus?: string
    googleId?: string | null
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    vehicles?: VehicleUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    userPaymentMethods?: UserPaymentMethodUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    parkingPasses?: ParkingPassUncheckedCreateNestedManyWithoutUserInput
    placeRatings?: PlaceRatingUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    EmailVerificationToken?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    PhoneVerificationOtp?: PhoneVerificationOtpUncheckedCreateNestedManyWithoutUserInput
    PasswordResetToken?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationSettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationSettingsInput, UserUncheckedCreateWithoutNotificationSettingsInput>
  }

  export type UserUpsertWithoutNotificationSettingsInput = {
    update: XOR<UserUpdateWithoutNotificationSettingsInput, UserUncheckedUpdateWithoutNotificationSettingsInput>
    create: XOR<UserCreateWithoutNotificationSettingsInput, UserUncheckedCreateWithoutNotificationSettingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationSettingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationSettingsInput, UserUncheckedUpdateWithoutNotificationSettingsInput>
  }

  export type UserUpdateWithoutNotificationSettingsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    accountStatus?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    vehicles?: VehicleUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    userPaymentMethods?: UserPaymentMethodUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    parkingPasses?: ParkingPassUpdateManyWithoutUserNestedInput
    placeRatings?: PlaceRatingUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    EmailVerificationToken?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    PhoneVerificationOtp?: PhoneVerificationOtpUpdateManyWithoutUserNestedInput
    PasswordResetToken?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationSettingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    accountStatus?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    vehicles?: VehicleUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    userPaymentMethods?: UserPaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    parkingPasses?: ParkingPassUncheckedUpdateManyWithoutUserNestedInput
    placeRatings?: PlaceRatingUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    EmailVerificationToken?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    PhoneVerificationOtp?: PhoneVerificationOtpUncheckedUpdateManyWithoutUserNestedInput
    PasswordResetToken?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    username: string
    email: string
    passwordHash: string
    phoneNumber?: string | null
    accountType: string
    emailVerified?: boolean
    phoneVerified?: boolean
    accountStatus?: string
    googleId?: string | null
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    vehicles?: VehicleCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    userPaymentMethods?: UserPaymentMethodCreateNestedManyWithoutUserInput
    parkingPasses?: ParkingPassCreateNestedManyWithoutUserInput
    placeRatings?: PlaceRatingCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    EmailVerificationToken?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    PhoneVerificationOtp?: PhoneVerificationOtpCreateNestedManyWithoutUserInput
    PasswordResetToken?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    phoneNumber?: string | null
    accountType: string
    emailVerified?: boolean
    phoneVerified?: boolean
    accountStatus?: string
    googleId?: string | null
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    vehicles?: VehicleUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    userPaymentMethods?: UserPaymentMethodUncheckedCreateNestedManyWithoutUserInput
    parkingPasses?: ParkingPassUncheckedCreateNestedManyWithoutUserInput
    placeRatings?: PlaceRatingUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    EmailVerificationToken?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    PhoneVerificationOtp?: PhoneVerificationOtpUncheckedCreateNestedManyWithoutUserInput
    PasswordResetToken?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type BookingCreateWithoutNotificationsInput = {
    bookingReference: string
    bookingTime?: Date | string
    scheduledEntry: Date | string
    scheduledExit: Date | string
    actualEntry?: Date | string | null
    actualExit?: Date | string | null
    qrCode?: string | null
    bookingStatus: string
    estimatedPrice: Decimal | DecimalJsLike | number | string
    finalPrice?: Decimal | DecimalJsLike | number | string | null
    cancellationReason?: string | null
    cancellationTimeMinutes?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutBookingsInput
    vehicle: VehicleCreateNestedOneWithoutBookingsInput
    parkingSlot: ParkingSlotCreateNestedOneWithoutBookingsInput
    promoCode?: PromoCodeCreateNestedOneWithoutBookingsInput
    bookingStatusLogs?: BookingStatusLogCreateNestedManyWithoutBookingInput
    bookingPayment?: BookingPaymentCreateNestedOneWithoutBookingInput
    accessLogs?: AccessLogCreateNestedManyWithoutBookingInput
    bookingExtensions?: BookingExtensionCreateNestedManyWithoutBookingInput
    placeRatings?: PlaceRatingCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutNotificationsInput = {
    id?: number
    userId: number
    vehicleId: number
    slotId: number
    promoCodeId?: number | null
    bookingReference: string
    bookingTime?: Date | string
    scheduledEntry: Date | string
    scheduledExit: Date | string
    actualEntry?: Date | string | null
    actualExit?: Date | string | null
    qrCode?: string | null
    bookingStatus: string
    estimatedPrice: Decimal | DecimalJsLike | number | string
    finalPrice?: Decimal | DecimalJsLike | number | string | null
    cancellationReason?: string | null
    cancellationTimeMinutes?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    bookingStatusLogs?: BookingStatusLogUncheckedCreateNestedManyWithoutBookingInput
    bookingPayment?: BookingPaymentUncheckedCreateNestedOneWithoutBookingInput
    accessLogs?: AccessLogUncheckedCreateNestedManyWithoutBookingInput
    bookingExtensions?: BookingExtensionUncheckedCreateNestedManyWithoutBookingInput
    placeRatings?: PlaceRatingUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutNotificationsInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutNotificationsInput, BookingUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    accountStatus?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    vehicles?: VehicleUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    userPaymentMethods?: UserPaymentMethodUpdateManyWithoutUserNestedInput
    parkingPasses?: ParkingPassUpdateManyWithoutUserNestedInput
    placeRatings?: PlaceRatingUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    EmailVerificationToken?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    PhoneVerificationOtp?: PhoneVerificationOtpUpdateManyWithoutUserNestedInput
    PasswordResetToken?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    accountStatus?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    vehicles?: VehicleUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    userPaymentMethods?: UserPaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    parkingPasses?: ParkingPassUncheckedUpdateManyWithoutUserNestedInput
    placeRatings?: PlaceRatingUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    EmailVerificationToken?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    PhoneVerificationOtp?: PhoneVerificationOtpUncheckedUpdateManyWithoutUserNestedInput
    PasswordResetToken?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BookingUpsertWithoutNotificationsInput = {
    update: XOR<BookingUpdateWithoutNotificationsInput, BookingUncheckedUpdateWithoutNotificationsInput>
    create: XOR<BookingCreateWithoutNotificationsInput, BookingUncheckedCreateWithoutNotificationsInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutNotificationsInput, BookingUncheckedUpdateWithoutNotificationsInput>
  }

  export type BookingUpdateWithoutNotificationsInput = {
    bookingReference?: StringFieldUpdateOperationsInput | string
    bookingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledExit?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualExit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    bookingStatus?: StringFieldUpdateOperationsInput | string
    estimatedPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutBookingsNestedInput
    parkingSlot?: ParkingSlotUpdateOneRequiredWithoutBookingsNestedInput
    promoCode?: PromoCodeUpdateOneWithoutBookingsNestedInput
    bookingStatusLogs?: BookingStatusLogUpdateManyWithoutBookingNestedInput
    bookingPayment?: BookingPaymentUpdateOneWithoutBookingNestedInput
    accessLogs?: AccessLogUpdateManyWithoutBookingNestedInput
    bookingExtensions?: BookingExtensionUpdateManyWithoutBookingNestedInput
    placeRatings?: PlaceRatingUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    slotId?: IntFieldUpdateOperationsInput | number
    promoCodeId?: NullableIntFieldUpdateOperationsInput | number | null
    bookingReference?: StringFieldUpdateOperationsInput | string
    bookingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledExit?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualExit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    bookingStatus?: StringFieldUpdateOperationsInput | string
    estimatedPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookingStatusLogs?: BookingStatusLogUncheckedUpdateManyWithoutBookingNestedInput
    bookingPayment?: BookingPaymentUncheckedUpdateOneWithoutBookingNestedInput
    accessLogs?: AccessLogUncheckedUpdateManyWithoutBookingNestedInput
    bookingExtensions?: BookingExtensionUncheckedUpdateManyWithoutBookingNestedInput
    placeRatings?: PlaceRatingUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type PlaceCreateWithoutPlaceRatingsInput = {
    name: string
    image?: string | null
    placeType: string
    address: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    contactNumber?: string | null
    email?: string | null
    description?: string | null
    totalCapacity: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    parkingZones?: ParkingZoneCreateNestedManyWithoutPlaceInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutPlaceInput
    parkingPasses?: ParkingPassCreateNestedManyWithoutPlaceInput
    operatingHours?: OperatingHourCreateNestedManyWithoutPlaceInput
    placeAdmins?: PlaceAdminCreateNestedManyWithoutPlaceInput
  }

  export type PlaceUncheckedCreateWithoutPlaceRatingsInput = {
    id?: number
    name: string
    image?: string | null
    placeType: string
    address: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    contactNumber?: string | null
    email?: string | null
    description?: string | null
    totalCapacity: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    parkingZones?: ParkingZoneUncheckedCreateNestedManyWithoutPlaceInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutPlaceInput
    parkingPasses?: ParkingPassUncheckedCreateNestedManyWithoutPlaceInput
    operatingHours?: OperatingHourUncheckedCreateNestedManyWithoutPlaceInput
    placeAdmins?: PlaceAdminUncheckedCreateNestedManyWithoutPlaceInput
  }

  export type PlaceCreateOrConnectWithoutPlaceRatingsInput = {
    where: PlaceWhereUniqueInput
    create: XOR<PlaceCreateWithoutPlaceRatingsInput, PlaceUncheckedCreateWithoutPlaceRatingsInput>
  }

  export type UserCreateWithoutPlaceRatingsInput = {
    username: string
    email: string
    passwordHash: string
    phoneNumber?: string | null
    accountType: string
    emailVerified?: boolean
    phoneVerified?: boolean
    accountStatus?: string
    googleId?: string | null
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    vehicles?: VehicleCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    userPaymentMethods?: UserPaymentMethodCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    parkingPasses?: ParkingPassCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    EmailVerificationToken?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    PhoneVerificationOtp?: PhoneVerificationOtpCreateNestedManyWithoutUserInput
    PasswordResetToken?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPlaceRatingsInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    phoneNumber?: string | null
    accountType: string
    emailVerified?: boolean
    phoneVerified?: boolean
    accountStatus?: string
    googleId?: string | null
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    vehicles?: VehicleUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    userPaymentMethods?: UserPaymentMethodUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    parkingPasses?: ParkingPassUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    EmailVerificationToken?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    PhoneVerificationOtp?: PhoneVerificationOtpUncheckedCreateNestedManyWithoutUserInput
    PasswordResetToken?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPlaceRatingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPlaceRatingsInput, UserUncheckedCreateWithoutPlaceRatingsInput>
  }

  export type BookingCreateWithoutPlaceRatingsInput = {
    bookingReference: string
    bookingTime?: Date | string
    scheduledEntry: Date | string
    scheduledExit: Date | string
    actualEntry?: Date | string | null
    actualExit?: Date | string | null
    qrCode?: string | null
    bookingStatus: string
    estimatedPrice: Decimal | DecimalJsLike | number | string
    finalPrice?: Decimal | DecimalJsLike | number | string | null
    cancellationReason?: string | null
    cancellationTimeMinutes?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutBookingsInput
    vehicle: VehicleCreateNestedOneWithoutBookingsInput
    parkingSlot: ParkingSlotCreateNestedOneWithoutBookingsInput
    promoCode?: PromoCodeCreateNestedOneWithoutBookingsInput
    bookingStatusLogs?: BookingStatusLogCreateNestedManyWithoutBookingInput
    bookingPayment?: BookingPaymentCreateNestedOneWithoutBookingInput
    accessLogs?: AccessLogCreateNestedManyWithoutBookingInput
    bookingExtensions?: BookingExtensionCreateNestedManyWithoutBookingInput
    notifications?: NotificationCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutPlaceRatingsInput = {
    id?: number
    userId: number
    vehicleId: number
    slotId: number
    promoCodeId?: number | null
    bookingReference: string
    bookingTime?: Date | string
    scheduledEntry: Date | string
    scheduledExit: Date | string
    actualEntry?: Date | string | null
    actualExit?: Date | string | null
    qrCode?: string | null
    bookingStatus: string
    estimatedPrice: Decimal | DecimalJsLike | number | string
    finalPrice?: Decimal | DecimalJsLike | number | string | null
    cancellationReason?: string | null
    cancellationTimeMinutes?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    bookingStatusLogs?: BookingStatusLogUncheckedCreateNestedManyWithoutBookingInput
    bookingPayment?: BookingPaymentUncheckedCreateNestedOneWithoutBookingInput
    accessLogs?: AccessLogUncheckedCreateNestedManyWithoutBookingInput
    bookingExtensions?: BookingExtensionUncheckedCreateNestedManyWithoutBookingInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutPlaceRatingsInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutPlaceRatingsInput, BookingUncheckedCreateWithoutPlaceRatingsInput>
  }

  export type PlaceUpsertWithoutPlaceRatingsInput = {
    update: XOR<PlaceUpdateWithoutPlaceRatingsInput, PlaceUncheckedUpdateWithoutPlaceRatingsInput>
    create: XOR<PlaceCreateWithoutPlaceRatingsInput, PlaceUncheckedCreateWithoutPlaceRatingsInput>
    where?: PlaceWhereInput
  }

  export type PlaceUpdateToOneWithWhereWithoutPlaceRatingsInput = {
    where?: PlaceWhereInput
    data: XOR<PlaceUpdateWithoutPlaceRatingsInput, PlaceUncheckedUpdateWithoutPlaceRatingsInput>
  }

  export type PlaceUpdateWithoutPlaceRatingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    placeType?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalCapacity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parkingZones?: ParkingZoneUpdateManyWithoutPlaceNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutPlaceNestedInput
    parkingPasses?: ParkingPassUpdateManyWithoutPlaceNestedInput
    operatingHours?: OperatingHourUpdateManyWithoutPlaceNestedInput
    placeAdmins?: PlaceAdminUpdateManyWithoutPlaceNestedInput
  }

  export type PlaceUncheckedUpdateWithoutPlaceRatingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    placeType?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalCapacity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parkingZones?: ParkingZoneUncheckedUpdateManyWithoutPlaceNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutPlaceNestedInput
    parkingPasses?: ParkingPassUncheckedUpdateManyWithoutPlaceNestedInput
    operatingHours?: OperatingHourUncheckedUpdateManyWithoutPlaceNestedInput
    placeAdmins?: PlaceAdminUncheckedUpdateManyWithoutPlaceNestedInput
  }

  export type UserUpsertWithoutPlaceRatingsInput = {
    update: XOR<UserUpdateWithoutPlaceRatingsInput, UserUncheckedUpdateWithoutPlaceRatingsInput>
    create: XOR<UserCreateWithoutPlaceRatingsInput, UserUncheckedCreateWithoutPlaceRatingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPlaceRatingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPlaceRatingsInput, UserUncheckedUpdateWithoutPlaceRatingsInput>
  }

  export type UserUpdateWithoutPlaceRatingsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    accountStatus?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    vehicles?: VehicleUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    userPaymentMethods?: UserPaymentMethodUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    parkingPasses?: ParkingPassUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    EmailVerificationToken?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    PhoneVerificationOtp?: PhoneVerificationOtpUpdateManyWithoutUserNestedInput
    PasswordResetToken?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPlaceRatingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    accountStatus?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    vehicles?: VehicleUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    userPaymentMethods?: UserPaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    parkingPasses?: ParkingPassUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    EmailVerificationToken?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    PhoneVerificationOtp?: PhoneVerificationOtpUncheckedUpdateManyWithoutUserNestedInput
    PasswordResetToken?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BookingUpsertWithoutPlaceRatingsInput = {
    update: XOR<BookingUpdateWithoutPlaceRatingsInput, BookingUncheckedUpdateWithoutPlaceRatingsInput>
    create: XOR<BookingCreateWithoutPlaceRatingsInput, BookingUncheckedCreateWithoutPlaceRatingsInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutPlaceRatingsInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutPlaceRatingsInput, BookingUncheckedUpdateWithoutPlaceRatingsInput>
  }

  export type BookingUpdateWithoutPlaceRatingsInput = {
    bookingReference?: StringFieldUpdateOperationsInput | string
    bookingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledExit?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualExit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    bookingStatus?: StringFieldUpdateOperationsInput | string
    estimatedPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutBookingsNestedInput
    parkingSlot?: ParkingSlotUpdateOneRequiredWithoutBookingsNestedInput
    promoCode?: PromoCodeUpdateOneWithoutBookingsNestedInput
    bookingStatusLogs?: BookingStatusLogUpdateManyWithoutBookingNestedInput
    bookingPayment?: BookingPaymentUpdateOneWithoutBookingNestedInput
    accessLogs?: AccessLogUpdateManyWithoutBookingNestedInput
    bookingExtensions?: BookingExtensionUpdateManyWithoutBookingNestedInput
    notifications?: NotificationUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutPlaceRatingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    slotId?: IntFieldUpdateOperationsInput | number
    promoCodeId?: NullableIntFieldUpdateOperationsInput | number | null
    bookingReference?: StringFieldUpdateOperationsInput | string
    bookingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledExit?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualExit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    bookingStatus?: StringFieldUpdateOperationsInput | string
    estimatedPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookingStatusLogs?: BookingStatusLogUncheckedUpdateManyWithoutBookingNestedInput
    bookingPayment?: BookingPaymentUncheckedUpdateOneWithoutBookingNestedInput
    accessLogs?: AccessLogUncheckedUpdateManyWithoutBookingNestedInput
    bookingExtensions?: BookingExtensionUncheckedUpdateManyWithoutBookingNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type PlaceCreateWithoutOperatingHoursInput = {
    name: string
    image?: string | null
    placeType: string
    address: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    contactNumber?: string | null
    email?: string | null
    description?: string | null
    totalCapacity: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    parkingZones?: ParkingZoneCreateNestedManyWithoutPlaceInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutPlaceInput
    parkingPasses?: ParkingPassCreateNestedManyWithoutPlaceInput
    placeAdmins?: PlaceAdminCreateNestedManyWithoutPlaceInput
    placeRatings?: PlaceRatingCreateNestedManyWithoutPlaceInput
  }

  export type PlaceUncheckedCreateWithoutOperatingHoursInput = {
    id?: number
    name: string
    image?: string | null
    placeType: string
    address: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    contactNumber?: string | null
    email?: string | null
    description?: string | null
    totalCapacity: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    parkingZones?: ParkingZoneUncheckedCreateNestedManyWithoutPlaceInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutPlaceInput
    parkingPasses?: ParkingPassUncheckedCreateNestedManyWithoutPlaceInput
    placeAdmins?: PlaceAdminUncheckedCreateNestedManyWithoutPlaceInput
    placeRatings?: PlaceRatingUncheckedCreateNestedManyWithoutPlaceInput
  }

  export type PlaceCreateOrConnectWithoutOperatingHoursInput = {
    where: PlaceWhereUniqueInput
    create: XOR<PlaceCreateWithoutOperatingHoursInput, PlaceUncheckedCreateWithoutOperatingHoursInput>
  }

  export type PlaceUpsertWithoutOperatingHoursInput = {
    update: XOR<PlaceUpdateWithoutOperatingHoursInput, PlaceUncheckedUpdateWithoutOperatingHoursInput>
    create: XOR<PlaceCreateWithoutOperatingHoursInput, PlaceUncheckedCreateWithoutOperatingHoursInput>
    where?: PlaceWhereInput
  }

  export type PlaceUpdateToOneWithWhereWithoutOperatingHoursInput = {
    where?: PlaceWhereInput
    data: XOR<PlaceUpdateWithoutOperatingHoursInput, PlaceUncheckedUpdateWithoutOperatingHoursInput>
  }

  export type PlaceUpdateWithoutOperatingHoursInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    placeType?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalCapacity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parkingZones?: ParkingZoneUpdateManyWithoutPlaceNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutPlaceNestedInput
    parkingPasses?: ParkingPassUpdateManyWithoutPlaceNestedInput
    placeAdmins?: PlaceAdminUpdateManyWithoutPlaceNestedInput
    placeRatings?: PlaceRatingUpdateManyWithoutPlaceNestedInput
  }

  export type PlaceUncheckedUpdateWithoutOperatingHoursInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    placeType?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalCapacity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parkingZones?: ParkingZoneUncheckedUpdateManyWithoutPlaceNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutPlaceNestedInput
    parkingPasses?: ParkingPassUncheckedUpdateManyWithoutPlaceNestedInput
    placeAdmins?: PlaceAdminUncheckedUpdateManyWithoutPlaceNestedInput
    placeRatings?: PlaceRatingUncheckedUpdateManyWithoutPlaceNestedInput
  }

  export type PlaceCreateWithoutPlaceAdminsInput = {
    name: string
    image?: string | null
    placeType: string
    address: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    contactNumber?: string | null
    email?: string | null
    description?: string | null
    totalCapacity: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    parkingZones?: ParkingZoneCreateNestedManyWithoutPlaceInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutPlaceInput
    parkingPasses?: ParkingPassCreateNestedManyWithoutPlaceInput
    operatingHours?: OperatingHourCreateNestedManyWithoutPlaceInput
    placeRatings?: PlaceRatingCreateNestedManyWithoutPlaceInput
  }

  export type PlaceUncheckedCreateWithoutPlaceAdminsInput = {
    id?: number
    name: string
    image?: string | null
    placeType: string
    address: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    contactNumber?: string | null
    email?: string | null
    description?: string | null
    totalCapacity: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    parkingZones?: ParkingZoneUncheckedCreateNestedManyWithoutPlaceInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutPlaceInput
    parkingPasses?: ParkingPassUncheckedCreateNestedManyWithoutPlaceInput
    operatingHours?: OperatingHourUncheckedCreateNestedManyWithoutPlaceInput
    placeRatings?: PlaceRatingUncheckedCreateNestedManyWithoutPlaceInput
  }

  export type PlaceCreateOrConnectWithoutPlaceAdminsInput = {
    where: PlaceWhereUniqueInput
    create: XOR<PlaceCreateWithoutPlaceAdminsInput, PlaceUncheckedCreateWithoutPlaceAdminsInput>
  }

  export type PlaceUpsertWithoutPlaceAdminsInput = {
    update: XOR<PlaceUpdateWithoutPlaceAdminsInput, PlaceUncheckedUpdateWithoutPlaceAdminsInput>
    create: XOR<PlaceCreateWithoutPlaceAdminsInput, PlaceUncheckedCreateWithoutPlaceAdminsInput>
    where?: PlaceWhereInput
  }

  export type PlaceUpdateToOneWithWhereWithoutPlaceAdminsInput = {
    where?: PlaceWhereInput
    data: XOR<PlaceUpdateWithoutPlaceAdminsInput, PlaceUncheckedUpdateWithoutPlaceAdminsInput>
  }

  export type PlaceUpdateWithoutPlaceAdminsInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    placeType?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalCapacity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parkingZones?: ParkingZoneUpdateManyWithoutPlaceNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutPlaceNestedInput
    parkingPasses?: ParkingPassUpdateManyWithoutPlaceNestedInput
    operatingHours?: OperatingHourUpdateManyWithoutPlaceNestedInput
    placeRatings?: PlaceRatingUpdateManyWithoutPlaceNestedInput
  }

  export type PlaceUncheckedUpdateWithoutPlaceAdminsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    placeType?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalCapacity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parkingZones?: ParkingZoneUncheckedUpdateManyWithoutPlaceNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutPlaceNestedInput
    parkingPasses?: ParkingPassUncheckedUpdateManyWithoutPlaceNestedInput
    operatingHours?: OperatingHourUncheckedUpdateManyWithoutPlaceNestedInput
    placeRatings?: PlaceRatingUncheckedUpdateManyWithoutPlaceNestedInput
  }

  export type UserCreateWithoutEmailVerificationTokenInput = {
    username: string
    email: string
    passwordHash: string
    phoneNumber?: string | null
    accountType: string
    emailVerified?: boolean
    phoneVerified?: boolean
    accountStatus?: string
    googleId?: string | null
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    vehicles?: VehicleCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    userPaymentMethods?: UserPaymentMethodCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    parkingPasses?: ParkingPassCreateNestedManyWithoutUserInput
    placeRatings?: PlaceRatingCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    PhoneVerificationOtp?: PhoneVerificationOtpCreateNestedManyWithoutUserInput
    PasswordResetToken?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEmailVerificationTokenInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    phoneNumber?: string | null
    accountType: string
    emailVerified?: boolean
    phoneVerified?: boolean
    accountStatus?: string
    googleId?: string | null
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    vehicles?: VehicleUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    userPaymentMethods?: UserPaymentMethodUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    parkingPasses?: ParkingPassUncheckedCreateNestedManyWithoutUserInput
    placeRatings?: PlaceRatingUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    PhoneVerificationOtp?: PhoneVerificationOtpUncheckedCreateNestedManyWithoutUserInput
    PasswordResetToken?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEmailVerificationTokenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmailVerificationTokenInput, UserUncheckedCreateWithoutEmailVerificationTokenInput>
  }

  export type UserUpsertWithoutEmailVerificationTokenInput = {
    update: XOR<UserUpdateWithoutEmailVerificationTokenInput, UserUncheckedUpdateWithoutEmailVerificationTokenInput>
    create: XOR<UserCreateWithoutEmailVerificationTokenInput, UserUncheckedCreateWithoutEmailVerificationTokenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmailVerificationTokenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmailVerificationTokenInput, UserUncheckedUpdateWithoutEmailVerificationTokenInput>
  }

  export type UserUpdateWithoutEmailVerificationTokenInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    accountStatus?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    vehicles?: VehicleUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    userPaymentMethods?: UserPaymentMethodUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    parkingPasses?: ParkingPassUpdateManyWithoutUserNestedInput
    placeRatings?: PlaceRatingUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    PhoneVerificationOtp?: PhoneVerificationOtpUpdateManyWithoutUserNestedInput
    PasswordResetToken?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEmailVerificationTokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    accountStatus?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    vehicles?: VehicleUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    userPaymentMethods?: UserPaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    parkingPasses?: ParkingPassUncheckedUpdateManyWithoutUserNestedInput
    placeRatings?: PlaceRatingUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    PhoneVerificationOtp?: PhoneVerificationOtpUncheckedUpdateManyWithoutUserNestedInput
    PasswordResetToken?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPhoneVerificationOtpInput = {
    username: string
    email: string
    passwordHash: string
    phoneNumber?: string | null
    accountType: string
    emailVerified?: boolean
    phoneVerified?: boolean
    accountStatus?: string
    googleId?: string | null
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    vehicles?: VehicleCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    userPaymentMethods?: UserPaymentMethodCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    parkingPasses?: ParkingPassCreateNestedManyWithoutUserInput
    placeRatings?: PlaceRatingCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    EmailVerificationToken?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    PasswordResetToken?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPhoneVerificationOtpInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    phoneNumber?: string | null
    accountType: string
    emailVerified?: boolean
    phoneVerified?: boolean
    accountStatus?: string
    googleId?: string | null
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    vehicles?: VehicleUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    userPaymentMethods?: UserPaymentMethodUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    parkingPasses?: ParkingPassUncheckedCreateNestedManyWithoutUserInput
    placeRatings?: PlaceRatingUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    EmailVerificationToken?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    PasswordResetToken?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPhoneVerificationOtpInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPhoneVerificationOtpInput, UserUncheckedCreateWithoutPhoneVerificationOtpInput>
  }

  export type UserUpsertWithoutPhoneVerificationOtpInput = {
    update: XOR<UserUpdateWithoutPhoneVerificationOtpInput, UserUncheckedUpdateWithoutPhoneVerificationOtpInput>
    create: XOR<UserCreateWithoutPhoneVerificationOtpInput, UserUncheckedCreateWithoutPhoneVerificationOtpInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPhoneVerificationOtpInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPhoneVerificationOtpInput, UserUncheckedUpdateWithoutPhoneVerificationOtpInput>
  }

  export type UserUpdateWithoutPhoneVerificationOtpInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    accountStatus?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    vehicles?: VehicleUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    userPaymentMethods?: UserPaymentMethodUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    parkingPasses?: ParkingPassUpdateManyWithoutUserNestedInput
    placeRatings?: PlaceRatingUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    EmailVerificationToken?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    PasswordResetToken?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPhoneVerificationOtpInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    accountStatus?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    vehicles?: VehicleUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    userPaymentMethods?: UserPaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    parkingPasses?: ParkingPassUncheckedUpdateManyWithoutUserNestedInput
    placeRatings?: PlaceRatingUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    EmailVerificationToken?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    PasswordResetToken?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPasswordResetTokenInput = {
    username: string
    email: string
    passwordHash: string
    phoneNumber?: string | null
    accountType: string
    emailVerified?: boolean
    phoneVerified?: boolean
    accountStatus?: string
    googleId?: string | null
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    vehicles?: VehicleCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    userPaymentMethods?: UserPaymentMethodCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    parkingPasses?: ParkingPassCreateNestedManyWithoutUserInput
    placeRatings?: PlaceRatingCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    EmailVerificationToken?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    PhoneVerificationOtp?: PhoneVerificationOtpCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPasswordResetTokenInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    phoneNumber?: string | null
    accountType: string
    emailVerified?: boolean
    phoneVerified?: boolean
    accountStatus?: string
    googleId?: string | null
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    vehicles?: VehicleUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    userPaymentMethods?: UserPaymentMethodUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    parkingPasses?: ParkingPassUncheckedCreateNestedManyWithoutUserInput
    placeRatings?: PlaceRatingUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    EmailVerificationToken?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    PhoneVerificationOtp?: PhoneVerificationOtpUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPasswordResetTokenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasswordResetTokenInput, UserUncheckedCreateWithoutPasswordResetTokenInput>
  }

  export type UserUpsertWithoutPasswordResetTokenInput = {
    update: XOR<UserUpdateWithoutPasswordResetTokenInput, UserUncheckedUpdateWithoutPasswordResetTokenInput>
    create: XOR<UserCreateWithoutPasswordResetTokenInput, UserUncheckedCreateWithoutPasswordResetTokenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPasswordResetTokenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPasswordResetTokenInput, UserUncheckedUpdateWithoutPasswordResetTokenInput>
  }

  export type UserUpdateWithoutPasswordResetTokenInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    accountStatus?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    vehicles?: VehicleUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    userPaymentMethods?: UserPaymentMethodUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    parkingPasses?: ParkingPassUpdateManyWithoutUserNestedInput
    placeRatings?: PlaceRatingUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    EmailVerificationToken?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    PhoneVerificationOtp?: PhoneVerificationOtpUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPasswordResetTokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    accountStatus?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    vehicles?: VehicleUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    userPaymentMethods?: UserPaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    parkingPasses?: ParkingPassUncheckedUpdateManyWithoutUserNestedInput
    placeRatings?: PlaceRatingUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    EmailVerificationToken?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    PhoneVerificationOtp?: PhoneVerificationOtpUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VehicleCreateManyUserInput = {
    id?: number
    licensePlate: string
    vehicleType: string
    brand?: string | null
    model?: string | null
    color?: string | null
    rfidTag?: string | null
    length?: Decimal | DecimalJsLike | number | string | null
    width?: Decimal | DecimalJsLike | number | string | null
    height?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type BookingCreateManyUserInput = {
    id?: number
    vehicleId: number
    slotId: number
    promoCodeId?: number | null
    bookingReference: string
    bookingTime?: Date | string
    scheduledEntry: Date | string
    scheduledExit: Date | string
    actualEntry?: Date | string | null
    actualExit?: Date | string | null
    qrCode?: string | null
    bookingStatus: string
    estimatedPrice: Decimal | DecimalJsLike | number | string
    finalPrice?: Decimal | DecimalJsLike | number | string | null
    cancellationReason?: string | null
    cancellationTimeMinutes?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type UserPaymentMethodCreateManyUserInput = {
    id?: number
    paymentMethodId: number
    tokenReference: string
    maskedInfo?: string | null
    expiryInfo?: string | null
    isDefault?: boolean
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type NotificationCreateManyUserInput = {
    id?: number
    bookingId?: number | null
    notificationType: string
    channel: string
    content: string
    isRead?: boolean
    sentTime?: Date | string
    readTime?: Date | string | null
    createdAt?: Date | string
  }

  export type ParkingPassCreateManyUserInput = {
    id?: number
    placeId: number
    passType: string
    passReference?: string | null
    startDate: Date | string
    endDate: Date | string
    price: Decimal | DecimalJsLike | number | string
    status: string
    autoRenew?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type PlaceRatingCreateManyUserInput = {
    id?: number
    placeId: number
    bookingId: number
    ratingScore: Decimal | DecimalJsLike | number | string
    reviewComment?: string | null
    ratingDate?: Date | string
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type UserSessionCreateManyUserInput = {
    id?: number
    token: string
    deviceInfo?: string | null
    ipAddress?: string | null
    lastActivity?: Date | string
    expiryTime: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type EmailVerificationTokenCreateManyUserInput = {
    id?: number
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type PhoneVerificationOtpCreateManyUserInput = {
    id?: number
    phoneNumber: string
    otp: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type PasswordResetTokenCreateManyUserInput = {
    id?: number
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type VehicleUpdateWithoutUserInput = {
    licensePlate?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    rfidTag?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    width?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookings?: BookingUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    licensePlate?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    rfidTag?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    width?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookings?: BookingUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    licensePlate?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    rfidTag?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    width?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BookingUpdateWithoutUserInput = {
    bookingReference?: StringFieldUpdateOperationsInput | string
    bookingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledExit?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualExit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    bookingStatus?: StringFieldUpdateOperationsInput | string
    estimatedPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicle?: VehicleUpdateOneRequiredWithoutBookingsNestedInput
    parkingSlot?: ParkingSlotUpdateOneRequiredWithoutBookingsNestedInput
    promoCode?: PromoCodeUpdateOneWithoutBookingsNestedInput
    bookingStatusLogs?: BookingStatusLogUpdateManyWithoutBookingNestedInput
    bookingPayment?: BookingPaymentUpdateOneWithoutBookingNestedInput
    accessLogs?: AccessLogUpdateManyWithoutBookingNestedInput
    bookingExtensions?: BookingExtensionUpdateManyWithoutBookingNestedInput
    placeRatings?: PlaceRatingUpdateManyWithoutBookingNestedInput
    notifications?: NotificationUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    slotId?: IntFieldUpdateOperationsInput | number
    promoCodeId?: NullableIntFieldUpdateOperationsInput | number | null
    bookingReference?: StringFieldUpdateOperationsInput | string
    bookingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledExit?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualExit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    bookingStatus?: StringFieldUpdateOperationsInput | string
    estimatedPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookingStatusLogs?: BookingStatusLogUncheckedUpdateManyWithoutBookingNestedInput
    bookingPayment?: BookingPaymentUncheckedUpdateOneWithoutBookingNestedInput
    accessLogs?: AccessLogUncheckedUpdateManyWithoutBookingNestedInput
    bookingExtensions?: BookingExtensionUncheckedUpdateManyWithoutBookingNestedInput
    placeRatings?: PlaceRatingUncheckedUpdateManyWithoutBookingNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    slotId?: IntFieldUpdateOperationsInput | number
    promoCodeId?: NullableIntFieldUpdateOperationsInput | number | null
    bookingReference?: StringFieldUpdateOperationsInput | string
    bookingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledExit?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualExit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    bookingStatus?: StringFieldUpdateOperationsInput | string
    estimatedPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserPaymentMethodUpdateWithoutUserInput = {
    tokenReference?: StringFieldUpdateOperationsInput | string
    maskedInfo?: NullableStringFieldUpdateOperationsInput | string | null
    expiryInfo?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: PaymentMethodUpdateOneRequiredWithoutUserPaymentMethodsNestedInput
  }

  export type UserPaymentMethodUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    paymentMethodId?: IntFieldUpdateOperationsInput | number
    tokenReference?: StringFieldUpdateOperationsInput | string
    maskedInfo?: NullableStringFieldUpdateOperationsInput | string | null
    expiryInfo?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserPaymentMethodUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    paymentMethodId?: IntFieldUpdateOperationsInput | number
    tokenReference?: StringFieldUpdateOperationsInput | string
    maskedInfo?: NullableStringFieldUpdateOperationsInput | string | null
    expiryInfo?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUpdateWithoutUserInput = {
    notificationType?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    readTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: NullableIntFieldUpdateOperationsInput | number | null
    notificationType?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    readTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: NullableIntFieldUpdateOperationsInput | number | null
    notificationType?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    readTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParkingPassUpdateWithoutUserInput = {
    passType?: StringFieldUpdateOperationsInput | string
    passReference?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    place?: PlaceUpdateOneRequiredWithoutParkingPassesNestedInput
    parkingPassPayments?: ParkingPassPaymentUpdateManyWithoutParkingPassNestedInput
  }

  export type ParkingPassUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    placeId?: IntFieldUpdateOperationsInput | number
    passType?: StringFieldUpdateOperationsInput | string
    passReference?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parkingPassPayments?: ParkingPassPaymentUncheckedUpdateManyWithoutParkingPassNestedInput
  }

  export type ParkingPassUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    placeId?: IntFieldUpdateOperationsInput | number
    passType?: StringFieldUpdateOperationsInput | string
    passReference?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlaceRatingUpdateWithoutUserInput = {
    ratingScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    ratingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    place?: PlaceUpdateOneRequiredWithoutPlaceRatingsNestedInput
    booking?: BookingUpdateOneRequiredWithoutPlaceRatingsNestedInput
  }

  export type PlaceRatingUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    placeId?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    ratingScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    ratingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlaceRatingUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    placeId?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    ratingScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    ratingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserSessionUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserSessionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserSessionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmailVerificationTokenUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailVerificationTokenUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailVerificationTokenUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhoneVerificationOtpUpdateWithoutUserInput = {
    phoneNumber?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhoneVerificationOtpUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhoneVerificationOtpUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateManyVehicleInput = {
    id?: number
    userId: number
    slotId: number
    promoCodeId?: number | null
    bookingReference: string
    bookingTime?: Date | string
    scheduledEntry: Date | string
    scheduledExit: Date | string
    actualEntry?: Date | string | null
    actualExit?: Date | string | null
    qrCode?: string | null
    bookingStatus: string
    estimatedPrice: Decimal | DecimalJsLike | number | string
    finalPrice?: Decimal | DecimalJsLike | number | string | null
    cancellationReason?: string | null
    cancellationTimeMinutes?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type BookingUpdateWithoutVehicleInput = {
    bookingReference?: StringFieldUpdateOperationsInput | string
    bookingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledExit?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualExit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    bookingStatus?: StringFieldUpdateOperationsInput | string
    estimatedPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    parkingSlot?: ParkingSlotUpdateOneRequiredWithoutBookingsNestedInput
    promoCode?: PromoCodeUpdateOneWithoutBookingsNestedInput
    bookingStatusLogs?: BookingStatusLogUpdateManyWithoutBookingNestedInput
    bookingPayment?: BookingPaymentUpdateOneWithoutBookingNestedInput
    accessLogs?: AccessLogUpdateManyWithoutBookingNestedInput
    bookingExtensions?: BookingExtensionUpdateManyWithoutBookingNestedInput
    placeRatings?: PlaceRatingUpdateManyWithoutBookingNestedInput
    notifications?: NotificationUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutVehicleInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    slotId?: IntFieldUpdateOperationsInput | number
    promoCodeId?: NullableIntFieldUpdateOperationsInput | number | null
    bookingReference?: StringFieldUpdateOperationsInput | string
    bookingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledExit?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualExit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    bookingStatus?: StringFieldUpdateOperationsInput | string
    estimatedPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookingStatusLogs?: BookingStatusLogUncheckedUpdateManyWithoutBookingNestedInput
    bookingPayment?: BookingPaymentUncheckedUpdateOneWithoutBookingNestedInput
    accessLogs?: AccessLogUncheckedUpdateManyWithoutBookingNestedInput
    bookingExtensions?: BookingExtensionUncheckedUpdateManyWithoutBookingNestedInput
    placeRatings?: PlaceRatingUncheckedUpdateManyWithoutBookingNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutVehicleInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    slotId?: IntFieldUpdateOperationsInput | number
    promoCodeId?: NullableIntFieldUpdateOperationsInput | number | null
    bookingReference?: StringFieldUpdateOperationsInput | string
    bookingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledExit?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualExit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    bookingStatus?: StringFieldUpdateOperationsInput | string
    estimatedPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ParkingZoneCreateManyPlaceInput = {
    id?: number
    zoneName: string
    floorLevel?: string | null
    zoneType?: string | null
    totalSlots: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type TariffPlanCreateManyPlaceInput = {
    id?: number
    planName: string
    description?: string | null
    effectiveFrom: Date | string
    effectiveUntil?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type ParkingPassCreateManyPlaceInput = {
    id?: number
    userId: number
    passType: string
    passReference?: string | null
    startDate: Date | string
    endDate: Date | string
    price: Decimal | DecimalJsLike | number | string
    status: string
    autoRenew?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type OperatingHourCreateManyPlaceInput = {
    id?: number
    dayOfWeek: string
    openingTime?: Date | string | null
    closingTime?: Date | string | null
    is24hours?: boolean
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type PlaceAdminCreateManyPlaceInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    fullName: string
    role: string
    contactNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type PlaceRatingCreateManyPlaceInput = {
    id?: number
    userId: number
    bookingId: number
    ratingScore: Decimal | DecimalJsLike | number | string
    reviewComment?: string | null
    ratingDate?: Date | string
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type ParkingZoneUpdateWithoutPlaceInput = {
    zoneName?: StringFieldUpdateOperationsInput | string
    floorLevel?: NullableStringFieldUpdateOperationsInput | string | null
    zoneType?: NullableStringFieldUpdateOperationsInput | string | null
    totalSlots?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parkingSlots?: ParkingSlotUpdateManyWithoutParkingZoneNestedInput
  }

  export type ParkingZoneUncheckedUpdateWithoutPlaceInput = {
    id?: IntFieldUpdateOperationsInput | number
    zoneName?: StringFieldUpdateOperationsInput | string
    floorLevel?: NullableStringFieldUpdateOperationsInput | string | null
    zoneType?: NullableStringFieldUpdateOperationsInput | string | null
    totalSlots?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parkingSlots?: ParkingSlotUncheckedUpdateManyWithoutParkingZoneNestedInput
  }

  export type ParkingZoneUncheckedUpdateManyWithoutPlaceInput = {
    id?: IntFieldUpdateOperationsInput | number
    zoneName?: StringFieldUpdateOperationsInput | string
    floorLevel?: NullableStringFieldUpdateOperationsInput | string | null
    zoneType?: NullableStringFieldUpdateOperationsInput | string | null
    totalSlots?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TariffPlanUpdateWithoutPlaceInput = {
    planName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tariffRates?: TariffRateUpdateManyWithoutTariffPlanNestedInput
  }

  export type TariffPlanUncheckedUpdateWithoutPlaceInput = {
    id?: IntFieldUpdateOperationsInput | number
    planName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tariffRates?: TariffRateUncheckedUpdateManyWithoutTariffPlanNestedInput
  }

  export type TariffPlanUncheckedUpdateManyWithoutPlaceInput = {
    id?: IntFieldUpdateOperationsInput | number
    planName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ParkingPassUpdateWithoutPlaceInput = {
    passType?: StringFieldUpdateOperationsInput | string
    passReference?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutParkingPassesNestedInput
    parkingPassPayments?: ParkingPassPaymentUpdateManyWithoutParkingPassNestedInput
  }

  export type ParkingPassUncheckedUpdateWithoutPlaceInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    passType?: StringFieldUpdateOperationsInput | string
    passReference?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parkingPassPayments?: ParkingPassPaymentUncheckedUpdateManyWithoutParkingPassNestedInput
  }

  export type ParkingPassUncheckedUpdateManyWithoutPlaceInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    passType?: StringFieldUpdateOperationsInput | string
    passReference?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OperatingHourUpdateWithoutPlaceInput = {
    dayOfWeek?: StringFieldUpdateOperationsInput | string
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is24hours?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OperatingHourUncheckedUpdateWithoutPlaceInput = {
    id?: IntFieldUpdateOperationsInput | number
    dayOfWeek?: StringFieldUpdateOperationsInput | string
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is24hours?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OperatingHourUncheckedUpdateManyWithoutPlaceInput = {
    id?: IntFieldUpdateOperationsInput | number
    dayOfWeek?: StringFieldUpdateOperationsInput | string
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is24hours?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlaceAdminUpdateWithoutPlaceInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlaceAdminUncheckedUpdateWithoutPlaceInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlaceAdminUncheckedUpdateManyWithoutPlaceInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlaceRatingUpdateWithoutPlaceInput = {
    ratingScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    ratingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutPlaceRatingsNestedInput
    booking?: BookingUpdateOneRequiredWithoutPlaceRatingsNestedInput
  }

  export type PlaceRatingUncheckedUpdateWithoutPlaceInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    ratingScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    ratingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlaceRatingUncheckedUpdateManyWithoutPlaceInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    ratingScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    ratingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ParkingSlotCreateManyParkingZoneInput = {
    id?: number
    slotNumber: string
    slotType: string
    isReserved?: boolean
    isOccupied?: boolean
    isDisabledFriendly?: boolean
    hasEvCharger?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type ParkingSlotUpdateWithoutParkingZoneInput = {
    slotNumber?: StringFieldUpdateOperationsInput | string
    slotType?: StringFieldUpdateOperationsInput | string
    isReserved?: BoolFieldUpdateOperationsInput | boolean
    isOccupied?: BoolFieldUpdateOperationsInput | boolean
    isDisabledFriendly?: BoolFieldUpdateOperationsInput | boolean
    hasEvCharger?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slotAvailability?: SlotAvailabilityUpdateManyWithoutParkingSlotNestedInput
    bookings?: BookingUpdateManyWithoutParkingSlotNestedInput
  }

  export type ParkingSlotUncheckedUpdateWithoutParkingZoneInput = {
    id?: IntFieldUpdateOperationsInput | number
    slotNumber?: StringFieldUpdateOperationsInput | string
    slotType?: StringFieldUpdateOperationsInput | string
    isReserved?: BoolFieldUpdateOperationsInput | boolean
    isOccupied?: BoolFieldUpdateOperationsInput | boolean
    isDisabledFriendly?: BoolFieldUpdateOperationsInput | boolean
    hasEvCharger?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slotAvailability?: SlotAvailabilityUncheckedUpdateManyWithoutParkingSlotNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutParkingSlotNestedInput
  }

  export type ParkingSlotUncheckedUpdateManyWithoutParkingZoneInput = {
    id?: IntFieldUpdateOperationsInput | number
    slotNumber?: StringFieldUpdateOperationsInput | string
    slotType?: StringFieldUpdateOperationsInput | string
    isReserved?: BoolFieldUpdateOperationsInput | boolean
    isOccupied?: BoolFieldUpdateOperationsInput | boolean
    isDisabledFriendly?: BoolFieldUpdateOperationsInput | boolean
    hasEvCharger?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SlotAvailabilityCreateManyParkingSlotInput = {
    id?: number
    availableFrom: Date | string
    availableUntil: Date | string
    isBookable?: boolean
    statusReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type BookingCreateManyParkingSlotInput = {
    id?: number
    userId: number
    vehicleId: number
    promoCodeId?: number | null
    bookingReference: string
    bookingTime?: Date | string
    scheduledEntry: Date | string
    scheduledExit: Date | string
    actualEntry?: Date | string | null
    actualExit?: Date | string | null
    qrCode?: string | null
    bookingStatus: string
    estimatedPrice: Decimal | DecimalJsLike | number | string
    finalPrice?: Decimal | DecimalJsLike | number | string | null
    cancellationReason?: string | null
    cancellationTimeMinutes?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type SlotAvailabilityUpdateWithoutParkingSlotInput = {
    availableFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    availableUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    isBookable?: BoolFieldUpdateOperationsInput | boolean
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SlotAvailabilityUncheckedUpdateWithoutParkingSlotInput = {
    id?: IntFieldUpdateOperationsInput | number
    availableFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    availableUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    isBookable?: BoolFieldUpdateOperationsInput | boolean
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SlotAvailabilityUncheckedUpdateManyWithoutParkingSlotInput = {
    id?: IntFieldUpdateOperationsInput | number
    availableFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    availableUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    isBookable?: BoolFieldUpdateOperationsInput | boolean
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BookingUpdateWithoutParkingSlotInput = {
    bookingReference?: StringFieldUpdateOperationsInput | string
    bookingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledExit?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualExit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    bookingStatus?: StringFieldUpdateOperationsInput | string
    estimatedPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutBookingsNestedInput
    promoCode?: PromoCodeUpdateOneWithoutBookingsNestedInput
    bookingStatusLogs?: BookingStatusLogUpdateManyWithoutBookingNestedInput
    bookingPayment?: BookingPaymentUpdateOneWithoutBookingNestedInput
    accessLogs?: AccessLogUpdateManyWithoutBookingNestedInput
    bookingExtensions?: BookingExtensionUpdateManyWithoutBookingNestedInput
    placeRatings?: PlaceRatingUpdateManyWithoutBookingNestedInput
    notifications?: NotificationUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutParkingSlotInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    promoCodeId?: NullableIntFieldUpdateOperationsInput | number | null
    bookingReference?: StringFieldUpdateOperationsInput | string
    bookingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledExit?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualExit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    bookingStatus?: StringFieldUpdateOperationsInput | string
    estimatedPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookingStatusLogs?: BookingStatusLogUncheckedUpdateManyWithoutBookingNestedInput
    bookingPayment?: BookingPaymentUncheckedUpdateOneWithoutBookingNestedInput
    accessLogs?: AccessLogUncheckedUpdateManyWithoutBookingNestedInput
    bookingExtensions?: BookingExtensionUncheckedUpdateManyWithoutBookingNestedInput
    placeRatings?: PlaceRatingUncheckedUpdateManyWithoutBookingNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutParkingSlotInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    promoCodeId?: NullableIntFieldUpdateOperationsInput | number | null
    bookingReference?: StringFieldUpdateOperationsInput | string
    bookingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledExit?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualExit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    bookingStatus?: StringFieldUpdateOperationsInput | string
    estimatedPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TariffRateCreateManyTariffPlanInput = {
    id?: number
    vehicleType: string
    slotType: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    dayCategory?: string | null
    basePrice: Decimal | DecimalJsLike | number | string
    hourlyRate: Decimal | DecimalJsLike | number | string
    dayRate?: Decimal | DecimalJsLike | number | string | null
    minimumCharge?: Decimal | DecimalJsLike | number | string
    gracePeriodMinutes?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type TariffRateUpdateWithoutTariffPlanInput = {
    vehicleType?: StringFieldUpdateOperationsInput | string
    slotType?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dayCategory?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hourlyRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dayRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minimumCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gracePeriodMinutes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TariffRateUncheckedUpdateWithoutTariffPlanInput = {
    id?: IntFieldUpdateOperationsInput | number
    vehicleType?: StringFieldUpdateOperationsInput | string
    slotType?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dayCategory?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hourlyRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dayRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minimumCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gracePeriodMinutes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TariffRateUncheckedUpdateManyWithoutTariffPlanInput = {
    id?: IntFieldUpdateOperationsInput | number
    vehicleType?: StringFieldUpdateOperationsInput | string
    slotType?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dayCategory?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hourlyRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dayRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minimumCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gracePeriodMinutes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BookingStatusLogCreateManyBookingInput = {
    id?: number
    previousStatus: string
    newStatus: string
    changedBy: string
    reason?: string | null
    statusTime?: Date | string
    createdAt?: Date | string
  }

  export type AccessLogCreateManyBookingInput = {
    id?: number
    logType: string
    logTime?: Date | string
    verificationMethod?: string | null
    verifiedBy?: string | null
    location?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type BookingExtensionCreateManyBookingInput = {
    id?: number
    originalEndTime: Date | string
    newEndTime: Date | string
    additionalCharge: Decimal | DecimalJsLike | number | string
    paymentStatus: string
    requestTime?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type PlaceRatingCreateManyBookingInput = {
    id?: number
    placeId: number
    userId: number
    ratingScore: Decimal | DecimalJsLike | number | string
    reviewComment?: string | null
    ratingDate?: Date | string
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type NotificationCreateManyBookingInput = {
    id?: number
    userId: number
    notificationType: string
    channel: string
    content: string
    isRead?: boolean
    sentTime?: Date | string
    readTime?: Date | string | null
    createdAt?: Date | string
  }

  export type BookingStatusLogUpdateWithoutBookingInput = {
    previousStatus?: StringFieldUpdateOperationsInput | string
    newStatus?: StringFieldUpdateOperationsInput | string
    changedBy?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    statusTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingStatusLogUncheckedUpdateWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    previousStatus?: StringFieldUpdateOperationsInput | string
    newStatus?: StringFieldUpdateOperationsInput | string
    changedBy?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    statusTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingStatusLogUncheckedUpdateManyWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    previousStatus?: StringFieldUpdateOperationsInput | string
    newStatus?: StringFieldUpdateOperationsInput | string
    changedBy?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    statusTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessLogUpdateWithoutBookingInput = {
    logType?: StringFieldUpdateOperationsInput | string
    logTime?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessLogUncheckedUpdateWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    logType?: StringFieldUpdateOperationsInput | string
    logTime?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessLogUncheckedUpdateManyWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    logType?: StringFieldUpdateOperationsInput | string
    logTime?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingExtensionUpdateWithoutBookingInput = {
    originalEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    newEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    additionalCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    requestTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BookingExtensionUncheckedUpdateWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    originalEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    newEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    additionalCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    requestTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BookingExtensionUncheckedUpdateManyWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    originalEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    newEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    additionalCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    requestTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlaceRatingUpdateWithoutBookingInput = {
    ratingScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    ratingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    place?: PlaceUpdateOneRequiredWithoutPlaceRatingsNestedInput
    user?: UserUpdateOneRequiredWithoutPlaceRatingsNestedInput
  }

  export type PlaceRatingUncheckedUpdateWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    placeId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    ratingScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    ratingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlaceRatingUncheckedUpdateManyWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    placeId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    ratingScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    ratingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUpdateWithoutBookingInput = {
    notificationType?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    readTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    notificationType?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    readTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    notificationType?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    readTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentTransactionCreateManyBookingPaymentInput = {
    id?: number
    paymentMethodId: number
    transactionReference?: string | null
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    transactionStatus: string
    gatewayResponse?: string | null
    transactionData?: string | null
    transactionTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type RefundTransactionCreateManyBookingPaymentInput = {
    id?: number
    refundReference?: string | null
    refundAmount: Decimal | DecimalJsLike | number | string
    refundReason?: string | null
    refundStatus: string
    processorResponse?: string | null
    refundData?: string | null
    refundTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type PaymentTransactionUpdateWithoutBookingPaymentInput = {
    transactionReference?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    transactionStatus?: StringFieldUpdateOperationsInput | string
    gatewayResponse?: NullableStringFieldUpdateOperationsInput | string | null
    transactionData?: NullableStringFieldUpdateOperationsInput | string | null
    transactionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: PaymentMethodUpdateOneRequiredWithoutPaymentTransactionsNestedInput
  }

  export type PaymentTransactionUncheckedUpdateWithoutBookingPaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    paymentMethodId?: IntFieldUpdateOperationsInput | number
    transactionReference?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    transactionStatus?: StringFieldUpdateOperationsInput | string
    gatewayResponse?: NullableStringFieldUpdateOperationsInput | string | null
    transactionData?: NullableStringFieldUpdateOperationsInput | string | null
    transactionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentTransactionUncheckedUpdateManyWithoutBookingPaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    paymentMethodId?: IntFieldUpdateOperationsInput | number
    transactionReference?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    transactionStatus?: StringFieldUpdateOperationsInput | string
    gatewayResponse?: NullableStringFieldUpdateOperationsInput | string | null
    transactionData?: NullableStringFieldUpdateOperationsInput | string | null
    transactionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefundTransactionUpdateWithoutBookingPaymentInput = {
    refundReference?: NullableStringFieldUpdateOperationsInput | string | null
    refundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null
    refundStatus?: StringFieldUpdateOperationsInput | string
    processorResponse?: NullableStringFieldUpdateOperationsInput | string | null
    refundData?: NullableStringFieldUpdateOperationsInput | string | null
    refundTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefundTransactionUncheckedUpdateWithoutBookingPaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    refundReference?: NullableStringFieldUpdateOperationsInput | string | null
    refundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null
    refundStatus?: StringFieldUpdateOperationsInput | string
    processorResponse?: NullableStringFieldUpdateOperationsInput | string | null
    refundData?: NullableStringFieldUpdateOperationsInput | string | null
    refundTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefundTransactionUncheckedUpdateManyWithoutBookingPaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    refundReference?: NullableStringFieldUpdateOperationsInput | string | null
    refundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null
    refundStatus?: StringFieldUpdateOperationsInput | string
    processorResponse?: NullableStringFieldUpdateOperationsInput | string | null
    refundData?: NullableStringFieldUpdateOperationsInput | string | null
    refundTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentTransactionCreateManyPaymentMethodInput = {
    id?: number
    paymentId: number
    transactionReference?: string | null
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    transactionStatus: string
    gatewayResponse?: string | null
    transactionData?: string | null
    transactionTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type UserPaymentMethodCreateManyPaymentMethodInput = {
    id?: number
    userId: number
    tokenReference: string
    maskedInfo?: string | null
    expiryInfo?: string | null
    isDefault?: boolean
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type ParkingPassPaymentCreateManyPaymentMethodInput = {
    id?: number
    passId: number
    amount: Decimal | DecimalJsLike | number | string
    paymentStatus: string
    transactionReference?: string | null
    paymentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type PaymentTransactionUpdateWithoutPaymentMethodInput = {
    transactionReference?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    transactionStatus?: StringFieldUpdateOperationsInput | string
    gatewayResponse?: NullableStringFieldUpdateOperationsInput | string | null
    transactionData?: NullableStringFieldUpdateOperationsInput | string | null
    transactionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookingPayment?: BookingPaymentUpdateOneRequiredWithoutPaymentTransactionsNestedInput
  }

  export type PaymentTransactionUncheckedUpdateWithoutPaymentMethodInput = {
    id?: IntFieldUpdateOperationsInput | number
    paymentId?: IntFieldUpdateOperationsInput | number
    transactionReference?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    transactionStatus?: StringFieldUpdateOperationsInput | string
    gatewayResponse?: NullableStringFieldUpdateOperationsInput | string | null
    transactionData?: NullableStringFieldUpdateOperationsInput | string | null
    transactionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentTransactionUncheckedUpdateManyWithoutPaymentMethodInput = {
    id?: IntFieldUpdateOperationsInput | number
    paymentId?: IntFieldUpdateOperationsInput | number
    transactionReference?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    transactionStatus?: StringFieldUpdateOperationsInput | string
    gatewayResponse?: NullableStringFieldUpdateOperationsInput | string | null
    transactionData?: NullableStringFieldUpdateOperationsInput | string | null
    transactionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserPaymentMethodUpdateWithoutPaymentMethodInput = {
    tokenReference?: StringFieldUpdateOperationsInput | string
    maskedInfo?: NullableStringFieldUpdateOperationsInput | string | null
    expiryInfo?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutUserPaymentMethodsNestedInput
  }

  export type UserPaymentMethodUncheckedUpdateWithoutPaymentMethodInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    tokenReference?: StringFieldUpdateOperationsInput | string
    maskedInfo?: NullableStringFieldUpdateOperationsInput | string | null
    expiryInfo?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserPaymentMethodUncheckedUpdateManyWithoutPaymentMethodInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    tokenReference?: StringFieldUpdateOperationsInput | string
    maskedInfo?: NullableStringFieldUpdateOperationsInput | string | null
    expiryInfo?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ParkingPassPaymentUpdateWithoutPaymentMethodInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    transactionReference?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parkingPass?: ParkingPassUpdateOneRequiredWithoutParkingPassPaymentsNestedInput
  }

  export type ParkingPassPaymentUncheckedUpdateWithoutPaymentMethodInput = {
    id?: IntFieldUpdateOperationsInput | number
    passId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    transactionReference?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ParkingPassPaymentUncheckedUpdateManyWithoutPaymentMethodInput = {
    id?: IntFieldUpdateOperationsInput | number
    passId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    transactionReference?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BookingCreateManyPromoCodeInput = {
    id?: number
    userId: number
    vehicleId: number
    slotId: number
    bookingReference: string
    bookingTime?: Date | string
    scheduledEntry: Date | string
    scheduledExit: Date | string
    actualEntry?: Date | string | null
    actualExit?: Date | string | null
    qrCode?: string | null
    bookingStatus: string
    estimatedPrice: Decimal | DecimalJsLike | number | string
    finalPrice?: Decimal | DecimalJsLike | number | string | null
    cancellationReason?: string | null
    cancellationTimeMinutes?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type BookingUpdateWithoutPromoCodeInput = {
    bookingReference?: StringFieldUpdateOperationsInput | string
    bookingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledExit?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualExit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    bookingStatus?: StringFieldUpdateOperationsInput | string
    estimatedPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutBookingsNestedInput
    parkingSlot?: ParkingSlotUpdateOneRequiredWithoutBookingsNestedInput
    bookingStatusLogs?: BookingStatusLogUpdateManyWithoutBookingNestedInput
    bookingPayment?: BookingPaymentUpdateOneWithoutBookingNestedInput
    accessLogs?: AccessLogUpdateManyWithoutBookingNestedInput
    bookingExtensions?: BookingExtensionUpdateManyWithoutBookingNestedInput
    placeRatings?: PlaceRatingUpdateManyWithoutBookingNestedInput
    notifications?: NotificationUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutPromoCodeInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    slotId?: IntFieldUpdateOperationsInput | number
    bookingReference?: StringFieldUpdateOperationsInput | string
    bookingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledExit?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualExit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    bookingStatus?: StringFieldUpdateOperationsInput | string
    estimatedPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookingStatusLogs?: BookingStatusLogUncheckedUpdateManyWithoutBookingNestedInput
    bookingPayment?: BookingPaymentUncheckedUpdateOneWithoutBookingNestedInput
    accessLogs?: AccessLogUncheckedUpdateManyWithoutBookingNestedInput
    bookingExtensions?: BookingExtensionUncheckedUpdateManyWithoutBookingNestedInput
    placeRatings?: PlaceRatingUncheckedUpdateManyWithoutBookingNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutPromoCodeInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    slotId?: IntFieldUpdateOperationsInput | number
    bookingReference?: StringFieldUpdateOperationsInput | string
    bookingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEntry?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledExit?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualExit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    bookingStatus?: StringFieldUpdateOperationsInput | string
    estimatedPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ParkingPassPaymentCreateManyParkingPassInput = {
    id?: number
    paymentMethodId: number
    amount: Decimal | DecimalJsLike | number | string
    paymentStatus: string
    transactionReference?: string | null
    paymentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type ParkingPassPaymentUpdateWithoutParkingPassInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    transactionReference?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: PaymentMethodUpdateOneRequiredWithoutParkingPassPaymentsNestedInput
  }

  export type ParkingPassPaymentUncheckedUpdateWithoutParkingPassInput = {
    id?: IntFieldUpdateOperationsInput | number
    paymentMethodId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    transactionReference?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ParkingPassPaymentUncheckedUpdateManyWithoutParkingPassInput = {
    id?: IntFieldUpdateOperationsInput | number
    paymentMethodId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    transactionReference?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}